<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adobe Commerce Architect Exam Prep (AD0-E722)</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        pre { white-space: pre-wrap; word-wrap: break-word; }
        code { font-family: 'Fira Code', 'Consolas', monospace; }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;

        // Icons as simple SVG components
        const ChevronRight = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9 18l6-6-6-6"/></svg>;
        const ChevronLeft = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M15 18l-6-6 6-6"/></svg>;
        const Check = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3"><path d="M20 6L9 17l-5-5"/></svg>;
        const X = () => <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3"><path d="M18 6L6 18M6 6l12 12"/></svg>;
        const BookOpen = () => <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>;
        const Target = () => <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>;
        const Award = ({size = 70, style}) => <svg width={size} height={size} style={style} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="8" r="6"/><path d="M15.477 12.89L17 22l-5-3-5 3 1.523-9.11"/></svg>;
        const RotateCcw = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>;
        const Shuffle = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M16 3h5v5M4 20L21 3M21 16v5h-5M15 15l6 6M4 4l5 5"/></svg>;
        const Lightbulb = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"/><path d="M9 18h6"/><path d="M10 22h4"/></svg>;
        const Code = () => <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="m18 16 4-4-4-4"/><path d="m6 8-4 4 4 4"/><path d="m14.5 4-5 16"/></svg>;
        const Filter = () => <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></svg>;

        // Quiz Questions Data
        const quizQuestions = [
          {
            id: 1,
            category: "Configuration & XML",
            difficulty: "Hard",
            question: "An Adobe Commerce Architect is working on a scanner that will pull prices from multiple external product feeds. The Architect has a list of vendors and decides to create a new config file marketplace_feeds.xml. Which three steps can the Architect take to ensure validation of the configuration files with unique validation rules for the individual and merged files?",
            options: [
              { id: "A", text: "Implement validation rules in the Converter class for the Config Reader." },
              { id: "B", text: "Create validation rules in marketplace_schema.xsd." },
              { id: "C", text: "Provide schema to validate a merged file." },
              { id: "D", text: "Add the Uniform Resource Name (URN) to the XSD file in the config XML file." },
              { id: "E", text: "Provide schema to validate an individual file." },
              { id: "F", text: "Create a class that implements \\Magento\\Framework\\Config\\DataInterface." }
            ],
            correctAnswers: ["C", "D", "E"],
            explanation: `For custom XML configuration validation in Magento 2, you need three key components:

1. Provide schema to validate an individual file (E): Individual file schemas validate each module's XML file before merging.

2. Provide schema to validate a merged file (C): Merged schemas validate the combined XML after all modules' configs are collected.

3. Add the URN to the XSD file in the config XML file (D): The URN links the XML to its schema for IDE and runtime validation.

Why not the others:
- A: Converter classes transform XML to arrays, not validate
- B: Schema file should match the XML filename pattern
- F: DataInterface is for accessing config data, not validation`,
            codeExample: `// SchemaLocator.php
class SchemaLocator implements SchemaLocatorInterface
{
    protected $schema;        // For merged file
    protected $perFileSchema; // For individual files
    
    public function __construct(Reader $moduleReader) {
        $configDir = $moduleReader->getModuleDir(Dir::MODULE_ETC_DIR, 'Vendor_Module');
        $this->schema = $configDir . '/marketplace_feeds.xsd';
        $this->perFileSchema = $configDir . '/marketplace_feeds_file.xsd';
    }
    
    public function getSchema() { return $this->schema; }
    public function getPerFileSchema() { return $this->perFileSchema; }
}`
          },
          {
            id: 2,
            category: "EAV & Attributes",
            difficulty: "Medium",
            question: "A merchant asks to add a new reward card functionality for customers. The reward_card_number attribute is causing the customer attribute to be unavailable in the My Account/My Rewards page template. What should be added to set the customer attribute correctly?",
            options: [
              { id: "A", text: "group property should be added with a value of 1" },
              { id: "B", text: "system property should be added with a value of true" },
              { id: "C", text: "scope property should be added with a value of global" }
            ],
            correctAnswers: ["A"],
            explanation: `The group property determines which attribute group the attribute belongs to and affects its visibility in templates.

Why Option A is correct:
The group property with a value of 1 assigns the attribute to the "General Information" group, making it visible in frontend templates including My Account pages.

Why B and C are incorrect:
- system = true: Makes it a system attribute, which HIDES it from frontend and admin forms
- scope = global: Controls whether the attribute value is shared across websites, not visibility`,
            codeExample: `$customerSetup->addAttribute(Customer::ENTITY, 'reward_card_number', [
    'type' => 'varchar',
    'label' => 'Reward Card Number',
    'input' => 'text',
    'required' => false,
    'visible' => true,
    'user_defined' => true,
    'system' => false,    // Must be false for custom attributes
    'group' => 1,         // KEY: Assigns to General group for visibility
]);`
          },
          {
            id: 3,
            category: "Indexing",
            difficulty: "Hard",
            question: "A custom product feed export module shows correct prices in testing but incorrect prices in production. Unit and integration tests pass. Which two steps should resolve this issue?",
            options: [
              { id: "A", text: "Reduce the frequency of the cron job to 5 minutes." },
              { id: "B", text: "Make sure no custom or third-party modules modify the changelog and indexing process." },
              { id: "C", text: "Make sure the version_id for the price indexer in mview_state is not higher than the changelog table and synchronize." },
              { id: "D", text: "Invalidate the catalog_product_price indexer in Admin Panel." },
              { id: "E", text: "Manually reindex from command line: bin/magento indexer:reindex catalog_product_price" }
            ],
            correctAnswers: ["B", "C"],
            explanation: `This is a classic MView indexing synchronization issue.

Why B is correct:
Custom or third-party modules may interfere with changelog tables (*_cl) or the indexing process, causing data inconsistencies.

Why C is correct:
The mview_state table tracks version_id values. If version_id is higher than changelog entries, the indexer skips records, causing stale data.

Why A, D, E are not optimal:
- A: Changing cron frequency doesn't fix synchronization
- D & E: Reindexing temporarily fixes but doesn't address root cause`,
            codeExample: `-- Check MView synchronization
SELECT * FROM mview_state WHERE view_id = 'catalog_product_price';
SELECT MAX(version_id) FROM catalog_product_price_cl;

-- Fix: Reset version_id if higher than changelog
UPDATE mview_state 
SET version_id = (SELECT IFNULL(MAX(version_id), 0) FROM catalog_product_price_cl)
WHERE view_id = 'catalog_product_price';`
          },
          {
            id: 4,
            category: "Session & Architecture",
            difficulty: "Hard",
            question: `After deploying a distributed architecture with multiple webservers behind a Load Balancer, users cannot access Customer Dashboard after logging in. Session is configured as:
'session' => ['save' => 'files', 'save_path' => '/var/www/html/var/session']

What should the Architect do?`,
            options: [
              { id: "A", text: "Update the session host value to a shared Redis instance" },
              { id: "B", text: "Increase the session size with config:set system/security/max_session_size_admin" },
              { id: "C", text: "Utilize the Remote Storage module to synchronize sessions between servers" }
            ],
            correctAnswers: ["A"],
            explanation: `In distributed/load-balanced architectures, file-based sessions cause authentication failures because each server has its own local filesystem.

Why A is correct:
Redis provides centralized session storage accessible by all servers. All web servers connect to the same Redis instance, ensuring session data is available regardless of which server handles the request.

Why B and C are incorrect:
- B: Session size limits are unrelated to distributed session sharing
- C: Remote Storage module is for media files, not session management`,
            codeExample: `// Correct env.php for distributed architecture
'session' => [
    'save' => 'redis',
    'redis' => [
        'host' => 'redis.internal',
        'port' => '6379',
        'database' => '2',  // Separate from cache
        'disable_locking' => '0',
        'max_concurrency' => '6',
    ]
],`
          },
          {
            id: 5,
            category: "Deployment & Cloud",
            difficulty: "Hard",
            question: "For optimal zero-downtime deployment on Adobe Commerce Cloud, when should static content be generated?",
            options: [
              { id: "A", text: "During the deploy phase with SCD_ON_DEMAND enabled" },
              { id: "B", text: "During the build phase with config:dump to move locales to config.php" },
              { id: "C", text: "During the post-deploy phase using WARM_UP_PAGES" },
              { id: "D", text: "On-demand when users request pages for the first time" }
            ],
            correctAnswers: ["B"],
            explanation: `For zero-downtime deployments, static content should be generated during the build phase.

Why B is correct:
- Build phase has no database access, but locales can be stored in config.php
- Static content is generated before site goes into maintenance mode
- Content is symlinked during deploy, making it available instantly
- No maintenance downtime for static content generation

Why others are suboptimal:
- A: Deploy phase puts site in maintenance mode
- C: Post-deploy is too late, users already accessing site
- D: On-demand adds load time to user requests`,
            codeExample: `# .magento.env.yaml for optimal SCD
stage:
  build:
    SKIP_SCD: false  # Generate during build
    SCD_STRATEGY: compact
  deploy:
    SKIP_SCD: true  # Skip during deploy

# Before deployment, run:
bin/magento app:config:dump`
          },
          {
            id: 6,
            category: "Plugins & DI",
            difficulty: "Medium",
            question: "A developer needs to modify the product save operation to add custom validation and prevent saving if conditions are not met. Which approach should the Architect recommend?",
            options: [
              { id: "A", text: "Create an after plugin on save() to validate and throw exception if validation fails" },
              { id: "B", text: "Create a before plugin on save() to validate and prevent execution" },
              { id: "C", text: "Create an around plugin on save() to validate and skip proceed() if validation fails" },
              { id: "D", text: "Create a preference for the Product model and override save()" }
            ],
            correctAnswers: ["C"],
            explanation: `When you need to potentially prevent a method from executing, an around plugin is the correct choice.

Why C is correct:
An around plugin allows you to:
1. Execute code before the original method
2. Decide whether to call proceed()
3. Execute code after if needed
4. Completely bypass the original method

Why others are incorrect:
- A (after): Save already happened - too late
- B (before): Cannot prevent method execution
- D (preference): Causes conflicts with other extensions`,
            codeExample: `class ProductSaveValidation
{
    public function aroundSave(
        \\Magento\\Catalog\\Model\\Product $subject,
        callable $proceed
    ) {
        if (!$this->validateProduct($subject)) {
            throw new LocalizedException(__('Validation failed.'));
        }
        return $proceed(); // Only call if validation passes
    }
}`
          },
          {
            id: 7,
            category: "Plugins & DI",
            difficulty: "Hard",
            question: "Which of the following CANNOT be intercepted using plugins in Magento 2?",
            options: [
              { id: "A", text: "Public methods of any class" },
              { id: "B", text: "Final methods and final classes" },
              { id: "C", text: "Protected methods with public wrapper" },
              { id: "D", text: "Interface methods with concrete implementations" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento 2 plugins have specific limitations:

Cannot intercept:
- Final classes and final methods
- Private and protected methods
- Static methods
- __construct() methods
- Virtual types
- Objects instantiated before Interception is bootstrapped
- Objects not instantiated by ObjectManager

Why B is correct:
PHP's final keyword prevents inheritance, and Magento's interceptor pattern requires generating a subclass.`,
            codeExample: `// These CANNOT be intercepted:

// 1. Final class
final class FinalClass {
    public function doSomething() { }  // Cannot intercept
}

// 2. Final method
class SomeClass {
    final public function finalMethod() { }  // Cannot intercept
    public function normalMethod() { }       // CAN intercept
}

// 3. Constructor
class AnyClass {
    public function __construct() { }  // Cannot intercept
}`
          },
          {
            id: 8,
            category: "Service Contracts",
            difficulty: "Medium",
            question: "An Architect is designing a module to expose product data through REST API. Which approach ensures proper API exposure following Adobe Commerce best practices?",
            options: [
              { id: "A", text: "Implement ExtensibleDataInterface for the data model" },
              { id: "B", text: "Create a repository interface extending SearchCriteriaInterface" },
              { id: "C", text: "Implement a repository pattern with interface annotated with @api and configure webapi.xml" },
              { id: "D", text: "Create a controller extending HttpGetActionInterface" }
            ],
            correctAnswers: ["C"],
            explanation: `Adobe Commerce's Web API is designed around Service Contracts using the repository pattern.

Why C is correct:
- Repository interfaces with @api annotation mark them as public API
- webapi.xml maps HTTP routes to service contract methods
- Ensures backward compatibility and proper API versioning

Why others are incorrect:
- A: ExtensibleDataInterface is for data models, not API exposure
- B: SearchCriteriaInterface is for filtering, not repository definition
- D: Controllers are for browser requests, not API endpoints`,
            codeExample: `// Api/CustomRepositoryInterface.php
/**
 * @api
 */
interface CustomRepositoryInterface
{
    /**
     * @param int $id
     * @return CustomInterface
     */
    public function getById($id);
}

// etc/webapi.xml
<route url="/V1/custom/:id" method="GET">
    <service class="Vendor\\Module\\Api\\CustomRepositoryInterface" method="getById"/>
    <resources><resource ref="Vendor_Module::view"/></resources>
</route>`
          },
          {
            id: 9,
            category: "GraphQL",
            difficulty: "Medium",
            question: "An Architect needs to create a custom GraphQL query. Which file must be created to define the GraphQL schema?",
            options: [
              { id: "A", text: "etc/graphql.xml" },
              { id: "B", text: "etc/schema.graphqls" },
              { id: "C", text: "etc/webapi_graphql.xml" },
              { id: "D", text: "etc/graphql/schema.xml" }
            ],
            correctAnswers: ["B"],
            explanation: `GraphQL schemas in Magento 2 are defined in schema.graphqls files.

Why B is correct:
- Located in etc/schema.graphqls
- Uses GraphQL Schema Definition Language (SDL)
- Automatically merged with other modules' schemas
- Defines types, queries, mutations, and resolvers

File naming convention:
- Must be named exactly schema.graphqls
- Must be in the etc directory`,
            codeExample: `# etc/schema.graphqls
type Query {
    customProducts(
        pageSize: Int = 20
    ): CustomProductsOutput
        @resolver(class: "Vendor\\\\Module\\\\Model\\\\Resolver\\\\CustomProducts")
        @doc(description: "Get custom products")
}

type CustomProductsOutput {
    items: [CustomProduct]
    total_count: Int
}`
          },
          {
            id: 10,
            category: "GraphQL",
            difficulty: "Hard",
            question: "When implementing a GraphQL resolver for a mutation that modifies customer data, how should authorization be checked?",
            options: [
              { id: "A", text: "Check $context->getUserId() is not null" },
              { id: "B", text: "Check $context->getExtensionAttributes()->getIsCustomer() is true" },
              { id: "C", text: "Use ACL resources in schema.graphqls" },
              { id: "D", text: "Implement PolicyInterface" }
            ],
            correctAnswers: ["B"],
            explanation: `GraphQL context provides customer authentication status through extension attributes.

Why B is correct:
The getIsCustomer() method on context extension attributes is the standard way to verify customer authentication in GraphQL resolvers.

Pattern:
- Check context for authentication
- Throw GraphQlAuthorizationException if not authenticated
- Then proceed with business logic`,
            codeExample: `class UpdateCustomerData implements ResolverInterface
{
    public function resolve(Field $field, $context, ResolveInfo $info, array $value = null, array $args = null)
    {
        // Check if customer is authenticated
        if (false === $context->getExtensionAttributes()->getIsCustomer()) {
            throw new GraphQlAuthorizationException(__('Not authorized.'));
        }
        
        $customerId = $context->getUserId();
        return $this->updateCustomerData($customerId, $args['input']);
    }
}`
          },
          {
            id: 11,
            category: "Message Queues",
            difficulty: "Hard",
            question: "An Architect is implementing asynchronous processing for large product imports that must survive server restarts. Which configuration approach should be used?",
            options: [
              { id: "A", text: "Use MySQL-based message queues with queue_topology.xml and queue_consumer.xml" },
              { id: "B", text: "Implement Redis pub/sub for real-time message handling" },
              { id: "C", text: "Configure cron jobs to process files from a shared directory" },
              { id: "D", text: "Use PHP sessions to store pending operations" }
            ],
            correctAnswers: ["A"],
            explanation: `For reliable asynchronous processing that survives server restarts, MySQL-based message queues (or RabbitMQ) are the proper solution.

Why A is correct:
- Messages are persisted in the database
- Survives server restarts
- Supports multiple consumers
- Built-in retry mechanisms

Why others are incorrect:
- B: Redis pub/sub is volatile - messages lost on restart
- C: Cron-based file processing lacks queue semantics
- D: Sessions are per-user and volatile`,
            codeExample: `<!-- etc/queue_topology.xml -->
<exchange name="vendor.exchange" type="topic" connection="db">
    <binding id="importBinding" topic="vendor.product.import" 
             destinationType="queue" destination="vendor.import.queue"/>
</exchange>

<!-- etc/queue_consumer.xml -->
<consumer name="importConsumer" queue="vendor.import.queue"
          handler="Vendor\\Module\\Model\\Consumer::process" connection="db"/>`
          },
          {
            id: 12,
            category: "Performance",
            difficulty: "Hard",
            question: "Category pages are slow despite FPC being enabled. The first request to each page is still slow. Which optimization should be implemented?",
            options: [
              { id: "A", text: "Implement Varnish ESI (Edge Side Includes) for dynamic blocks" },
              { id: "B", text: "Enable flat catalog tables for categories and products" },
              { id: "C", text: "Increase PHP memory_limit and max_execution_time" },
              { id: "D", text: "Disable all third-party modules temporarily" }
            ],
            correctAnswers: ["A"],
            explanation: `When FPC is working but initial requests are slow, the issue is often dynamic content that fragments the cache.

Why A is correct:
- Varnish ESI allows caching the main page while loading dynamic blocks separately
- Reduces cache fragmentation
- Dynamic content loads asynchronously
- Main page content can be cached longer

Why others are less optimal:
- B: Flat catalogs are deprecated
- C: Addresses symptoms, not root cause
- D: Diagnostic step, not a solution`,
            codeExample: `<!-- Mark block as ESI in layout XML -->
<block class="Vendor\\Module\\Block\\DynamicContent" 
       name="dynamic.content"
       ttl="0">  <!-- ttl="0" = private/dynamic -->
</block>

// Block must implement IdentityInterface
class DynamicContent extends Template implements IdentityInterface
{
    public function getIdentities() {
        return ['dynamic_content_' . $this->getCustomerId()];
    }
}`
          },
          {
            id: 13,
            category: "EAV & Attributes",
            difficulty: "Hard",
            question: "An Architect needs to create a product attribute requiring custom validation before saving and custom formatting when displayed. Which EAV model components should be implemented?",
            options: [
              { id: "A", text: "Backend model for validation, Frontend model for display formatting" },
              { id: "B", text: "Source model for validation, Backend model for display formatting" },
              { id: "C", text: "Frontend model for validation, Source model for display formatting" },
              { id: "D", text: "Backend model for both validation and display formatting" }
            ],
            correctAnswers: ["A"],
            explanation: `EAV attributes use three specialized model types:

Backend Model: Handles data processing during save/load
- beforeSave() - validation and transformation
- afterSave() - post-save operations
- afterLoad() - data processing on load

Frontend Model: Controls how values are displayed
- getValue() - formats the value for display

Source Model: Provides option values for select/multiselect

Why A is correct:
Backend model's validate() handles validation, Frontend model's getValue() handles display formatting.`,
            codeExample: `// Backend Model - for validation
class CustomValidation extends AbstractBackend
{
    public function validate($object) {
        $value = $object->getData($this->getAttribute()->getAttributeCode());
        if (!$this->isValid($value)) {
            throw new LocalizedException(__('Invalid value'));
        }
        return true;
    }
}

// Frontend Model - for display
class CustomDisplay extends AbstractFrontend
{
    public function getValue(DataObject $object) {
        $value = $object->getData($this->getAttribute()->getAttributeCode());
        return '<strong>' . htmlspecialchars($value) . '</strong>';
    }
}`
          },
          {
            id: 14,
            category: "Multi-Store",
            difficulty: "Medium",
            question: "For a multi-language, multi-currency site, which attribute scope should be used for product prices that need different values per website?",
            options: [
              { id: "A", text: "SCOPE_GLOBAL" },
              { id: "B", text: "SCOPE_WEBSITE" },
              { id: "C", text: "SCOPE_STORE" },
              { id: "D", text: "SCOPE_STOREVIEW" }
            ],
            correctAnswers: ["B"],
            explanation: `Product prices typically use SCOPE_WEBSITE for multi-currency setups.

Scope levels:
- GLOBAL: Same value across all websites/stores
- WEBSITE: Different value per website (currency level)
- STORE: Different value per store (rarely used for price)
- STOREVIEW: Different value per store view (language level)

Why B is correct:
Prices are tied to currency, and currency is configured at the website level. Each website can have its own base currency and price values.`,
            codeExample: `$eavSetup->addAttribute(Product::ENTITY, 'special_price_b2b', [
    'type' => 'decimal',
    'label' => 'B2B Special Price',
    'input' => 'price',
    'global' => ScopedAttributeInterface::SCOPE_WEBSITE,  // Website scope
    'visible' => true,
    'required' => false,
]);

// Scopes: SCOPE_GLOBAL=1, SCOPE_WEBSITE=2, SCOPE_STORE=0`
          },
          {
            id: 15,
            category: "Security",
            difficulty: "Medium",
            question: "An Architect needs to implement a custom admin action that modifies sensitive data. Which security measure is required to prevent CSRF attacks?",
            options: [
              { id: "A", text: "Add 'form_key' parameter validation in the controller" },
              { id: "B", text: "Implement custom authentication middleware" },
              { id: "C", text: "Use HTTPS for all requests" },
              { id: "D", text: "Add IP whitelist in .htaccess" }
            ],
            correctAnswers: ["A"],
            explanation: `Magento's form_key mechanism protects against CSRF attacks.

Why A is correct:
- form_key is a unique token generated per session
- Must be included in all state-changing requests
- Validated automatically by extending correct base classes

Implementation:
- Admin controllers should extend \\Magento\\Backend\\App\\Action
- Use _isAllowed() for ACL checks
- Form key validation is built-in`,
            codeExample: `class Save extends \\Magento\\Backend\\App\\Action
{
    const ADMIN_RESOURCE = 'Vendor_Module::save';
    
    public function execute() {
        // Form key is automatically validated by parent
        // Manual validation if needed:
        if (!$this->_formKeyValidator->validate($this->getRequest())) {
            throw new LocalizedException(__('Invalid form key.'));
        }
    }
    
    protected function _isAllowed() {
        return $this->_authorization->isAllowed(self::ADMIN_RESOURCE);
    }
}`
          },
          {
            id: 16,
            category: "Database",
            difficulty: "Hard",
            question: "An Architect needs to create a custom table with a foreign key to catalog_product_entity. Which db_schema approach ensures referential integrity while handling product deletion properly?",
            options: [
              { id: "A", text: "Use CASCADE for onDelete action" },
              { id: "B", text: "Use SET NULL for onDelete action with nullable column" },
              { id: "C", text: "Use NO ACTION and handle deletion in observer" },
              { id: "D", text: "Skip foreign key and use application-level validation" }
            ],
            correctAnswers: ["A"],
            explanation: `For custom tables referencing products, CASCADE is typically the correct choice.

Why A is correct:
- When a product is deleted, related custom data is automatically deleted
- Maintains referential integrity at database level
- No orphaned records
- Standard practice for dependent data

Considerations:
- CASCADE: Delete dependent records automatically
- SET NULL: Keep record but remove reference
- NO ACTION: Prevent deletion if references exist`,
            codeExample: `<!-- db_schema.xml -->
<table name="vendor_product_custom" resource="default" engine="innodb">
    <column xsi:type="int" name="entity_id" nullable="false" identity="true"/>
    <column xsi:type="int" name="product_id" nullable="false"/>
    <column xsi:type="varchar" name="custom_data" length="255"/>
    
    <constraint xsi:type="primary" referenceId="PRIMARY">
        <column name="entity_id"/>
    </constraint>
    
    <constraint xsi:type="foreign" referenceId="FK_PRODUCT_ID"
                table="vendor_product_custom" column="product_id"
                referenceTable="catalog_product_entity" referenceColumn="entity_id"
                onDelete="CASCADE"/>
</table>`
          },
          {
            id: 17,
            category: "Testing",
            difficulty: "Medium",
            question: "Which testing framework should be used for testing service contracts and repositories?",
            options: [
              { id: "A", text: "Unit tests with PHPUnit mocks" },
              { id: "B", text: "Integration tests with the Magento testing framework" },
              { id: "C", text: "API functional tests with REST/GraphQL" },
              { id: "D", text: "MFTF (Magento Functional Testing Framework) tests" }
            ],
            correctAnswers: ["B"],
            explanation: `Service contracts and repositories should be tested with Integration tests.

Why B is correct:
- Integration tests use real database and Magento infrastructure
- Test actual DI configuration and preferences
- Verify repository methods work with real data
- Test the complete service layer

Test type guidelines:
- Unit tests: Isolated class logic with mocked dependencies
- Integration tests: Service contracts, repositories, modules
- API functional tests: REST/GraphQL endpoint behavior
- MFTF: UI/browser-based scenarios`,
            codeExample: `class CustomRepositoryTest extends \\PHPUnit\\Framework\\TestCase
{
    protected function setUp(): void {
        $this->objectManager = Bootstrap::getObjectManager();
        $this->repository = $this->objectManager->get(CustomRepositoryInterface::class);
    }
    
    /**
     * @magentoDataFixture Vendor_Module::Test/_files/custom_entity.php
     */
    public function testGetById() {
        $entity = $this->repository->getById(1);
        $this->assertEquals('Test Name', $entity->getName());
    }
}`
          },
          {
            id: 18,
            category: "Events & Observers",
            difficulty: "Medium",
            question: "When should an Architect recommend using an observer instead of a plugin?",
            options: [
              { id: "A", text: "When modifying method return values" },
              { id: "B", text: "When responding to specific application events dispatched by Magento" },
              { id: "C", text: "When preventing a method from executing" },
              { id: "D", text: "When modifying method input parameters" }
            ],
            correctAnswers: ["B"],
            explanation: `Observers and plugins serve different purposes:

Observers are best for:
- Responding to dispatched events (event-driven architecture)
- Multiple unrelated actions after an event
- Cross-cutting concerns that shouldn't modify core behavior

Plugins are best for:
- Modifying specific method behavior
- Changing inputs/outputs of methods
- Conditional method execution

Why B is correct:
Observers listen to specific events and react to them, which is their primary purpose.`,
            codeExample: `// Observer - responds to event
// events.xml
<event name="sales_order_place_after">
    <observer name="vendor_notification" instance="Vendor\\Module\\Observer\\OrderPlaceAfter"/>
</event>

class OrderPlaceAfter implements ObserverInterface
{
    public function execute(Observer $observer) {
        $order = $observer->getEvent()->getOrder();
        $this->sendNotification($order);
    }
}`
          },
          {
            id: 19,
            category: "Code Architecture",
            difficulty: "Medium",
            question: "According to Adobe Commerce best practices, where should business logic be placed?",
            options: [
              { id: "A", text: "In Controllers" },
              { id: "B", text: "In Blocks/ViewModels" },
              { id: "C", text: "In Service classes and Models" },
              { id: "D", text: "In Helpers" }
            ],
            correctAnswers: ["C"],
            explanation: `Business logic should be encapsulated in Service classes and Models following the Service Contract pattern.

Why C is correct:
- Service classes expose business operations through interfaces
- Models contain entity-specific logic
- Promotes reusability across REST, GraphQL, and UI
- Enables proper unit testing

Layer responsibilities:
- Controllers: Request handling, routing
- Blocks/ViewModels: Presentation logic only
- Services/Models: Business logic
- Helpers: Utility functions (minimal use recommended)`,
            codeExample: `// Service class with business logic
class OrderProcessor implements OrderProcessorInterface
{
    public function processOrder(OrderInterface $order): ProcessResultInterface {
        $this->validateOrder($order);
        $this->calculateTotals($order);
        return $this->createResult($order);
    }
}

// Controller just delegates to service
class Process extends Action
{
    public function execute() {
        $order = $this->orderRepository->get($this->getRequest()->getParam('order_id'));
        $result = $this->orderProcessor->processOrder($order);
        return $this->resultJson->setData($result->toArray());
    }
}`
          },
          {
            id: 20,
            category: "Cloud Infrastructure",
            difficulty: "Hard",
            question: "On Adobe Commerce Cloud, what is the correct way to add environment-specific configuration that should not be committed to the repository?",
            options: [
              { id: "A", text: "Modify app/etc/env.php directly on the server" },
              { id: "B", text: "Use environment variables in the Cloud Console" },
              { id: "C", text: "Create a config.local.php file" },
              { id: "D", text: "Use .magento.env.yaml for all configurations" }
            ],
            correctAnswers: ["B"],
            explanation: `Adobe Commerce Cloud uses environment variables for environment-specific configuration.

Why B is correct:
- Environment variables are set in Cloud Console or CLI
- Not stored in repository
- Different values per environment (staging, production)
- Secure storage for sensitive data
- Override env.php values at runtime

Configuration hierarchy:
1. env.php (committed)
2. .magento.env.yaml (committed)
3. Environment variables (not committed) - highest priority`,
            codeExample: `# Set environment variable via CLI:
magento-cloud variable:set SOME_API_KEY "secret_value" --level environment

# Reference in env.php using MAGENTO_DC_ prefix:
# MAGENTO_DC_SESSION__SAVE=redis
# Converts to: 'session' => ['save' => 'redis']

# For sensitive data, use Cloud variables:
# CRYPT_KEY, DATABASE_URL, REDIS_URL
# These are automatically injected`
          },
          {
            id: 21,
            category: "Configuration & XML",
            difficulty: "Medium",
            question: "When a module needs to modify layout updates from another module, which approach should an Architect recommend?",
            options: [
              { id: "A", text: "Override the original layout XML file in app/design" },
              { id: "B", text: "Use layout XML with the same handle name to add, remove, or move elements" },
              { id: "C", text: "Create a plugin on the Layout\\Merge class" },
              { id: "D", text: "Modify the original module's layout file directly" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento's layout system is designed for declarative customization through XML merging.

Why B is correct:
- Layout XML files with the same handle are merged automatically
- Use <referenceBlock> to modify existing blocks
- Use <move> to relocate elements
- Use <remove> to hide elements
- Non-invasive and upgrade-safe

Why others are incorrect:
- A: Theme overrides work but module-level changes should use module layout
- C: Plugins on Layout\\Merge are complex and error-prone
- D: Never modify core/vendor files directly`,
            codeExample: `<!-- Vendor/Module/view/frontend/layout/catalog_product_view.xml -->
<page xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <body>
        <!-- Modify existing block -->
        <referenceBlock name="product.info.details">
            <block class="Vendor\\Module\\Block\\CustomTab" name="custom.tab"
                   template="Vendor_Module::product/tab.phtml"/>
        </referenceBlock>

        <!-- Move element -->
        <move element="product.info.sku" destination="product.info.main" after="product.info.price"/>

        <!-- Remove element -->
        <referenceBlock name="catalog.compare.sidebar" remove="true"/>
    </body>
</page>`
          },
          {
            id: 22,
            category: "Dependency Injection",
            difficulty: "Hard",
            question: "An Architect needs to replace a service implementation only for a specific area (adminhtml). Which di.xml configuration approach is correct?",
            options: [
              { id: "A", text: "Create di.xml in etc/ with area-specific <preference>" },
              { id: "B", text: "Create di.xml in etc/adminhtml/ with the <preference> tag" },
              { id: "C", text: "Use a plugin with <area> attribute in etc/di.xml" },
              { id: "D", text: "Create separate module for adminhtml area only" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento's area-specific configuration allows different implementations per area.

Why B is correct:
- Files in etc/adminhtml/ only apply to admin area
- etc/frontend/ for storefront
- etc/webapi_rest/ for REST API
- etc/graphql/ for GraphQL
- Preference in area-specific di.xml cleanly replaces only for that area

Why others are incorrect:
- A: etc/di.xml applies globally to all areas
- C: Plugins don't have area attribute in di.xml
- D: Unnecessary complexity when area-specific config exists`,
            codeExample: `<!-- etc/adminhtml/di.xml - Only applies to admin -->
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="urn:magento:framework:ObjectManager/etc/config.xsd">
    <preference for="Vendor\\Module\\Api\\ServiceInterface"
                type="Vendor\\Module\\Model\\Admin\\Service"/>
</config>

<!-- etc/frontend/di.xml - Only applies to storefront -->
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="urn:magento:framework:ObjectManager/etc/config.xsd">
    <preference for="Vendor\\Module\\Api\\ServiceInterface"
                type="Vendor\\Module\\Model\\Frontend\\Service"/>
</config>`
          },
          {
            id: 23,
            category: "Dependency Injection",
            difficulty: "Hard",
            question: "When should an Architect use a Proxy class in Magento 2?",
            options: [
              { id: "A", text: "When the dependency is always used in every method call" },
              { id: "B", text: "When a class has expensive constructor dependencies that aren't always needed" },
              { id: "C", text: "When implementing the Observer pattern" },
              { id: "D", text: "When creating API endpoints" }
            ],
            correctAnswers: ["B"],
            explanation: `Proxies implement lazy loading for expensive dependencies.

Why B is correct:
- Proxy delays instantiation until first method call
- Reduces memory/CPU when dependency isn't used
- Useful in console commands, cron jobs, or conditional logic
- Auto-generated by Magento's code generation

Why others are incorrect:
- A: If always used, Proxy adds overhead without benefit
- C: Observers use different pattern (event dispatcher)
- D: API endpoints don't specifically require proxies`,
            codeExample: `<!-- di.xml - Using Proxy for expensive dependency -->
<type name="Vendor\\Module\\Model\\HeavyProcessor">
    <arguments>
        <!-- Proxy delays instantiation of ExpensiveService -->
        <argument name="expensiveService"
                  xsi:type="object">Magento\\Catalog\\Model\\Product\\Gallery\\Processor\\Proxy</argument>
    </arguments>
</type>

// PHP class receiving the proxy
class HeavyProcessor
{
    public function __construct(
        private readonly Processor $expensiveService  // Actually a Proxy
    ) {}

    public function process($condition)
    {
        if ($condition) {
            // ExpensiveService only instantiated here when actually needed
            $this->expensiveService->doSomething();
        }
    }
}`
          },
          {
            id: 24,
            category: "Dependency Injection",
            difficulty: "Medium",
            question: "What is the purpose of a Virtual Type in Magento 2's dependency injection?",
            options: [
              { id: "A", text: "To create abstract classes that cannot be instantiated" },
              { id: "B", text: "To create a new class alias with different constructor arguments without writing PHP code" },
              { id: "C", text: "To implement interfaces without concrete classes" },
              { id: "D", text: "To mock classes for unit testing" }
            ],
            correctAnswers: ["B"],
            explanation: `Virtual Types allow creating class variations through configuration only.

Why B is correct:
- Virtual Type creates a "named configuration" of an existing class
- Allows different argument values without PHP inheritance
- Useful for creating specialized instances (e.g., different loggers)
- Reduces PHP code for simple variations

Why others are incorrect:
- A: Abstract classes are PHP constructs, not DI configuration
- C: Interfaces still need concrete implementations
- D: Testing uses mocks/stubs, not virtual types`,
            codeExample: `<!-- Creating virtual types for different logger channels -->
<virtualType name="Vendor\\Module\\Logger\\DebugLogger" type="Magento\\Framework\\Logger\\Monolog">
    <arguments>
        <argument name="name" xsi:type="string">vendor_debug</argument>
        <argument name="handlers" xsi:type="array">
            <item name="debug" xsi:type="object">Vendor\\Module\\Logger\\Handler\\Debug</item>
        </argument>
    </arguments>
</virtualType>

<virtualType name="Vendor\\Module\\Logger\\ErrorLogger" type="Magento\\Framework\\Logger\\Monolog">
    <arguments>
        <argument name="name" xsi:type="string">vendor_error</argument>
        <argument name="handlers" xsi:type="array">
            <item name="error" xsi:type="object">Vendor\\Module\\Logger\\Handler\\Error</item>
        </argument>
    </arguments>
</virtualType>

<!-- Using the virtual types -->
<type name="Vendor\\Module\\Model\\SomeClass">
    <arguments>
        <argument name="logger" xsi:type="object">Vendor\\Module\\Logger\\DebugLogger</argument>
    </arguments>
</type>`
          },
          {
            id: 25,
            category: "Caching",
            difficulty: "Hard",
            question: "A merchant reports that product updates are not immediately visible on the storefront despite clearing the cache. Which cache mechanism is most likely causing this issue?",
            options: [
              { id: "A", text: "Block HTML Output cache" },
              { id: "B", text: "Full Page Cache with cache tags not properly implemented" },
              { id: "C", text: "Configuration cache" },
              { id: "D", text: "Layout cache" }
            ],
            correctAnswers: ["B"],
            explanation: `Full Page Cache with improper cache tag implementation causes stale content.

Why B is correct:
- FPC stores entire HTML pages
- Cache tags link content to entities (products, categories)
- If block doesn't declare proper identities, FPC won't invalidate
- Product updates trigger cache invalidation via cache tags

Why others are incorrect:
- A: Block cache is for specific blocks, less common issue
- C: Config cache doesn't affect product data display
- D: Layout cache affects structure, not content`,
            codeExample: `// Block must implement IdentityInterface for proper FPC invalidation
class ProductInfo extends Template implements IdentityInterface
{
    public function getIdentities()
    {
        // Return cache tags that will trigger invalidation
        $identities = [];
        if ($product = $this->getProduct()) {
            $identities = $product->getIdentities();
            // Returns: ['cat_p_123', 'cat_p']
        }
        return $identities;
    }
}

// Product model already implements this:
class Product implements IdentityInterface
{
    public function getIdentities()
    {
        return [self::CACHE_TAG . '_' . $this->getId(), self::CACHE_TAG];
    }
}`
          },
          {
            id: 26,
            category: "Caching",
            difficulty: "Medium",
            question: "Which cache type should be cleared after modifying system configuration values programmatically?",
            options: [
              { id: "A", text: "Full Page Cache only" },
              { id: "B", text: "Configuration cache" },
              { id: "C", text: "Layout cache" },
              { id: "D", text: "All caches must be cleared" }
            ],
            correctAnswers: ["B"],
            explanation: `Configuration cache stores merged system configuration.

Why B is correct:
- config cache stores compiled system.xml values
- After programmatic config changes, this cache must be refreshed
- Use CacheInterface to clean specific cache type
- Other caches (FPC, layout) may also need clearing depending on what changed

Why others are incorrect:
- A: FPC is for page output, not config storage
- C: Layout cache is for layout XML, not system config
- D: Clearing all is wasteful when only config changed`,
            codeExample: `// Programmatically clearing config cache after changes
use Magento\\Framework\\App\\Cache\\TypeListInterface;
use Magento\\Framework\\App\\Cache\\Type\\Config;

class ConfigUpdater
{
    public function __construct(
        private TypeListInterface $cacheTypeList,
        private \\Magento\\Framework\\App\\Config\\Storage\\WriterInterface $configWriter
    ) {}

    public function updateConfig(string $path, string $value): void
    {
        $this->configWriter->save($path, $value);

        // Clean config cache
        $this->cacheTypeList->cleanType(Config::TYPE_IDENTIFIER);

        // If config affects FPC (e.g., store name), also clean FPC
        // $this->cacheTypeList->cleanType('full_page');
    }
}`
          },
          {
            id: 27,
            category: "JavaScript & Frontend",
            difficulty: "Medium",
            question: "How should an Architect add a custom JavaScript module that depends on jQuery in Magento 2?",
            options: [
              { id: "A", text: "Add <script> tag directly in the template" },
              { id: "B", text: "Define the module in requirejs-config.js with jquery dependency" },
              { id: "C", text: "Include jQuery and the script in the <head> section" },
              { id: "D", text: "Use PHP to inject JavaScript into the page" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento 2 uses RequireJS for JavaScript module loading and dependency management.

Why B is correct:
- requirejs-config.js defines module paths and dependencies
- jQuery is available as 'jquery' shim
- Ensures proper load order and dependency resolution
- Supports bundling and optimization

Why others are incorrect:
- A: Bypasses RequireJS, causes load order issues
- C: Breaks RequireJS optimization and bundling
- D: Mixing PHP and JS is poor architecture`,
            codeExample: `// requirejs-config.js
var config = {
    map: {
        '*': {
            'customModule': 'Vendor_Module/js/custom-module'
        }
    },
    paths: {
        'customLibrary': 'Vendor_Module/js/lib/custom-library'
    }
};

// js/custom-module.js
define([
    'jquery',
    'mage/translate',
    'customLibrary'
], function($, $t, customLib) {
    'use strict';

    return function(config, element) {
        $(element).on('click', function() {
            customLib.doSomething();
            alert($t('Translated message'));
        });
    };
});

// Usage in template with data-mage-init
<div data-mage-init='{"customModule": {"option": "value"}}'></div>`
          },
          {
            id: 28,
            category: "JavaScript & Frontend",
            difficulty: "Hard",
            question: "An Architect needs to customize the checkout address validation in Magento 2. Which approach follows best practices for UI Component customization?",
            options: [
              { id: "A", text: "Override the checkout_index_index.xml layout completely" },
              { id: "B", text: "Create a mixin for the address validation JS component" },
              { id: "C", text: "Modify the vendor JavaScript file directly" },
              { id: "D", text: "Replace the entire checkout module with a custom one" }
            ],
            correctAnswers: ["B"],
            explanation: `Mixins allow extending JavaScript components without full replacement.

Why B is correct:
- Mixins extend existing functionality non-invasively
- Multiple modules can add mixins to same component
- Preserved during upgrades
- Minimal code duplication

Why others are incorrect:
- A: Full layout override is heavy-handed for validation change
- C: Never modify vendor files
- D: Extreme overkill for validation customization`,
            codeExample: `// requirejs-config.js
var config = {
    config: {
        mixins: {
            'Magento_Checkout/js/model/address-converter': {
                'Vendor_Module/js/model/address-converter-mixin': true
            }
        }
    }
};

// js/model/address-converter-mixin.js
define([], function() {
    'use strict';

    return function(addressConverter) {
        // Store original function
        var originalFormAddressDataToQuoteAddress = addressConverter.formAddressDataToQuoteAddress;

        // Extend with custom validation
        addressConverter.formAddressDataToQuoteAddress = function(formData) {
            // Custom validation logic
            if (!this.validateCustomField(formData)) {
                throw new Error('Custom validation failed');
            }

            // Call original
            return originalFormAddressDataToQuoteAddress.call(this, formData);
        };

        addressConverter.validateCustomField = function(formData) {
            // Custom validation
            return true;
        };

        return addressConverter;
    };
});`
          },
          {
            id: 29,
            category: "Checkout & Orders",
            difficulty: "Hard",
            question: "When implementing a custom total collector for the shopping cart, which class should be extended and which configuration file declares it?",
            options: [
              { id: "A", text: "Extend AbstractTotal and configure in sales.xml" },
              { id: "B", text: "Extend Quote\\Address\\Total\\AbstractTotal and configure in sales.xml" },
              { id: "C", text: "Implement TotalInterface and configure in di.xml" },
              { id: "D", text: "Extend Order\\Total\\AbstractTotal and configure in checkout.xml" }
            ],
            correctAnswers: ["B"],
            explanation: `Quote totals are collected by extending AbstractTotal and declaring in sales.xml.

Why B is correct:
- Quote\\Address\\Total\\AbstractTotal is the base for quote totals
- sales.xml defines collectors and their sort order
- Totals are collected in sequence based on sort_order
- Supports both quote and order totals configuration

Why others are incorrect:
- A: Need specific Quote\\Address\\Total namespace
- C: No TotalInterface - uses abstract class pattern
- D: Order totals are separate; checkout.xml doesn't exist for this`,
            codeExample: `<!-- etc/sales.xml -->
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Sales:etc/sales.xsd">
    <section name="quote">
        <group name="totals">
            <item name="custom_fee" instance="Vendor\\Module\\Model\\Total\\CustomFee" sort_order="450"/>
        </group>
    </section>
</config>

// Model/Total/CustomFee.php
class CustomFee extends \\Magento\\Quote\\Model\\Quote\\Address\\Total\\AbstractTotal
{
    public function collect(
        Quote $quote,
        ShippingAssignmentInterface $shippingAssignment,
        Total $total
    ) {
        parent::collect($quote, $shippingAssignment, $total);

        $fee = 5.00; // Calculate your fee
        $total->setTotalAmount('custom_fee', $fee);
        $total->setBaseTotalAmount('custom_fee', $fee);

        return $this;
    }

    public function fetch(Quote $quote, Total $total)
    {
        return [
            'code' => 'custom_fee',
            'title' => __('Custom Fee'),
            'value' => $total->getTotalAmount('custom_fee')
        ];
    }
}`
          },
          {
            id: 30,
            category: "Checkout & Orders",
            difficulty: "Medium",
            question: "What is the correct way to add a custom step to the Magento 2 checkout process?",
            options: [
              { id: "A", text: "Modify the checkout_index_index.xml layout file" },
              { id: "B", text: "Create a new controller and redirect from the standard checkout" },
              { id: "C", text: "Add a UI Component in checkout_index_index.xml and create the corresponding JS component" },
              { id: "D", text: "Override the Onepage controller" }
            ],
            correctAnswers: ["C"],
            explanation: `Checkout steps in Magento 2 are UI Components configured in layout XML.

Why C is correct:
- Checkout is built with UI Components (Knockout.js based)
- Steps are defined in checkout_index_index.xml under checkout component
- Each step has a JS component handling logic and a template for UI
- Allows adding steps without modifying core

Why others are incorrect:
- A: Modifying isn't wrong but must add UI Component specifically
- B: Redirection breaks the SPA checkout flow
- D: Checkout uses UI Components, not traditional controllers`,
            codeExample: `<!-- checkout_index_index.xml -->
<page layout="checkout">
    <body>
        <referenceBlock name="checkout.root">
            <arguments>
                <argument name="jsLayout" xsi:type="array">
                    <item name="components" xsi:type="array">
                        <item name="checkout" xsi:type="array">
                            <item name="children" xsi:type="array">
                                <item name="steps" xsi:type="array">
                                    <item name="children" xsi:type="array">
                                        <item name="custom-step" xsi:type="array">
                                            <item name="component" xsi:type="string">Vendor_Module/js/view/custom-step</item>
                                            <item name="sortOrder" xsi:type="string">1</item>
                                            <item name="children" xsi:type="array">
                                                <!-- step children -->
                                            </item>
                                        </item>
                                    </item>
                                </item>
                            </item>
                        </item>
                    </item>
                </argument>
            </arguments>
        </referenceBlock>
    </body>
</page>`
          },
          {
            id: 31,
            category: "Order Management",
            difficulty: "Medium",
            question: "An Architect needs to add custom logic when an order transitions from 'pending' to 'processing' state. What is the recommended approach?",
            options: [
              { id: "A", text: "Create a plugin on the Order save method" },
              { id: "B", text: "Create an observer for the sales_order_state_change_before event" },
              { id: "C", text: "Modify the Order model directly" },
              { id: "D", text: "Override the Order resource model" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento dispatches events for order state changes, making observers ideal.

Why B is correct:
- sales_order_state_change_before fires when state changes
- Observer can access old and new state
- Non-invasive approach
- Multiple modules can observe same event

Why others are incorrect:
- A: Plugin on save doesn't specifically target state changes
- C/D: Never modify core classes directly`,
            codeExample: `<!-- events.xml -->
<event name="sales_order_state_change_before">
    <observer name="vendor_order_state_change"
              instance="Vendor\\Module\\Observer\\OrderStateChange"/>
</event>

// Observer/OrderStateChange.php
class OrderStateChange implements ObserverInterface
{
    public function execute(Observer $observer)
    {
        $order = $observer->getEvent()->getOrder();
        $oldState = $order->getOrigData('state');
        $newState = $order->getState();

        if ($oldState === Order::STATE_PENDING_PAYMENT
            && $newState === Order::STATE_PROCESSING) {
            // Custom logic for pending -> processing
            $this->processOrderTransition($order);
        }
    }
}`
          },
          {
            id: 32,
            category: "Payment Integration",
            difficulty: "Hard",
            question: "When implementing a custom payment method that requires redirect to external gateway, which interface must be implemented?",
            options: [
              { id: "A", text: "Magento\\Payment\\Model\\MethodInterface" },
              { id: "B", text: "Magento\\Payment\\Gateway\\ConfigInterface" },
              { id: "C", text: "Magento\\Checkout\\Model\\ConfigProviderInterface and payment gateway facade" },
              { id: "D", text: "Magento\\Payment\\Model\\Method\\AbstractMethod" }
            ],
            correctAnswers: ["C"],
            explanation: `Payment methods in Magento 2 use the Payment Gateway framework with config providers.

Why C is correct:
- ConfigProviderInterface provides checkout config to JS
- Payment Gateway facade handles payment operations
- Supports redirect flow with proper configuration
- Modern approach replacing deprecated AbstractMethod

Why others are incorrect:
- A: MethodInterface is legacy, prefer Gateway
- B: ConfigInterface is for gateway config, not the full method
- D: AbstractMethod is deprecated in favor of Gateway`,
            codeExample: `// ConfigProvider for checkout JS
class ConfigProvider implements ConfigProviderInterface
{
    public function getConfig()
    {
        return [
            'payment' => [
                'custom_gateway' => [
                    'redirectUrl' => $this->urlBuilder->getUrl('custom/payment/redirect'),
                    'isActive' => $this->config->isActive()
                ]
            ]
        ];
    }
}

// payment.xml facade configuration
<virtualType name="CustomPaymentFacade" type="Magento\\Payment\\Model\\Method\\Adapter">
    <arguments>
        <argument name="code" xsi:type="const">Vendor\\Module\\Model\\Ui\\ConfigProvider::CODE</argument>
        <argument name="formBlockType" xsi:type="string">Magento\\Payment\\Block\\Form</argument>
        <argument name="infoBlockType" xsi:type="string">Vendor\\Module\\Block\\Info</argument>
        <argument name="valueHandlerPool" xsi:type="object">CustomPaymentValueHandlerPool</argument>
        <argument name="commandPool" xsi:type="object">CustomPaymentCommandPool</argument>
    </arguments>
</virtualType>`
          },
          {
            id: 33,
            category: "Shipping",
            difficulty: "Medium",
            question: "Which class must be extended to create a custom shipping carrier in Magento 2?",
            options: [
              { id: "A", text: "Magento\\Shipping\\Model\\Carrier\\AbstractCarrier" },
              { id: "B", text: "Magento\\Quote\\Model\\Quote\\Address\\RateResult\\Method" },
              { id: "C", text: "Magento\\Shipping\\Model\\Rate\\Result" },
              { id: "D", text: "Magento\\Framework\\DataObject" }
            ],
            correctAnswers: ["A"],
            explanation: `Custom shipping carriers extend AbstractCarrier and implement CarrierInterface.

Why A is correct:
- AbstractCarrier provides base shipping carrier functionality
- Requires implementing collectRates() method
- Must also implement CarrierInterface
- Handles configuration, tracking, and rate calculation

Why others are incorrect:
- B: Method is a rate result object, not carrier
- C: Result is collection of rate methods
- D: DataObject is too generic`,
            codeExample: `class CustomCarrier extends AbstractCarrier implements CarrierInterface
{
    protected $_code = 'customcarrier';

    public function collectRates(RateRequest $request)
    {
        if (!$this->getConfigFlag('active')) {
            return false;
        }

        $result = $this->_rateResultFactory->create();
        $method = $this->_rateMethodFactory->create();

        $method->setCarrier($this->_code);
        $method->setCarrierTitle($this->getConfigData('title'));
        $method->setMethod('standard');
        $method->setMethodTitle('Standard Delivery');
        $method->setPrice($this->getConfigData('price'));
        $method->setCost($this->getConfigData('price'));

        $result->append($method);
        return $result;
    }

    public function getAllowedMethods()
    {
        return ['standard' => 'Standard Delivery'];
    }
}`
          },
          {
            id: 34,
            category: "API & Web Services",
            difficulty: "Hard",
            question: "When creating a custom REST API endpoint that requires customer authentication, which resource should be specified in webapi.xml?",
            options: [
              { id: "A", text: "anonymous" },
              { id: "B", text: "self" },
              { id: "C", text: "Magento_Customer::customer" },
              { id: "D", text: "Magento_Backend::admin" }
            ],
            correctAnswers: ["B"],
            explanation: `The 'self' resource allows authenticated customers to access their own data.

Why B is correct:
- 'self' is a special resource for customer-specific endpoints
- Ensures customer can only access their own data
- Requires valid customer token
- Maps %customer_id% placeholder to authenticated customer

Why others are incorrect:
- A: anonymous allows unauthenticated access
- C: This is admin ACL resource for managing customers
- D: This is for admin authentication, not customers`,
            codeExample: `<!-- webapi.xml -->
<routes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Webapi:etc/webapi.xsd">

    <!-- Customer-authenticated endpoint using 'self' -->
    <route url="/V1/custom/customer/orders" method="GET">
        <service class="Vendor\\Module\\Api\\CustomerOrderInterface" method="getList"/>
        <resources>
            <resource ref="self"/>
        </resources>
        <data>
            <parameter name="customerId" force="true">%customer_id%</parameter>
        </data>
    </route>

    <!-- Public endpoint -->
    <route url="/V1/custom/public/info" method="GET">
        <service class="Vendor\\Module\\Api\\PublicInterface" method="getInfo"/>
        <resources>
            <resource ref="anonymous"/>
        </resources>
    </route>
</routes>`
          },
          {
            id: 35,
            category: "API & Web Services",
            difficulty: "Medium",
            question: "What annotation is required on a repository interface method for it to be exposed via REST API?",
            options: [
              { id: "A", text: "@api" },
              { id: "B", text: "@webapi" },
              { id: "C", text: "@param and @return with proper type definitions" },
              { id: "D", text: "@rest" }
            ],
            correctAnswers: ["C"],
            explanation: `REST API relies on @param and @return docblock annotations for type information.

Why C is correct:
- Magento uses reflection to read docblock annotations
- @param defines input types for automatic deserialization
- @return defines output type for serialization
- Types must be fully qualified or use data interfaces

Why others are incorrect:
- A: @api marks as public API but doesn't enable REST
- B: @webapi doesn't exist
- D: @rest doesn't exist`,
            codeExample: `/**
 * @api
 */
interface ProductCustomRepositoryInterface
{
    /**
     * Get product by SKU
     *
     * @param string $sku
     * @return \\Vendor\\Module\\Api\\Data\\ProductCustomInterface
     * @throws \\Magento\\Framework\\Exception\\NoSuchEntityException
     */
    public function getBySku($sku);

    /**
     * Save product custom data
     *
     * @param \\Vendor\\Module\\Api\\Data\\ProductCustomInterface $product
     * @return \\Vendor\\Module\\Api\\Data\\ProductCustomInterface
     * @throws \\Magento\\Framework\\Exception\\CouldNotSaveException
     */
    public function save(ProductCustomInterface $product);

    /**
     * Get list with search criteria
     *
     * @param \\Magento\\Framework\\Api\\SearchCriteriaInterface $searchCriteria
     * @return \\Vendor\\Module\\Api\\Data\\ProductCustomSearchResultInterface
     */
    public function getList(SearchCriteriaInterface $searchCriteria);
}`
          },
          {
            id: 36,
            category: "Cron & Scheduling",
            difficulty: "Medium",
            question: "What is the correct way to configure a cron job that runs every 5 minutes in Magento 2?",
            options: [
              { id: "A", text: "Add cron expression in di.xml" },
              { id: "B", text: "Create crontab.xml with group and job definition" },
              { id: "C", text: "Configure in system.xml under cron section" },
              { id: "D", text: "Define in config.xml under crontab node" }
            ],
            correctAnswers: ["B"],
            explanation: `Cron jobs are defined in crontab.xml with group and schedule configuration.

Why B is correct:
- crontab.xml is the dedicated file for cron configuration
- Groups allow organizing related jobs
- Schedule uses standard cron expression syntax
- Instance specifies the class with execute() method

Why others are incorrect:
- A: di.xml is for dependency injection
- C: system.xml is for admin config fields
- D: Magento 2 uses crontab.xml, not config.xml`,
            codeExample: `<!-- etc/crontab.xml -->
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Cron:etc/crontab.xsd">
    <group id="default">
        <job name="vendor_module_sync" instance="Vendor\\Module\\Cron\\SyncData" method="execute">
            <schedule>*/5 * * * *</schedule>  <!-- Every 5 minutes -->
        </job>
    </group>

    <!-- Custom group for heavy jobs -->
    <group id="vendor_heavy_jobs">
        <job name="vendor_module_import" instance="Vendor\\Module\\Cron\\ImportData" method="execute">
            <schedule>0 2 * * *</schedule>  <!-- Daily at 2 AM -->
        </job>
    </group>
</config>

// Cron/SyncData.php
class SyncData
{
    public function execute()
    {
        // Cron job logic
        $this->logger->info('Running sync cron job');
        $this->syncService->synchronize();
    }
}`
          },
          {
            id: 37,
            category: "Import & Export",
            difficulty: "Hard",
            question: "When implementing a custom import entity type, which interface must the import model implement?",
            options: [
              { id: "A", text: "Magento\\ImportExport\\Model\\Import\\EntityInterface" },
              { id: "B", text: "Magento\\ImportExport\\Model\\Import\\Entity\\AbstractEntity" },
              { id: "C", text: "Magento\\ImportExport\\Model\\ImportInterface" },
              { id: "D", text: "Magento\\Framework\\DataObject\\IdentityInterface" }
            ],
            correctAnswers: ["B"],
            explanation: `Custom import entities extend AbstractEntity which provides the import framework.

Why B is correct:
- AbstractEntity provides base import functionality
- Handles validation, data processing, and behavior modes
- Must implement _importData() method
- Supports add/update/delete behaviors

Why others are incorrect:
- A: EntityInterface doesn't exist in this context
- C: ImportInterface is for the main import model
- D: IdentityInterface is for cache tags`,
            codeExample: `// Model/Import/CustomEntity.php
class CustomEntity extends \\Magento\\ImportExport\\Model\\Import\\Entity\\AbstractEntity
{
    const ENTITY_CODE = 'custom_entity';

    protected function _importData()
    {
        while ($bunch = $this->_dataSourceModel->getNextBunch()) {
            foreach ($bunch as $rowNum => $rowData) {
                if (!$this->validateRow($rowData, $rowNum)) {
                    continue;
                }

                if ($this->getErrorAggregator()->hasToBeTerminated()) {
                    $this->getErrorAggregator()->addRowToSkip($rowNum);
                    continue;
                }

                $this->saveEntity($rowData);
            }
        }
        return true;
    }

    public function getEntityTypeCode()
    {
        return self::ENTITY_CODE;
    }

    public function validateRow(array $rowData, $rowNum)
    {
        // Validation logic
        return true;
    }
}`
          },
          {
            id: 38,
            category: "Database",
            difficulty: "Hard",
            question: "In Magento 2.3+, what is the recommended way to add a new column to an existing table?",
            options: [
              { id: "A", text: "Create an InstallSchema script" },
              { id: "B", text: "Create an UpgradeSchema script with version check" },
              { id: "C", text: "Modify db_schema.xml and generate whitelist" },
              { id: "D", text: "Run ALTER TABLE SQL directly" }
            ],
            correctAnswers: ["C"],
            explanation: `Declarative Schema (db_schema.xml) is the modern approach for database changes.

Why C is correct:
- db_schema.xml declares desired table structure
- Whitelist (db_schema_whitelist.json) tracks allowed changes
- System automatically generates migration SQL
- Supports rollback and version management

Why others are incorrect:
- A/B: Install/UpgradeSchema are legacy approaches
- D: Direct SQL bypasses Magento's schema management`,
            codeExample: `<!-- db_schema.xml - Add column to existing table -->
<schema xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="urn:magento:framework:Setup/Declaration/Schema/etc/schema.xsd">

    <table name="sales_order" resource="sales">
        <!-- New column -->
        <column xsi:type="varchar" name="custom_field" nullable="true" length="255"
                comment="Custom Order Field"/>
    </table>
</schema>

<!-- Generate whitelist after adding column -->
# bin/magento setup:db-declaration:generate-whitelist --module-name=Vendor_Module

<!-- db_schema_whitelist.json (auto-generated) -->
{
    "sales_order": {
        "column": {
            "custom_field": true
        }
    }
}`
          },
          {
            id: 39,
            category: "Database",
            difficulty: "Medium",
            question: "What is the purpose of Data Patches in Magento 2?",
            options: [
              { id: "A", text: "To modify database schema structure" },
              { id: "B", text: "To add or modify data in the database (seed data, configuration)" },
              { id: "C", text: "To fix bugs in PHP code" },
              { id: "D", text: "To apply security patches" }
            ],
            correctAnswers: ["B"],
            explanation: `Data Patches insert or modify data, separate from schema changes.

Why B is correct:
- Data Patches populate initial data
- Used for default configuration, attributes, CMS content
- Run once and tracked in patch_list table
- Implement DataPatchInterface

Why others are incorrect:
- A: Schema changes use db_schema.xml or SchemaPatchInterface
- C: Code bugs fixed in PHP files, not patches
- D: Security patches are separate Composer packages`,
            codeExample: `// Setup/Patch/Data/AddCustomAttribute.php
class AddCustomAttribute implements DataPatchInterface, PatchRevertableInterface
{
    public function apply()
    {
        $this->moduleDataSetup->startSetup();

        $this->eavSetup->addAttribute(
            Product::ENTITY,
            'custom_attribute',
            [
                'type' => 'varchar',
                'label' => 'Custom Attribute',
                'input' => 'text',
                'required' => false,
                'visible' => true,
                'user_defined' => true,
                'global' => ScopedAttributeInterface::SCOPE_STORE,
            ]
        );

        $this->moduleDataSetup->endSetup();
    }

    public function revert()
    {
        $this->eavSetup->removeAttribute(Product::ENTITY, 'custom_attribute');
    }

    public static function getDependencies()
    {
        return [];
    }

    public function getAliases()
    {
        return [];
    }
}`
          },
          {
            id: 40,
            category: "Elasticsearch",
            difficulty: "Hard",
            question: "An Architect needs to add a custom product attribute to Elasticsearch index for searching. Which approach is correct?",
            options: [
              { id: "A", text: "Modify the Elasticsearch index mapping directly" },
              { id: "B", text: "Create attribute with 'searchable' = true and reindex" },
              { id: "C", text: "Create a plugin on Elasticsearch DataMapper" },
              { id: "D", text: "Configure in elasticsearch.xml" }
            ],
            correctAnswers: ["B"],
            explanation: `Product attributes with searchable=true are automatically indexed in Elasticsearch.

Why B is correct:
- Attribute configuration controls indexing behavior
- 'searchable' flag adds to search index
- 'visible_in_advanced_search' for advanced search form
- Reindexing updates Elasticsearch mappings

Why others are incorrect:
- A: Mappings are generated from attribute config
- C: Plugins are for custom transformation, not basic indexing
- D: elasticsearch.xml doesn't exist in this form`,
            codeExample: `// Adding searchable attribute via Data Patch
$this->eavSetup->addAttribute(
    Product::ENTITY,
    'searchable_custom',
    [
        'type' => 'varchar',
        'label' => 'Searchable Custom',
        'input' => 'text',
        'required' => false,
        'searchable' => true,                    // Adds to search index
        'visible_in_advanced_search' => true,    // Shows in advanced search
        'filterable' => false,
        'filterable_in_search' => false,
        'used_for_sort_by' => false,
        'global' => ScopedAttributeInterface::SCOPE_STORE,
    ]
);

// After adding, reindex:
// bin/magento indexer:reindex catalogsearch_fulltext

// For custom transformation, use DataProvider plugin:
class SearchDataProvider
{
    public function afterGetSearchData($subject, $result, $productId, $storeId)
    {
        // Add custom data to search document
        $result['custom_computed_field'] = $this->computeValue($productId);
        return $result;
    }
}`
          },
          {
            id: 41,
            category: "Admin Customization",
            difficulty: "Medium",
            question: "What is the correct way to add a new menu item to the Magento Admin panel?",
            options: [
              { id: "A", text: "Create adminhtml/menu.xml with parent reference" },
              { id: "B", text: "Add item in system.xml under menu section" },
              { id: "C", text: "Create etc/menu.xml with item definition" },
              { id: "D", text: "Modify core admin menu configuration" }
            ],
            correctAnswers: ["C"],
            explanation: `Admin menu items are defined in etc/menu.xml.

Why C is correct:
- etc/menu.xml is the configuration file for admin menu
- Items reference parent for positioning
- ACL resource controls access
- Action attribute links to controller

Why others are incorrect:
- A: Not in adminhtml/ folder - it's etc/menu.xml
- B: system.xml is for configuration fields
- D: Never modify core files`,
            codeExample: `<!-- etc/menu.xml -->
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Backend:etc/menu.xsd">
    <menu>
        <!-- Top-level menu -->
        <add id="Vendor_Module::main_menu"
             title="Custom Module"
             module="Vendor_Module"
             sortOrder="100"
             resource="Vendor_Module::main"/>

        <!-- Submenu item -->
        <add id="Vendor_Module::manage"
             title="Manage Items"
             module="Vendor_Module"
             sortOrder="10"
             parent="Vendor_Module::main_menu"
             action="custommodule/item/index"
             resource="Vendor_Module::manage"/>

        <!-- Under existing menu (e.g., Catalog) -->
        <add id="Vendor_Module::catalog_custom"
             title="Custom Catalog Feature"
             module="Vendor_Module"
             sortOrder="100"
             parent="Magento_Catalog::catalog"
             action="custommodule/catalog/custom"
             resource="Vendor_Module::catalog_custom"/>
    </menu>
</config>`
          },
          {
            id: 42,
            category: "Admin Customization",
            difficulty: "Hard",
            question: "When creating an admin grid using UI Components, which XML file defines the grid configuration?",
            options: [
              { id: "A", text: "layout/[handle]_index_index.xml" },
              { id: "B", text: "ui_component/[listing_name].xml" },
              { id: "C", text: "etc/adminhtml/grid.xml" },
              { id: "D", text: "view/adminhtml/templates/grid.phtml" }
            ],
            correctAnswers: ["B"],
            explanation: `UI Component grids are defined in view/adminhtml/ui_component/[name].xml.

Why B is correct:
- UI Components are in view/[area]/ui_component/
- Grid listing name matches layout reference
- Defines columns, filters, mass actions, data source
- Uses declarative XML structure

Why others are incorrect:
- A: Layout references UI Component, doesn't define it
- C: grid.xml doesn't exist in this pattern
- D: Templates are for rendering, not configuration`,
            codeExample: `<!-- view/adminhtml/ui_component/vendor_items_listing.xml -->
<listing xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Ui:etc/ui_configuration.xsd">
    <argument name="data" xsi:type="array">
        <item name="js_config" xsi:type="array">
            <item name="provider" xsi:type="string">vendor_items_listing.vendor_items_listing_data_source</item>
        </item>
    </argument>

    <dataSource name="vendor_items_listing_data_source" component="Magento_Ui/js/grid/provider">
        <argument name="dataProvider" xsi:type="configurableObject">
            <argument name="class" xsi:type="string">Magento\\Framework\\View\\Element\\UiComponent\\DataProvider\\DataProvider</argument>
            <argument name="name" xsi:type="string">vendor_items_listing_data_source</argument>
            <argument name="primaryFieldName" xsi:type="string">entity_id</argument>
            <argument name="requestFieldName" xsi:type="string">id</argument>
        </argument>
    </dataSource>

    <listingToolbar name="listing_top">
        <massaction name="listing_massaction">
            <action name="delete">
                <argument name="data" xsi:type="array">
                    <item name="config" xsi:type="array">
                        <item name="type" xsi:type="string">delete</item>
                        <item name="label" xsi:type="string" translate="true">Delete</item>
                        <item name="url" xsi:type="url" path="*/*/massDelete"/>
                    </item>
                </argument>
            </action>
        </massaction>
    </listingToolbar>

    <columns name="vendor_items_columns">
        <selectionsColumn name="ids">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="indexField" xsi:type="string">entity_id</item>
                </item>
            </argument>
        </selectionsColumn>
        <column name="entity_id">
            <argument name="data" xsi:type="array">
                <item name="config" xsi:type="array">
                    <item name="filter" xsi:type="string">textRange</item>
                    <item name="label" xsi:type="string" translate="true">ID</item>
                </item>
            </argument>
        </column>
    </columns>
</listing>`
          },
          {
            id: 43,
            category: "Extension Attributes",
            difficulty: "Hard",
            question: "Which file is used to declare extension attributes for a data interface in Magento 2?",
            options: [
              { id: "A", text: "di.xml" },
              { id: "B", text: "extension_attributes.xml" },
              { id: "C", text: "webapi.xml" },
              { id: "D", text: "data_interface.xml" }
            ],
            correctAnswers: ["B"],
            explanation: `Extension attributes are declared in etc/extension_attributes.xml.

Why B is correct:
- extension_attributes.xml defines additional attributes for data interfaces
- Generates ExtensionInterface automatically
- Allows extending core interfaces without modification
- Preserved during API serialization

Why others are incorrect:
- A: di.xml is for dependency injection
- C: webapi.xml is for API routes
- D: data_interface.xml doesn't exist`,
            codeExample: `<!-- etc/extension_attributes.xml -->
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="urn:magento:framework:Api/etc/extension_attributes.xsd">

    <!-- Add custom attribute to Product -->
    <extension_attributes for="Magento\\Catalog\\Api\\Data\\ProductInterface">
        <attribute code="custom_warranty" type="string"/>
        <attribute code="custom_options" type="Vendor\\Module\\Api\\Data\\CustomOptionInterface[]"/>
    </extension_attributes>

    <!-- Add attribute to Order -->
    <extension_attributes for="Magento\\Sales\\Api\\Data\\OrderInterface">
        <attribute code="delivery_instructions" type="string"/>
    </extension_attributes>
</config>

// Usage in code:
$product->getExtensionAttributes()->setCustomWarranty('2 years');
$warranty = $product->getExtensionAttributes()->getCustomWarranty();

// To persist, add plugin on repository save method:
public function afterSave(ProductRepositoryInterface $subject, ProductInterface $product)
{
    $extensionAttributes = $product->getExtensionAttributes();
    if ($extensionAttributes && $extensionAttributes->getCustomWarranty()) {
        $this->saveWarranty($product->getId(), $extensionAttributes->getCustomWarranty());
    }
    return $product;
}`
          },
          {
            id: 44,
            category: "B2B Features",
            difficulty: "Hard",
            question: "In Adobe Commerce B2B, how should an Architect implement custom approval rules for company purchase orders?",
            options: [
              { id: "A", text: "Override the PurchaseOrder model" },
              { id: "B", text: "Create a plugin on the approval workflow" },
              { id: "C", text: "Implement ApprovalRuleInterface and configure via admin" },
              { id: "D", text: "Modify the company permissions directly" }
            ],
            correctAnswers: ["C"],
            explanation: `B2B purchase order approvals use ApprovalRuleInterface for custom rules.

Why C is correct:
- ApprovalRuleInterface defines custom approval conditions
- Rules are configurable by company admins
- Supports amount thresholds, roles, and custom conditions
- Integrates with B2B approval workflow

Why others are incorrect:
- A: Model override is invasive and not extensible
- B: Plugins work but interfaces are cleaner for rules
- D: Permissions are separate from approval rules`,
            codeExample: `// Implementing custom approval rule
class CustomApprovalRule implements ApprovalRuleInterface
{
    public function validate(PurchaseOrderInterface $purchaseOrder): bool
    {
        // Custom validation logic
        $total = $purchaseOrder->getGrandTotal();
        $companyId = $purchaseOrder->getCompanyId();

        // Check if order exceeds custom threshold
        $threshold = $this->getCompanyThreshold($companyId);

        return $total <= $threshold;
    }

    public function getConditionType(): string
    {
        return 'custom_amount_rule';
    }

    public function getLabel(): string
    {
        return __('Custom Amount Threshold');
    }
}

// Register in di.xml
<type name="Magento\\PurchaseOrder\\Model\\ApprovalRulePool">
    <arguments>
        <argument name="rules" xsi:type="array">
            <item name="custom_rule" xsi:type="object">Vendor\\Module\\Model\\ApprovalRule\\CustomApprovalRule</item>
        </argument>
    </arguments>
</type>`
          },
          {
            id: 45,
            category: "MSI (Inventory)",
            difficulty: "Medium",
            question: "In Magento MSI (Multi-Source Inventory), what is the relationship between Sources and Stocks?",
            options: [
              { id: "A", text: "Sources contain Stocks" },
              { id: "B", text: "Stocks are assigned to Sources" },
              { id: "C", text: "Sources are linked to Stocks, and Stocks are linked to Sales Channels" },
              { id: "D", text: "Sources and Stocks are the same concept" }
            ],
            correctAnswers: ["C"],
            explanation: `MSI architecture: Sources  Stocks  Sales Channels (websites).

Why C is correct:
- Sources = physical inventory locations (warehouses)
- Stocks = aggregation of Sources
- Stocks are linked to Sales Channels (websites)
- Allows different inventory views per website

Why others are incorrect:
- A: Sources don't contain Stocks, they're linked
- B: Stocks aggregate Sources, not assigned to them
- D: They serve different purposes`,
            codeExample: `// MSI Architecture:
// Source (warehouse) -> Stock (aggregation) -> Sales Channel (website)

// Get salable quantity for a product on a stock
$salableQty = $this->getProductSalableQty->execute('SKU-123', $stockId);

// Check if product is in stock for specific stock
$isInStock = $this->isProductSalable->execute('SKU-123', $stockId);

// Programmatically create source assignment
$sourceItem = $this->sourceItemFactory->create();
$sourceItem->setSourceCode('warehouse_1');
$sourceItem->setSku('SKU-123');
$sourceItem->setQuantity(100);
$sourceItem->setStatus(SourceItemInterface::STATUS_IN_STOCK);
$this->sourceItemsSave->execute([$sourceItem]);

// Get stock ID by sales channel (website)
$stockId = $this->stockResolver->execute(
    SalesChannelInterface::TYPE_WEBSITE,
    'base'
)->getStockId();`
          },
          {
            id: 46,
            category: "Security",
            difficulty: "Hard",
            question: "Which security measure should be implemented when handling user-submitted content that will be displayed on the storefront?",
            options: [
              { id: "A", text: "Use htmlspecialchars() in PHP before output" },
              { id: "B", text: "Use $block->escapeHtml() in templates" },
              { id: "C", text: "Store sanitized HTML in database" },
              { id: "D", text: "Rely on browser XSS protection headers" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento templates should use block escape methods to prevent XSS.

Why B is correct:
- escapeHtml() properly encodes HTML entities
- Context-aware escaping (escapeUrl, escapeJs, etc.)
- Consistent with Magento security standards
- Applied at output time, not storage

Why others are incorrect:
- A: Works but block methods are Magento standard
- C: Sanitizing at storage can lose legitimate content
- D: Browser headers are defense-in-depth, not primary protection`,
            codeExample: `<!-- Template escaping examples -->

<!-- Basic HTML escaping -->
<p><?= $block->escapeHtml($userInput) ?></p>

<!-- Escaping with allowed tags -->
<div><?= $block->escapeHtml($userContent, ['b', 'i', 'a']) ?></div>

<!-- URL escaping -->
<a href="<?= $block->escapeUrl($userProvidedUrl) ?>">Link</a>

<!-- JavaScript escaping -->
<scr` + `ipt>
    var userData = <?= $block->escapeJs($jsonData) ?>;
</scr` + `ipt>

<!-- HTML attribute escaping -->
<input value="<?= $block->escapeHtmlAttr($value) ?>"/>

<!-- CSS escaping -->
<div style="background: <?= $block->escapeCss($color) ?>"></div>

// In PHP class (ViewModel)
public function getSafeContent(): string
{
    return $this->escaper->escapeHtml($this->getUserContent());
}`
          },
          {
            id: 47,
            category: "Logging & Debugging",
            difficulty: "Medium",
            question: "What is the recommended way to add custom logging in a Magento 2 module?",
            options: [
              { id: "A", text: "Use PHP error_log() function" },
              { id: "B", text: "Write directly to var/log files" },
              { id: "C", text: "Inject Psr\\Log\\LoggerInterface and use its methods" },
              { id: "D", text: "Create custom file handling class" }
            ],
            correctAnswers: ["C"],
            explanation: `Magento uses PSR-3 LoggerInterface for standardized logging.

Why C is correct:
- PSR-3 LoggerInterface is the standard
- Injected via dependency injection
- Supports multiple log levels
- Configurable handlers and formatters

Why others are incorrect:
- A: error_log bypasses Magento logging infrastructure
- B: Direct file writing is not maintainable
- D: Custom handlers extend, not replace the system`,
            codeExample: `// Using PSR-3 Logger
use Psr\\Log\\LoggerInterface;

class MyService
{
    public function __construct(
        private LoggerInterface $logger
    ) {}

    public function process(): void
    {
        $this->logger->info('Processing started', ['context' => 'value']);

        try {
            // Business logic
            $this->logger->debug('Debug info', $debugData);
        } catch (\\Exception $e) {
            $this->logger->error('Processing failed', [
                'exception' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
        }

        $this->logger->warning('Deprecated method used');
    }
}

// Custom logger channel (di.xml virtual type)
<virtualType name="Vendor\\Module\\Logger" type="Magento\\Framework\\Logger\\Monolog">
    <arguments>
        <argument name="name" xsi:type="string">vendor_module</argument>
        <argument name="handlers" xsi:type="array">
            <item name="system" xsi:type="object">Vendor\\Module\\Logger\\Handler</item>
        </argument>
    </arguments>
</virtualType>`
          },
          {
            id: 48,
            category: "Theme Development",
            difficulty: "Medium",
            question: "In Magento 2 theme hierarchy, which location takes highest priority for template overrides?",
            options: [
              { id: "A", text: "Module view/frontend/templates" },
              { id: "B", text: "Theme Vendor_Module/templates (app/design/frontend/Vendor/theme/Vendor_Module)" },
              { id: "C", text: "Parent theme templates" },
              { id: "D", text: "Child theme templates" }
            ],
            correctAnswers: ["D"],
            explanation: `Theme fallback hierarchy: Child Theme  Parent Theme  Module.

Why D is correct:
- Child theme has highest priority
- Then parent theme(s) in inheritance chain
- Finally, module's own templates
- Allows progressive customization

Why others are incorrect:
- A: Module templates have lowest priority
- B: Theme overrides beat module but not child theme
- C: Parent theme is checked before module, after child`,
            codeExample: `// Template fallback order (highest to lowest):
// 1. app/design/frontend/Vendor/child-theme/Vendor_Module/templates/
// 2. app/design/frontend/Vendor/parent-theme/Vendor_Module/templates/
// 3. app/code/Vendor/Module/view/frontend/templates/
// 4. vendor/magento/module-xxx/view/frontend/templates/

// Theme inheritance (theme.xml)
<!-- app/design/frontend/Vendor/child-theme/theme.xml -->
<theme xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:noNamespaceSchemaLocation="urn:magento:framework:Config/etc/theme.xsd">
    <title>Child Theme</title>
    <parent>Vendor/parent-theme</parent>
</theme>

// Override module template in theme:
// app/design/frontend/Vendor/theme/Magento_Catalog/templates/product/view.phtml

// Override layout in theme:
// app/design/frontend/Vendor/theme/Magento_Catalog/layout/catalog_product_view.xml`
          },
          {
            id: 49,
            category: "Catalog Rules",
            difficulty: "Medium",
            question: "How are Catalog Price Rules applied to product prices in Magento 2?",
            options: [
              { id: "A", text: "Calculated in real-time during page load" },
              { id: "B", text: "Pre-calculated and stored in catalogrule_product_price table via indexer" },
              { id: "C", text: "Applied only at checkout" },
              { id: "D", text: "Stored directly in the product's price attribute" }
            ],
            correctAnswers: ["B"],
            explanation: `Catalog rules are pre-indexed for performance.

Why B is correct:
- catalogrule_product_price stores calculated rule prices
- Indexer runs when rules change or on schedule
- Product collection loads from pre-calculated table
- Much faster than real-time calculation

Why others are incorrect:
- A: Real-time would be too slow for product listings
- C: That's Cart Price Rules, not Catalog
- D: Original price is preserved; rule prices are separate`,
            codeExample: `// Catalog rule indexer reindex
// bin/magento indexer:reindex catalogrule_product

// Tables involved:
// - catalogrule: Rule definitions
// - catalogrule_product: Products matching rules
// - catalogrule_product_price: Final calculated prices

// Get rule price programmatically
$rulePrice = $this->ruleResource->getRulePrice(
    $dateTime,
    $websiteId,
    $customerGroupId,
    $productId
);

// Apply in price collection
$productCollection->addPriceData();
// This automatically joins catalogrule_product_price for rule prices

// Product final price considers:
// 1. Regular price
// 2. Special price
// 3. Catalog rule price
// 4. Tier prices
// Returns lowest applicable price`
          },
          {
            id: 50,
            category: "Module Development",
            difficulty: "Medium",
            question: "What determines the load order of modules in Magento 2?",
            options: [
              { id: "A", text: "Alphabetical order of module names" },
              { id: "B", text: "Order in app/etc/config.php" },
              { id: "C", text: "Sequence dependencies defined in module.xml" },
              { id: "D", text: "Composer package order" }
            ],
            correctAnswers: ["C"],
            explanation: `Module sequence in module.xml controls load order.

Why C is correct:
- <sequence> tag defines dependencies
- Module loads after all listed dependencies
- Ensures proper plugin/preference order
- Required for proper configuration merging

Why others are incorrect:
- A: Alphabetical is not the mechanism
- B: config.php lists enabled modules, not order
- D: Composer handles PHP autoloading, not module sequence`,
            codeExample: `<!-- etc/module.xml -->
<config xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="urn:magento:framework:Module/etc/module.xsd">
    <module name="Vendor_CustomCheckout">
        <sequence>
            <!-- This module loads AFTER these modules -->
            <module name="Magento_Checkout"/>
            <module name="Magento_Quote"/>
            <module name="Magento_Customer"/>
        </sequence>
    </module>
</config>

// Why sequence matters:
// 1. Configuration merging order
// 2. Plugin execution order
// 3. Observer registration order
// 4. Layout update merging

// Check current module order:
// bin/magento module:status

// Sequence affects:
// - etc/*.xml merge order
// - view/*/layout/*.xml merge order
// - which plugin executes first when multiple exist`
          },
          {
            id: 51,
            category: "Performance",
            difficulty: "Hard",
            question: "Which technique should be used to optimize database queries for a custom product listing that displays data from multiple EAV attributes?",
            options: [
              { id: "A", text: "Load each product individually with getById()" },
              { id: "B", text: "Use addAttributeToSelect() with specific attributes on collection" },
              { id: "C", text: "Enable flat catalog for all attributes" },
              { id: "D", text: "Cache the entire product collection in Redis" }
            ],
            correctAnswers: ["B"],
            explanation: `Selective attribute loading minimizes EAV joins and improves performance.

Why B is correct:
- addAttributeToSelect() only joins needed attribute tables
- Reduces query complexity significantly
- Can use addAttributeToSelect('*') carefully
- Supports addAttributeToFilter for conditions

Why others are incorrect:
- A: Individual loads cause N+1 query problem
- C: Flat catalog is deprecated and limited
- D: Caching entire collections has memory/invalidation issues`,
            codeExample: `// Optimized collection loading
$collection = $this->productCollectionFactory->create();
$collection
    ->addAttributeToSelect(['name', 'price', 'thumbnail', 'status'])  // Only needed
    ->addAttributeToFilter('status', Status::STATUS_ENABLED)
    ->addAttributeToFilter('visibility', ['neq' => Visibility::VISIBILITY_NOT_VISIBLE])
    ->setPageSize(20);

// DON'T do this - loads ALL attributes:
// $collection->addAttributeToSelect('*');

// For custom attributes, ensure they exist
if ($this->eavConfig->getAttribute('catalog_product', 'custom_attr')->getId()) {
    $collection->addAttributeToSelect('custom_attr');
}

// Use joins for non-EAV data
$collection->getSelect()->joinLeft(
    ['inventory' => $this->resource->getTableName('cataloginventory_stock_item')],
    'e.entity_id = inventory.product_id',
    ['qty']
);

// Benchmark:
// select('*') with 50 attributes: ~200ms
// select([5 attrs]): ~20ms`
          },
          {
            id: 52,
            category: "Dependency Injection",
            difficulty: "Medium",
            question: "An Adobe Commerce Architect needs to create new product instances in a service class. Which pattern should be used to create new entity objects that will be saved to the database?",
            options: [
              { id: "A", text: "Use the Repository pattern with get() method" },
              { id: "B", text: "Use the Factory pattern to create new instances" },
              { id: "C", text: "Use ObjectManager::create() directly" },
              { id: "D", text: "Use the Builder pattern with setData() method" }
            ],
            correctAnswers: ["B"],
            explanation: `The Factory pattern is specifically designed for creating NEW entity instances in Magento 2.

Why B is correct:
- Factories create new, empty instances of objects
- Factory classes are auto-generated by Magento
- They properly handle dependency injection for the created object
- Convention: ClassNameFactory->create() returns new instance

Why others are incorrect:
- A: Repository->get() retrieves EXISTING entities, not creates new ones
- C: Direct ObjectManager usage is an anti-pattern (except in factories/tests)
- D: Builder pattern is not a standard Magento pattern for entity creation`,
            codeExample: `// Correct: Using Factory for new entities
class ProductService
{
    public function __construct(
        private ProductInterfaceFactory $productFactory,
        private ProductRepositoryInterface $productRepository
    ) {}

    public function createProduct(array $data): ProductInterface
    {
        // Factory creates NEW instance
        $product = $this->productFactory->create();
        $product->setSku($data['sku']);
        $product->setName($data['name']);

        // Repository SAVES the entity
        return $this->productRepository->save($product);
    }
}

// Wrong: Using repository to "create"
// $product = $this->productRepository->get($sku); // This GETS existing!`
          },
          {
            id: 53,
            category: "Dependency Injection",
            difficulty: "Medium",
            question: "A developer needs to replace a constructor argument for a specific class in di.xml. The original class has a $logger parameter that should use a custom logger. What is the correct di.xml configuration?",
            options: [
              { id: "A", text: "Use <preference> to replace the logger class globally" },
              { id: "B", text: "Use <type> with <arguments> to override the specific parameter" },
              { id: "C", text: "Use <virtualType> to create a new class with different arguments" },
              { id: "D", text: "Use <plugin> to intercept the constructor and change the logger" }
            ],
            correctAnswers: ["B"],
            explanation: `The <type> element with <arguments> allows you to override specific constructor arguments for a class.

Why B is correct:
- <type name="Class"> targets a specific class
- <arguments> allows overriding individual constructor parameters
- This is the standard way to customize DI for existing classes
- Maintains the original class while changing its dependencies

Why others are incorrect:
- A: Preference replaces class globally, affects all usages - overkill for argument change
- C: VirtualType creates alias with different args, but question asks about existing class
- D: Plugins cannot intercept constructors in Magento 2`,
            codeExample: `<!-- di.xml - Correct approach -->
<type name="Vendor\\Module\\Service\\MyService">
    <arguments>
        <argument name="logger" xsi:type="object">Vendor\\Module\\Logger\\CustomLogger</argument>
    </arguments>
</type>

<!-- Original class -->
class MyService
{
    public function __construct(
        private LoggerInterface $logger  // This will receive CustomLogger
    ) {}
}

<!-- Wrong: Using preference (global replacement) -->
<preference for="Psr\\Log\\LoggerInterface" type="CustomLogger"/>
<!-- This affects ALL classes using LoggerInterface! -->`
          },
          {
            id: 54,
            category: "Dependency Injection",
            difficulty: "Hard",
            question: "When a plugin (interceptor) is defined for a class, how does Magento handle the interceptor class generation and inheritance?",
            options: [
              { id: "A", text: "The generated interceptor extends the original class and calls parent methods" },
              { id: "B", text: "The generated interceptor implements the same interface without extending" },
              { id: "C", text: "The original class is modified at runtime to include plugin logic" },
              { id: "D", text: "A proxy class wraps the original class without inheritance" }
            ],
            correctAnswers: ["A"],
            explanation: `Magento's interceptor (plugin) mechanism generates a class that extends the original class.

Why A is correct:
- Interceptor classes are generated in var/generation (or generated/) directory
- Generated class naming: Original\\Class\\Interceptor
- The interceptor EXTENDS the original class
- Plugin methods (before/after/around) are called via ___callPlugins()
- Parent methods are called to execute original logic

Why others are incorrect:
- B: Interceptors DO extend the original class, not just implement interface
- C: Original class files are never modified
- D: Interceptors use inheritance, not composition/wrapping`,
            codeExample: `// Generated Interceptor (simplified)
// File: generated/code/Vendor/Module/Model/Product/Interceptor.php

namespace Vendor\\Module\\Model\\Product;

class Interceptor extends \\Vendor\\Module\\Model\\Product
    implements \\Magento\\Framework\\Interception\\InterceptorInterface
{
    use \\Magento\\Framework\\Interception\\Interceptor;

    public function getName()
    {
        // Calls before plugins, then parent::getName(), then after plugins
        $pluginInfo = $this->pluginList->getNext('getName');
        return $pluginInfo ? $this->___callPlugins('getName', [], $pluginInfo)
                          : parent::getName();
    }
}`
          },
          {
            id: 55,
            category: "Dependency Injection",
            difficulty: "Medium",
            question: "In which scenarios is direct usage of ObjectManager acceptable in Magento 2 code?",
            options: [
              { id: "A", text: "In controllers when constructor injection is not available" },
              { id: "B", text: "In static methods and factory classes generated by Magento" },
              { id: "C", text: "In any class when you need to conditionally create objects" },
              { id: "D", text: "In helper classes for backward compatibility" }
            ],
            correctAnswers: ["B"],
            explanation: `Direct ObjectManager usage is only acceptable in specific framework-level scenarios.

Why B is correct:
- Factory classes (auto-generated) use ObjectManager internally
- Static methods have no constructor, may need ObjectManager
- Framework bootstrap code before DI is initialized
- Integration tests that need to retrieve objects
- Fixtures and scripts outside normal request flow

Why others are incorrect:
- A: Controllers have constructor injection available, no excuse
- C: Use factories or conditional logic with injected dependencies
- D: Helpers should use constructor injection like any other class`,
            codeExample: `// ACCEPTABLE: Generated Factory (internal use)
class ProductFactory
{
    public function __construct(
        \\Magento\\Framework\\ObjectManagerInterface $objectManager
    ) {
        $this->_objectManager = $objectManager;
    }

    public function create(array $data = [])
    {
        return $this->_objectManager->create(Product::class, $data);
    }
}

// NOT ACCEPTABLE: Direct usage in service class
class BadService
{
    public function doSomething()
    {
        // WRONG - anti-pattern!
        $product = \\Magento\\Framework\\App\\ObjectManager::getInstance()
            ->create(ProductInterface::class);
    }
}`
          },
          {
            id: 56,
            category: "Dependency Injection",
            difficulty: "Medium",
            question: "What is the difference between shared='true' and shared='false' for a type definition in di.xml?",
            options: [
              { id: "A", text: "shared='true' creates a new instance each time, shared='false' reuses one instance" },
              { id: "B", text: "shared='true' reuses one instance (singleton), shared='false' creates new instance each time" },
              { id: "C", text: "shared='true' allows the object to be shared across modules" },
              { id: "D", text: "shared='false' prevents the class from being overridden by preferences" }
            ],
            correctAnswers: ["B"],
            explanation: `The 'shared' attribute controls whether the object manager returns the same instance or creates a new one.

Why B is correct:
- shared="true" (DEFAULT): Object is singleton - same instance returned every time
- shared="false": New instance created on each request (factory-like behavior)
- Default is shared="true" for most classes
- This affects performance and state management

Why others are incorrect:
- A: Reversed - shared=true is singleton, shared=false creates new
- C: "shared" refers to instance sharing, not module access
- D: "shared" doesn't affect preference behavior`,
            codeExample: `<!-- di.xml -->

<!-- Singleton (default behavior) - same instance reused -->
<type name="Vendor\\Module\\Service\\CacheService" shared="true"/>

<!-- Non-shared - new instance each injection -->
<type name="Vendor\\Module\\Model\\Cart\\Item" shared="false"/>

<!-- Practical example -->
class OrderService
{
    // If CartItem is shared=false, each injection gets fresh instance
    public function __construct(
        private CartItem $cartItem1,  // Instance A
        private CartItem $cartItem2   // Instance B (different!)
    ) {}
}

// With shared=true (default):
// $cartItem1 === $cartItem2 (same object)`
          },
          {
            id: 57,
            category: "Dependency Injection",
            difficulty: "Medium",
            question: "When should an architect use a virtualType instead of a regular type with argument overrides?",
            options: [
              { id: "A", text: "When you need to completely replace a class with a different implementation" },
              { id: "B", text: "When you need to create an alias with different constructor arguments without creating a PHP class" },
              { id: "C", text: "When you need to add plugins to a class" },
              { id: "D", text: "When you need to make a class available for unit testing" }
            ],
            correctAnswers: ["B"],
            explanation: `VirtualType creates a DI-level alias with different arguments, without requiring a new PHP class file.

Why B is correct:
- VirtualType is a "configuration-only" class alias
- Reuses existing PHP class with different injected dependencies
- No PHP file needed - purely di.xml configuration
- Useful for creating specialized versions of generic classes

Why others are incorrect:
- A: Use <preference> to replace class implementation
- C: Plugins are added via <plugin> element, not virtualType
- D: Testing doesn't require virtualType`,
            codeExample: `<!-- di.xml - VirtualType example -->

<!-- Create specialized logger without new PHP class -->
<virtualType name="Vendor\\Module\\Logger\\PaymentLogger"
             type="Magento\\Framework\\Logger\\Monolog">
    <arguments>
        <argument name="name" xsi:type="string">payment</argument>
        <argument name="handlers" xsi:type="array">
            <item name="debug" xsi:type="object">Vendor\\Module\\Logger\\Handler\\Payment</item>
        </argument>
    </arguments>
</virtualType>

<!-- Use the virtual type -->
<type name="Vendor\\Module\\Service\\PaymentService">
    <arguments>
        <argument name="logger" xsi:type="object">Vendor\\Module\\Logger\\PaymentLogger</argument>
    </arguments>
</type>

<!-- No PHP file needed for PaymentLogger! -->`
          },
          {
            id: 58,
            category: "Dependency Injection",
            difficulty: "Hard",
            question: "A service class has an expensive dependency that is only used in certain conditions. What pattern should the architect use to defer the instantiation of this dependency?",
            options: [
              { id: "A", text: "Use a Factory to create the dependency when needed" },
              { id: "B", text: "Use a Proxy class to lazy-load the dependency" },
              { id: "C", text: "Use shared='false' to prevent early instantiation" },
              { id: "D", text: "Use ObjectManager::get() to retrieve the dependency on demand" }
            ],
            correctAnswers: ["B"],
            explanation: `Proxy classes in Magento 2 provide lazy loading - the real object is only instantiated when first used.

Why B is correct:
- Proxy delays object creation until first method call
- Generated automatically by Magento (ClassName\\Proxy)
- Implements same interface as original class
- Ideal for expensive dependencies used conditionally
- Constructor runs instantly, but wrapped object is lazy

Why others are incorrect:
- A: Factory creates new instances, doesn't lazy-load existing singleton dependencies
- C: shared=false affects instance sharing, not lazy loading
- D: ObjectManager is anti-pattern`,
            codeExample: `<!-- di.xml - Using Proxy for lazy loading -->
<type name="Vendor\\Module\\Service\\OrderService">
    <arguments>
        <!-- Heavy dependency only loaded when actually used -->
        <argument name="reportGenerator" xsi:type="object">
            Vendor\\Module\\Service\\HeavyReportGenerator\\Proxy
        </argument>
    </arguments>
</type>

// PHP Service Class
class OrderService
{
    public function __construct(
        private HeavyReportGenerator $reportGenerator // Actually a Proxy!
    ) {
        // HeavyReportGenerator NOT instantiated yet
    }

    public function generateReport(): void
    {
        // NOW HeavyReportGenerator is instantiated (first use)
        $this->reportGenerator->generate();
    }
}`
          },
          {
            id: 59,
            category: "Dependency Injection",
            difficulty: "Medium",
            question: "An architect needs to modify the behavior of a core Magento class. When should they use a Plugin versus a Preference?",
            options: [
              { id: "A", text: "Plugin for extending behavior, Preference for completely replacing the class" },
              { id: "B", text: "Plugin for performance-critical code, Preference for non-critical code" },
              { id: "C", text: "Plugin only works on interfaces, Preference works on concrete classes" },
              { id: "D", text: "Plugin is deprecated, Preference is the recommended approach" }
            ],
            correctAnswers: ["A"],
            explanation: `Plugins and Preferences serve different purposes in Magento's DI system.

Why A is correct:
- PLUGIN: Extends/modifies behavior (before, after, around methods)
  - Multiple plugins can exist for same method
  - Original class remains, behavior is augmented
  - Recommended for most customizations

- PREFERENCE: Completely replaces one class with another
  - Only one preference per interface/class
  - Your class must extend/implement original
  - Use when you need to change class structure

Why others are incorrect:
- B: Performance is not the deciding factor
- C: Both can work on interfaces and concrete classes
- D: Plugins are the current recommended approach, not deprecated`,
            codeExample: `<!-- Plugin: EXTEND behavior (recommended) -->
<type name="Magento\\Catalog\\Model\\Product">
    <plugin name="my_product_plugin"
            type="Vendor\\Module\\Plugin\\ProductPlugin"/>
</type>

class ProductPlugin
{
    public function afterGetName(Product $subject, $result)
    {
        return $result . ' - On Sale!';  // Extends, doesn't replace
    }
}

<!-- Preference: REPLACE class (use sparingly) -->
<preference for="Magento\\Catalog\\Api\\ProductRepositoryInterface"
            type="Vendor\\Module\\Model\\ProductRepository"/>

// Must implement/extend original
class ProductRepository implements ProductRepositoryInterface
{
    // Complete replacement of all methods
}`
          },
          {
            id: 60,
            category: "Dependency Injection",
            difficulty: "Hard",
            question: "A module needs to register multiple implementations of the same interface that should all be executed. Which pattern does Magento use for this scenario?",
            options: [
              { id: "A", text: "Chain of Responsibility pattern with plugins" },
              { id: "B", text: "Composite pattern using an array argument in di.xml" },
              { id: "C", text: "Observer pattern with multiple event listeners" },
              { id: "D", text: "Strategy pattern with runtime switching" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento uses the Composite pattern to handle multiple implementations of an interface.

Why B is correct:
- Composite class receives array of implementations via di.xml
- Each implementation is iterated and executed
- Examples: ValidatorPool, CommandPool, Collectors
- Common in payment methods, validators, data collectors

Why others are incorrect:
- A: Chain of Responsibility is different (sequential with early exit)
- C: Observers are for events, not interface implementations
- D: Strategy is for selecting ONE implementation, not running multiple`,
            codeExample: `<!-- di.xml - Composite Pattern -->
<type name="Vendor\\Module\\Model\\ValidatorComposite">
    <arguments>
        <argument name="validators" xsi:type="array">
            <item name="stock" xsi:type="object">Vendor\\Module\\Model\\Validator\\Stock</item>
            <item name="price" xsi:type="object">Vendor\\Module\\Model\\Validator\\Price</item>
            <item name="status" xsi:type="object">Vendor\\Module\\Model\\Validator\\Status</item>
        </argument>
    </arguments>
</type>

// Composite class runs all validators
class ValidatorComposite implements ValidatorInterface
{
    public function __construct(
        private array $validators  // All implementations injected
    ) {}

    public function validate($entity): bool
    {
        foreach ($this->validators as $validator) {
            if (!$validator->validate($entity)) {
                return false;
            }
        }
        return true;
    }
}`
          },
          {
            id: 61,
            category: "Service Contracts",
            difficulty: "Medium",
            question: "When designing a data interface for a service contract, which methods should it contain according to Magento best practices?",
            options: [
              { id: "A", text: "Only getter methods for immutable data transfer" },
              { id: "B", text: "Getters and setters for each data property" },
              { id: "C", text: "Business logic methods along with data access" },
              { id: "D", text: "Static factory methods for object creation" }
            ],
            correctAnswers: ["B"],
            explanation: `Data interfaces in Magento 2 service contracts should contain getters and setters for data transfer.

Why B is correct:
- Data interfaces represent data structures (DTOs)
- Must have getter and setter for each property
- Allows hydration from various sources (API, database)
- Should extend ExtensibleDataInterface for extension attributes
- Annotated with @api for stability guarantee

Why others are incorrect:
- A: Setters are required for populating data from API/forms
- C: Business logic belongs in service interfaces, not data interfaces
- D: Factory methods should be in separate Factory classes`,
            codeExample: `// Correct Data Interface Design
namespace Vendor\\Module\\Api\\Data;

/**
 * @api
 */
interface ProductDataInterface extends ExtensibleDataInterface
{
    const SKU = 'sku';
    const NAME = 'name';
    const PRICE = 'price';

    /** @return string */
    public function getSku();
    /** @param string $sku @return $this */
    public function setSku($sku);

    /** @return string */
    public function getName();
    /** @param string $name @return $this */
    public function setName($name);

    /** @return float */
    public function getPrice();
    /** @param float $price @return $this */
    public function setPrice($price);

    // Extension attributes support
    public function getExtensionAttributes();
    public function setExtensionAttributes(ProductDataExtensionInterface $ext);
}`
          },
          {
            id: 62,
            category: "Service Contracts",
            difficulty: "Hard",
            question: "When using SearchCriteria with multiple FilterGroups, how are the conditions combined?",
            options: [
              { id: "A", text: "All filters in all groups are combined with AND" },
              { id: "B", text: "All filters in all groups are combined with OR" },
              { id: "C", text: "Filters within a group are AND, between groups are OR" },
              { id: "D", text: "Filters within a group are OR, between groups are AND" }
            ],
            correctAnswers: ["D"],
            explanation: `SearchCriteria uses a specific logic: OR within FilterGroup, AND between FilterGroups.

Why D is correct:
- FilterGroup = collection of Filter objects combined with OR
- Multiple FilterGroups are combined with AND
- This allows complex queries like: (status=1 OR status=2) AND (type='simple' OR type='virtual')
- Each FilterGroup represents a set of alternative conditions

Why others are incorrect:
- A: Not all AND - would be too restrictive
- B: Not all OR - would be too permissive
- C: Reversed - within group is OR, between groups is AND`,
            codeExample: `// Building SearchCriteria: (status=1 OR status=2) AND (qty > 0)

$searchCriteriaBuilder = $this->searchCriteriaBuilderFactory->create();

// FilterGroup 1: status conditions (OR within group)
$filter1 = $this->filterBuilder->setField('status')
    ->setValue(1)->setConditionType('eq')->create();
$filter2 = $this->filterBuilder->setField('status')
    ->setValue(2)->setConditionType('eq')->create();
$filterGroup1 = $this->filterGroupBuilder
    ->setFilters([$filter1, $filter2])->create();

// FilterGroup 2: qty condition
$filter3 = $this->filterBuilder->setField('qty')
    ->setValue(0)->setConditionType('gt')->create();
$filterGroup2 = $this->filterGroupBuilder
    ->setFilters([$filter3])->create();

// Combine: Group1 AND Group2
$searchCriteria = $searchCriteriaBuilder
    ->setFilterGroups([$filterGroup1, $filterGroup2])
    ->create();

// Result: (status=1 OR status=2) AND qty>0`
          },
          {
            id: 63,
            category: "Service Contracts",
            difficulty: "Medium",
            question: "What is the difference between extension attributes and custom attributes in Magento 2?",
            options: [
              { id: "A", text: "Extension attributes are for EAV entities, custom attributes for flat tables" },
              { id: "B", text: "Extension attributes are defined in code, custom attributes are created in admin" },
              { id: "C", text: "Extension attributes require module installation, custom attributes don't" },
              { id: "D", text: "Extension attributes are deprecated, custom attributes are recommended" }
            ],
            correctAnswers: ["B"],
            explanation: `Extension attributes and custom attributes serve different purposes in Magento 2.

Why B is correct:
- Extension Attributes: Defined in extension_attributes.xml, added via code
  - Allow modules to add data to existing API interfaces
  - Type-safe, strongly typed
  - Require code deployment

- Custom Attributes: Created via admin panel or programmatically
  - EAV attributes for entities like products, customers, categories
  - Dynamic, can be added at runtime
  - No code deployment needed for basic attributes

Why others are incorrect:
- A: Both can work with EAV and flat tables
- C: Both can require module installation depending on implementation
- D: Both are actively used and supported`,
            codeExample: `<!-- Extension Attribute (code-defined) -->
<!-- extension_attributes.xml -->
<extension_attributes for="Magento\\Catalog\\Api\\Data\\ProductInterface">
    <attribute code="warranty_info" type="Vendor\\Module\\Api\\Data\\WarrantyInterface"/>
</extension_attributes>

// Usage
$product->getExtensionAttributes()->getWarrantyInfo();

<!-- Custom Attribute (admin-defined EAV) -->
// Created via: Stores > Attributes > Product > Add New
// Or programmatically:
$eavSetup->addAttribute(
    Product::ENTITY,
    'custom_field',
    ['type' => 'varchar', 'label' => 'Custom Field']
);

// Usage
$product->getCustomAttribute('custom_field')->getValue();
// OR
$product->getData('custom_field');`
          },
          {
            id: 64,
            category: "Service Contracts",
            difficulty: "Medium",
            question: "What is the purpose of the @api annotation in Magento 2 service contracts?",
            options: [
              { id: "A", text: "It exposes the interface as a REST endpoint automatically" },
              { id: "B", text: "It marks the interface as stable and subject to semantic versioning" },
              { id: "C", text: "It enables caching for all methods in the interface" },
              { id: "D", text: "It allows the interface to be used in GraphQL queries" }
            ],
            correctAnswers: ["B"],
            explanation: `The @api annotation marks code as part of Magento's public API with stability guarantees.

Why B is correct:
- @api indicates the interface is part of public API
- Subject to Semantic Versioning (SemVer) rules
- Breaking changes only in major versions (2.x -> 3.x)
- Third-party modules can safely depend on @api code
- Magento commits to backward compatibility

Why others are incorrect:
- A: REST exposure requires webapi.xml configuration
- C: Caching requires separate configuration (cacheable="true")
- D: GraphQL requires schema.graphqls and resolvers`,
            codeExample: `/**
 * Product Repository Interface
 *
 * @api  <-- This annotation is key!
 * @since 100.0.0  <-- Version when API was introduced
 */
interface ProductRepositoryInterface
{
    /**
     * @param int $id
     * @return ProductInterface
     * @throws NoSuchEntityException
     */
    public function getById($id);

    /**
     * @param ProductInterface $product
     * @return ProductInterface
     */
    public function save(ProductInterface $product);
}

// With @api:
// - Guaranteed stable in minor/patch releases
// - Safe to use in third-party modules
// - Breaking changes = major version bump

// Without @api:
// - Internal implementation, may change anytime
// - Use at your own risk in extensions`
          },
          {
            id: 65,
            category: "Web API",
            difficulty: "Medium",
            question: "How should a custom REST API endpoint handle errors to return appropriate HTTP status codes?",
            options: [
              { id: "A", text: "Return an array with 'error' key and HTTP 200 status" },
              { id: "B", text: "Throw specific Webapi exceptions that map to HTTP status codes" },
              { id: "C", text: "Use header() function to set HTTP status before returning" },
              { id: "D", text: "Return null and let Magento handle the error response" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento's Web API framework maps specific exception types to HTTP status codes.

Why B is correct:
- NoSuchEntityException  404 Not Found
- AuthorizationException  401/403 Unauthorized/Forbidden
- InputException  400 Bad Request
- CouldNotSaveException  500 Internal Server Error
- LocalizedException  500 (generic error)
- Framework handles response formatting automatically

Why others are incorrect:
- A: Would always return 200, hiding real error status
- C: Direct header manipulation breaks API framework
- D: Null doesn't trigger proper error handling`,
            codeExample: `// Correct error handling in API service
namespace Vendor\\Module\\Model;

use Magento\\Framework\\Exception\\NoSuchEntityException;
use Magento\\Framework\\Exception\\InputException;
use Magento\\Framework\\Exception\\CouldNotSaveException;

class OrderService implements OrderServiceInterface
{
    public function getOrder($orderId)
    {
        if (!$orderId) {
            // Returns HTTP 400 Bad Request
            throw new InputException(__('Order ID is required'));
        }

        $order = $this->orderRepository->get($orderId);
        if (!$order->getId()) {
            // Returns HTTP 404 Not Found
            throw new NoSuchEntityException(
                __('Order with ID "%1" not found', $orderId)
            );
        }

        return $order;
    }

    public function saveOrder($order)
    {
        try {
            return $this->orderRepository->save($order);
        } catch (\\Exception $e) {
            // Returns HTTP 500 Internal Server Error
            throw new CouldNotSaveException(__('Could not save order'));
        }
    }
}`
          },
          {
            id: 66,
            category: "Web API",
            difficulty: "Hard",
            question: "How does Magento implement bulk/async API operations for processing large datasets?",
            options: [
              { id: "A", text: "By using database transactions to batch multiple operations" },
              { id: "B", text: "By using message queues to process operations asynchronously" },
              { id: "C", text: "By splitting requests into chunks and processing sequentially" },
              { id: "D", text: "By using Redis cache to store operations and process later" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento's Bulk API uses message queues for asynchronous processing of large operations.

Why B is correct:
- Bulk endpoints publish operations to message queue
- Operations processed by consumers in background
- Immediate response with operation UUID for tracking
- Supports RabbitMQ and MySQL queue
- Status tracked in magento_operation and magento_bulk tables

Why others are incorrect:
- A: DB transactions are for atomicity, not async processing
- C: Sequential processing doesn't scale
- D: Redis is not used for bulk operation storage`,
            codeExample: `// Bulk API Request: POST /V1/products/bySku (async)
// Request body with multiple products
[
    {"product": {"sku": "SKU1", "name": "Product 1"}},
    {"product": {"sku": "SKU2", "name": "Product 2"}},
    {"product": {"sku": "SKU3", "name": "Product 3"}}
]

// Immediate Response (HTTP 202 Accepted)
{
    "bulk_uuid": "c43ed402-3cd7-4b9e-9066-5c5c2b060bc2",
    "request_items": [
        {"id": 0, "status": "accepted"},
        {"id": 1, "status": "accepted"},
        {"id": 2, "status": "accepted"}
    ]
}

// Check status: GET /V1/bulk/{bulk_uuid}/status
// Operations processed by: bin/magento queue:consumers:start async.operations.all

// Consumer configuration in queue_consumer.xml
<consumer name="async.operations.all"
          queue="async.operations.all"
          handler="Magento\\AsynchronousOperations\\Model\\MassConsumer"/>`
          },
          {
            id: 67,
            category: "Web API",
            difficulty: "Medium",
            question: "How does Magento handle API versioning for REST and SOAP endpoints?",
            options: [
              { id: "A", text: "Through Accept header versioning (application/json;version=1)" },
              { id: "B", text: "Through URL path versioning (/V1/, /V2/)" },
              { id: "C", text: "Through query parameter (?api-version=1)" },
              { id: "D", text: "Magento does not support API versioning" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento uses URL path versioning for API endpoints.

Why B is correct:
- API version included in URL: /rest/V1/products, /rest/V2/products
- Each module can define routes for different versions
- Version specified in webapi.xml route attribute
- Allows breaking changes in new versions while maintaining old
- Clear, explicit versioning visible in every request

Why others are incorrect:
- A: Magento doesn't use Accept header versioning
- C: Query parameter versioning not implemented
- D: Versioning is explicitly supported`,
            codeExample: `<!-- webapi.xml - API Versioning -->

<!-- Version 1 endpoint -->
<route url="/V1/products/:sku" method="GET">
    <service class="Magento\\Catalog\\Api\\ProductRepositoryInterface" method="get"/>
    <resources>
        <resource ref="Magento_Catalog::products"/>
    </resources>
</route>

<!-- Version 2 endpoint (enhanced) -->
<route url="/V2/products/:sku" method="GET">
    <service class="Vendor\\Module\\Api\\ProductRepositoryV2Interface" method="get"/>
    <resources>
        <resource ref="Magento_Catalog::products"/>
    </resources>
</route>

// Request examples:
// GET /rest/V1/products/SKU123   Returns basic product data
// GET /rest/V2/products/SKU123   Returns enhanced product data

// SOAP also uses versioning:
// /soap/default?wsdl&services=catalogProductRepositoryV1`
          },
          {
            id: 68,
            category: "Web API",
            difficulty: "Medium",
            question: "What configuration file is used to define custom REST API endpoints in Magento 2?",
            options: [
              { id: "A", text: "routes.xml with API route type" },
              { id: "B", text: "webapi.xml with route definitions" },
              { id: "C", text: "api.xml with endpoint configurations" },
              { id: "D", text: "config.xml with API section" }
            ],
            correctAnswers: ["B"],
            explanation: `Custom REST and SOAP API endpoints are defined in webapi.xml.

Why B is correct:
- webapi.xml located in module's etc/ directory
- Defines URL route, HTTP method, service class/method
- Specifies ACL resource for authorization
- Works for both REST and SOAP endpoints
- Can define multiple routes for same service

Why others are incorrect:
- A: routes.xml is for frontend/adminhtml controllers, not API
- C: api.xml doesn't exist for this purpose
- D: config.xml is for general module configuration`,
            codeExample: `<!-- etc/webapi.xml -->
<routes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="urn:magento:module:Magento_Webapi:etc/webapi.xsd">

    <!-- GET endpoint -->
    <route url="/V1/custom/orders/:orderId" method="GET">
        <service class="Vendor\\Module\\Api\\OrderServiceInterface"
                 method="getOrder"/>
        <resources>
            <resource ref="Vendor_Module::order_view"/>
        </resources>
    </route>

    <!-- POST endpoint with request body -->
    <route url="/V1/custom/orders" method="POST">
        <service class="Vendor\\Module\\Api\\OrderServiceInterface"
                 method="createOrder"/>
        <resources>
            <resource ref="Vendor_Module::order_create"/>
        </resources>
        <data>
            <parameter name="orderData" force="true">%order_data%</parameter>
        </data>
    </route>

    <!-- Anonymous access (no auth required) -->
    <route url="/V1/custom/public-info" method="GET">
        <service class="Vendor\\Module\\Api\\InfoServiceInterface" method="getInfo"/>
        <resources>
            <resource ref="anonymous"/>
        </resources>
    </route>
</routes>`
          },
          {
            id: 69,
            category: "Web API",
            difficulty: "Medium",
            question: "How is access control implemented for custom API endpoints in Magento 2?",
            options: [
              { id: "A", text: "By checking user roles in the service class constructor" },
              { id: "B", text: "By defining resource in webapi.xml that maps to acl.xml permissions" },
              { id: "C", text: "By implementing AuthorizationInterface in the service class" },
              { id: "D", text: "By using middleware to intercept requests" }
            ],
            correctAnswers: ["B"],
            explanation: `API authorization uses ACL resources defined in acl.xml and referenced in webapi.xml.

Why B is correct:
- webapi.xml <resource ref="..."/> links to ACL resource
- ACL resources defined in acl.xml hierarchy
- Admin users/integrations assigned resources via roles
- Framework checks authorization before calling service
- Built-in resources: anonymous, self (customer), Magento_*::*

Why others are incorrect:
- A: Authorization happens before service method is called
- C: No such interface for API authorization
- D: Not middleware-based, uses declarative configuration`,
            codeExample: `<!-- etc/acl.xml - Define ACL resources -->
<acl>
    <resources>
        <resource id="Magento_Backend::admin">
            <resource id="Vendor_Module::custom_api" title="Custom API Access">
                <resource id="Vendor_Module::order_view" title="View Orders"/>
                <resource id="Vendor_Module::order_create" title="Create Orders"/>
                <resource id="Vendor_Module::order_delete" title="Delete Orders"/>
            </resource>
        </resource>
    </resources>
</acl>

<!-- etc/webapi.xml - Reference ACL in routes -->
<route url="/V1/custom/orders/:id" method="GET">
    <service class="Vendor\\Module\\Api\\OrderServiceInterface" method="get"/>
    <resources>
        <resource ref="Vendor_Module::order_view"/>
    </resources>
</route>

<route url="/V1/custom/orders/:id" method="DELETE">
    <service class="Vendor\\Module\\Api\\OrderServiceInterface" method="delete"/>
    <resources>
        <resource ref="Vendor_Module::order_delete"/>
    </resources>
</route>

<!-- Special resources -->
<!-- ref="anonymous" - No authentication required -->
<!-- ref="self" - Customer can access own data -->`
          },
          {
            id: 70,
            category: "Web API",
            difficulty: "Medium",
            question: "When should an architect choose SOAP over REST for a Magento 2 integration?",
            options: [
              { id: "A", text: "When the integration requires JSON response format" },
              { id: "B", text: "When a strict contract with WSDL validation is required" },
              { id: "C", text: "When better performance is needed" },
              { id: "D", text: "When the client is a mobile application" }
            ],
            correctAnswers: ["B"],
            explanation: `SOAP is preferred when strict contracts and formal validation are required.

Why B is correct:
- WSDL provides formal contract definition
- Strong typing and validation built-in
- Enterprise systems often require WSDL contracts
- Automatic client generation from WSDL
- Better error handling with SOAP faults

Why others are incorrect:
- A: SOAP uses XML, not JSON (REST uses JSON)
- C: REST generally has better performance (less overhead)
- D: Mobile apps typically prefer REST (lightweight, JSON)`,
            codeExample: `// SOAP Endpoint Access
// WSDL URL: https://magento.test/soap/default?wsdl&services=catalogProductRepositoryV1

// PHP SOAP Client Example
$wsdlUrl = 'https://magento.test/soap/default?wsdl&services=catalogProductRepositoryV1';

$opts = [
    'http' => ['header' => "Authorization: Bearer {$token}"]
];
$context = stream_context_create($opts);

$client = new SoapClient($wsdlUrl, [
    'stream_context' => $context,
    'soap_version' => SOAP_1_2
]);

// Strongly typed call
$result = $client->catalogProductRepositoryV1Get(['sku' => 'SKU123']);

// REST Alternative (simpler, JSON)
$response = $httpClient->get('/rest/V1/products/SKU123', [
    'headers' => ['Authorization' => 'Bearer ' . $token]
]);
$product = json_decode($response->getBody());

// Use SOAP when:
// - Enterprise integration requiring WSDL contracts
// - Legacy systems that only support SOAP
// - Formal API validation requirements`
          },
          {
            id: 71,
            category: "Web API",
            difficulty: "Hard",
            question: "What authentication methods are available for Magento 2 REST API, and when should each be used?",
            options: [
              { id: "A", text: "Only OAuth 1.0 is supported for all API access" },
              { id: "B", text: "Token-based for integrations, OAuth for third-party apps, Session for admin Ajax" },
              { id: "C", text: "Basic HTTP authentication for all scenarios" },
              { id: "D", text: "API keys stored in database for all access types" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento 2 supports multiple authentication methods for different use cases.

Why B is correct:
- Token-based (Bearer): Simple integrations, server-to-server
  - Admin token: POST /V1/integration/admin/token
  - Customer token: POST /V1/integration/customer/token

- OAuth 1.0a: Third-party applications
  - Full OAuth flow with consumer key/secret
  - Used for integrations in System > Integrations

- Session-based: Admin panel Ajax requests
  - Uses existing admin session
  - For admin UI components calling API

Why others are incorrect:
- A: Multiple methods supported, not just OAuth
- C: Basic auth not supported by default
- D: API keys are not the authentication mechanism`,
            codeExample: `// 1. Token-based Authentication (Simple integrations)
// Get admin token
POST /rest/V1/integration/admin/token
{"username": "admin", "password": "admin123"}
// Response: "abc123token..."

// Use token in requests
GET /rest/V1/products/SKU123
Authorization: Bearer abc123token...

// 2. OAuth 1.0a (Third-party apps)
// Configured in Admin: System > Integrations
// Full OAuth handshake with consumer credentials
$oauth = new OAuth($consumerKey, $consumerSecret);
$oauth->setToken($accessToken, $accessSecret);
$oauth->fetch($apiUrl);

// 3. Session-based (Admin Ajax)
// Already authenticated via admin session
// Used by admin UI components
$.ajax({
    url: '/rest/V1/products/SKU123',
    beforeSend: function(xhr) {
        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
    }
    // Session cookie sent automatically
});`
          },
          {
            id: 72,
            category: "Web API",
            difficulty: "Medium",
            question: "How can a developer customize the response format or add additional processing to API responses?",
            options: [
              { id: "A", text: "Override the REST controller class" },
              { id: "B", text: "Use a plugin on the service method or implement custom processors" },
              { id: "C", text: "Modify the webapi.xml response format attribute" },
              { id: "D", text: "Create a custom response renderer class" }
            ],
            correctAnswers: ["B"],
            explanation: `API responses can be customized using plugins on service methods or custom processors.

Why B is correct:
- Plugins on service interface methods (before/after/around)
- Modify input parameters or output data
- Processors in webapi.xml for special handling
- Extension attributes for adding data to responses
- Maintains separation of concerns

Why others are incorrect:
- A: REST controllers are part of framework, not meant to be overridden
- C: No response format attribute in webapi.xml
- D: Response rendering is handled by framework serializers`,
            codeExample: `// Method 1: Plugin on Service Method
class ProductRepositoryPlugin
{
    public function afterGet(
        ProductRepositoryInterface $subject,
        ProductInterface $result
    ) {
        // Add custom data to response
        $extensionAttributes = $result->getExtensionAttributes();
        $extensionAttributes->setCustomData($this->getCustomData($result));
        $result->setExtensionAttributes($extensionAttributes);

        return $result;
    }
}

// di.xml
<type name="Magento\\Catalog\\Api\\ProductRepositoryInterface">
    <plugin name="add_custom_data" type="Vendor\\Module\\Plugin\\ProductRepositoryPlugin"/>
</type>

// Method 2: Data Processor for complex transformations
// webapi.xml
<route url="/V1/custom/products/:sku" method="GET">
    <service class="Vendor\\Module\\Api\\ProductServiceInterface" method="get"/>
    <resources><resource ref="anonymous"/></resources>
    <data>
        <parameter name="sku" force="true">%sku%</parameter>
    </data>
</route>

// Custom service returns exactly what you want
public function get($sku): array {
    return ['sku' => $sku, 'formatted_price' => '$99.99'];
}`
          },
          {
            id: 73,
            category: "GraphQL",
            difficulty: "Medium",
            question: "How do you extend an existing GraphQL type in Magento 2 to add custom fields?",
            options: [
              { id: "A", text: "Override the original schema.graphqls file" },
              { id: "B", text: "Use the 'extend type' keyword in your module's schema.graphqls" },
              { id: "C", text: "Create a plugin on the GraphQL resolver" },
              { id: "D", text: "Modify the core GraphQL module configuration" }
            ],
            correctAnswers: ["B"],
            explanation: `The 'extend type' keyword allows adding fields to existing GraphQL types without modifying core files.

Why B is correct:
- 'extend type TypeName' adds fields to existing type
- Defined in module's etc/schema.graphqls
- Magento merges all schema files automatically
- Requires corresponding resolver for new fields
- Non-destructive extension pattern

Why others are incorrect:
- A: Overriding core files is bad practice
- C: Plugins work on resolvers, not schema definition
- D: Core module modification breaks upgrades`,
            codeExample: `# etc/schema.graphqls

# Extend existing Product type with custom field
extend type ProductInterface {
    warranty_period: Int @doc(description: "Warranty period in months")
    custom_label: String @resolver(class: "Vendor\\Module\\Model\\Resolver\\CustomLabel")
}

# Extend Query type to add custom query
extend type Query {
    customProducts(
        filter: ProductFilterInput
        pageSize: Int = 20
        currentPage: Int = 1
    ): Products @resolver(class: "Vendor\\Module\\Model\\Resolver\\CustomProducts")
}

# Extend Mutation type
extend type Mutation {
    addWarranty(input: WarrantyInput!): WarrantyOutput
        @resolver(class: "Vendor\\Module\\Model\\Resolver\\AddWarranty")
}

# Define custom input/output types
input WarrantyInput {
    product_id: Int!
    period: Int!
}

type WarrantyOutput {
    success: Boolean!
    message: String
}`
          },
          {
            id: 74,
            category: "GraphQL",
            difficulty: "Medium",
            question: "What interface must a GraphQL resolver class implement in Magento 2?",
            options: [
              { id: "A", text: "Magento\\Framework\\GraphQl\\Query\\ResolverInterface" },
              { id: "B", text: "Magento\\Framework\\GraphQl\\ResolverInterface" },
              { id: "C", text: "Magento\\GraphQl\\Model\\ResolverInterface" },
              { id: "D", text: "Magento\\Framework\\GraphQl\\Query\\Resolver\\ResolverInterface" }
            ],
            correctAnswers: ["A"],
            explanation: `GraphQL resolvers must implement ResolverInterface from the GraphQl Query namespace.

Why A is correct:
- Full path: Magento\\Framework\\GraphQl\\Query\\ResolverInterface
- Requires resolve() method implementation
- Receives Field, Context, ResolveInfo, and arguments
- Returns array or object matching GraphQL type
- Context contains store, customer, and extension info

Why others are incorrect:
- B, C, D: These are not the correct namespace/interface paths`,
            codeExample: `namespace Vendor\\Module\\Model\\Resolver;

use Magento\\Framework\\GraphQl\\Query\\ResolverInterface;
use Magento\\Framework\\GraphQl\\Config\\Element\\Field;
use Magento\\Framework\\GraphQl\\Schema\\Type\\ResolveInfo;

class CustomProducts implements ResolverInterface
{
    public function resolve(
        Field $field,
        $context,
        ResolveInfo $info,
        array $value = null,
        array $args = null
    ) {
        // Access store context
        $storeId = (int)$context->getExtensionAttributes()->getStore()->getId();

        // Access arguments from GraphQL query
        $pageSize = $args['pageSize'] ?? 20;
        $currentPage = $args['currentPage'] ?? 1;

        // Return data matching ProductsOutput type
        return [
            'items' => $this->getProducts($args),
            'total_count' => $this->getTotalCount($args),
            'page_info' => [
                'page_size' => $pageSize,
                'current_page' => $currentPage
            ]
        ];
    }
}`
          },
          {
            id: 75,
            category: "GraphQL",
            difficulty: "Hard",
            question: "How does Magento implement caching for GraphQL queries, and what interface must be implemented for custom cache identities?",
            options: [
              { id: "A", text: "GraphQL responses are not cached in Magento" },
              { id: "B", text: "Implement CacheIdFactorProviderInterface to add custom cache factors" },
              { id: "C", text: "Use standard block caching with cache tags" },
              { id: "D", text: "Implement CacheableInterface on the resolver class" }
            ],
            correctAnswers: ["B"],
            explanation: `GraphQL uses CacheIdFactorProviderInterface to determine cache identity factors.

Why B is correct:
- GraphQL GET requests are cached by Varnish/Fastly
- Cache ID composed of multiple factors (store, currency, customer group)
- Custom factors via CacheIdFactorProviderInterface
- Resolvers can provide cache identity via IdentityInterface
- X-Magento-Cache-Id header used for cache key

Why others are incorrect:
- A: GraphQL GET queries ARE cached
- C: Block caching is for HTML, not GraphQL
- D: No such interface for resolvers`,
            codeExample: `// Custom Cache Factor Provider
namespace Vendor\\Module\\Model\\CacheId;

use Magento\\GraphQlCache\\Model\\CacheId\\CacheIdFactorProviderInterface;

class CustomCacheFactor implements CacheIdFactorProviderInterface
{
    public function getFactorName(): string
    {
        return 'CUSTOM_FACTOR';
    }

    public function getFactorValue(ContextInterface $context): string
    {
        // Return value that affects cache identity
        return $this->getCustomValue($context);
    }
}

// di.xml registration
<type name="Magento\\GraphQlCache\\Model\\CacheId\\CacheIdCalculator">
    <arguments>
        <argument name="idFactorProviders" xsi:type="array">
            <item name="custom_factor" xsi:type="object">
                Vendor\\Module\\Model\\CacheId\\CustomCacheFactor
            </item>
        </argument>
    </arguments>
</type>

// Resolver with Cache Identity
class ProductResolver implements ResolverInterface, IdentityInterface
{
    public function getIdentities(array $resolvedData): array
    {
        // Return cache tags for invalidation
        return ['cat_p_' . $resolvedData['entity_id']];
    }
}`
          },
          {
            id: 76,
            category: "GraphQL",
            difficulty: "Medium",
            question: "What is the correct way to define a GraphQL mutation that accepts complex input in Magento 2?",
            options: [
              { id: "A", text: "Define parameters directly in the mutation signature" },
              { id: "B", text: "Use an input type and reference it in the mutation with ! for required" },
              { id: "C", text: "Pass JSON string as the only parameter" },
              { id: "D", text: "Use query variables without type definitions" }
            ],
            correctAnswers: ["B"],
            explanation: `GraphQL mutations should use input types for complex data structures.

Why B is correct:
- Input types group related parameters
- ! suffix marks fields as required (non-nullable)
- Clear contract for API consumers
- Enables validation and documentation
- Follows GraphQL best practices

Why others are incorrect:
- A: Direct parameters don't scale for complex inputs
- C: JSON strings bypass GraphQL type system
- D: Variables must have type definitions`,
            codeExample: `# schema.graphqls

# Define input type for mutation
input CreateOrderInput {
    cart_id: String!
    shipping_address: AddressInput!
    billing_address: AddressInput
    payment_method: PaymentMethodInput!
    shipping_method: String!
}

input AddressInput {
    firstname: String!
    lastname: String!
    street: [String!]!
    city: String!
    region: String
    postcode: String!
    country_code: String!
    telephone: String!
}

input PaymentMethodInput {
    code: String!
    additional_data: [KeyValueInput]
}

# Define mutation with input type
type Mutation {
    createOrder(input: CreateOrderInput!): CreateOrderOutput
        @resolver(class: "Vendor\\Module\\Model\\Resolver\\CreateOrder")
}

type CreateOrderOutput {
    order_id: String
    order_number: String
    success: Boolean!
    message: String
}`
          },
          {
            id: 77,
            category: "GraphQL",
            difficulty: "Hard",
            question: "How can you optimize GraphQL resolver performance to avoid N+1 query problems?",
            options: [
              { id: "A", text: "Use synchronous database queries in each resolver" },
              { id: "B", text: "Implement BatchResolverInterface or use DataLoader pattern" },
              { id: "C", text: "Cache all resolver results in session" },
              { id: "D", text: "Limit the number of fields in the query" }
            ],
            correctAnswers: ["B"],
            explanation: `BatchResolverInterface allows batching multiple resolver calls into a single database query.

Why B is correct:
- BatchResolverInterface for resolving multiple items at once
- Collects all IDs first, then single batch query
- DataLoader pattern defers execution and batches
- Reduces N+1 to 1+1 query pattern
- Critical for nested relationships

Why others are incorrect:
- A: Synchronous queries cause N+1 problem
- C: Session caching doesn't solve N+1
- D: Limiting fields doesn't address query batching`,
            codeExample: `// BatchResolverInterface Implementation
namespace Vendor\\Module\\Model\\Resolver;

use Magento\\Framework\\GraphQl\\Query\\Resolver\\BatchResolverInterface;
use Magento\\Framework\\GraphQl\\Query\\Resolver\\BatchResponse;

class ProductImages implements BatchResolverInterface
{
    public function resolve(
        ContextInterface $context,
        Field $field,
        array $requests
    ): BatchResponse {
        // Collect all product IDs from batch requests
        $productIds = [];
        foreach ($requests as $request) {
            $productIds[] = $request->getValue()['entity_id'];
        }

        // Single batch query for all products
        $imagesData = $this->imageRepository->getByProductIds($productIds);

        // Build response for each request
        $response = new BatchResponse();
        foreach ($requests as $request) {
            $productId = $request->getValue()['entity_id'];
            $response->addResponse(
                $request,
                $imagesData[$productId] ?? []
            );
        }

        return $response;
    }
}

// Without batching: N queries (one per product)
// With batching: 1 query (all products at once)`
          },
          {
            id: 78,
            category: "GraphQL",
            difficulty: "Medium",
            question: "What are the main components of PWA Studio architecture for Adobe Commerce?",
            options: [
              { id: "A", text: "Venia (UI components) and Peregrine (business logic hooks)" },
              { id: "B", text: "React Router and Redux for state management" },
              { id: "C", text: "Vue.js components and Vuex store" },
              { id: "D", text: "Angular modules and services" }
            ],
            correctAnswers: ["A"],
            explanation: `PWA Studio uses Venia for UI and Peregrine for business logic.

Why A is correct:
- Venia: Reference storefront UI components
  - React components for common ecommerce patterns
  - Customizable and extensible
  - Uses CSS Modules for styling

- Peregrine: Business logic library
  - Custom React hooks (useTalons)
  - GraphQL queries/mutations
  - Cart, checkout, customer logic
  - Reusable across different UIs

Why others are incorrect:
- B: While React is used, Redux is not the main state solution
- C: PWA Studio is React-based, not Vue
- D: Not Angular-based`,
            codeExample: `// Peregrine Talon (Business Logic)
import { useProduct } from '@magento/peregrine/lib/talons/Product/useProduct';

// Venia Component (UI)
import { ProductFullDetail } from '@magento/venia-ui/lib/components/ProductFullDetail';

// Custom component using Peregrine talon
const MyProductPage = () => {
    // Peregrine hook handles GraphQL, state, logic
    const talonProps = useProduct({
        queries: {
            getProductQuery: GET_PRODUCT_QUERY
        }
    });

    const { product, loading, error } = talonProps;

    if (loading) return <LoadingIndicator />;
    if (error) return <ErrorView />;

    // Venia component for UI
    return <ProductFullDetail product={product} />;
};

// PWA Studio Architecture:
// Peregrine (talons)  Business logic, GraphQL, state
// Venia (components)  UI presentation
// Buildpack  Build tools, webpack configuration
// UPWARD  Server-side rendering, routing`
          },
          {
            id: 79,
            category: "GraphQL",
            difficulty: "Hard",
            question: "What is the correct sequence of GraphQL mutations for a headless checkout flow?",
            options: [
              { id: "A", text: "placeOrder  setPayment  setShipping  createCart" },
              { id: "B", text: "createEmptyCart  addToCart  setShippingAddress  setShippingMethod  setPaymentMethod  placeOrder" },
              { id: "C", text: "addToCart  checkout  pay  complete" },
              { id: "D", text: "initCheckout  processPayment  finalizeOrder" }
            ],
            correctAnswers: ["B"],
            explanation: `Headless checkout requires a specific sequence of GraphQL mutations.

Why B is correct:
- createEmptyCart: Initialize cart, get cart ID
- addProductsToCart: Add items to cart
- setShippingAddresses: Set delivery address
- setShippingMethods: Choose shipping option
- setPaymentMethod: Select payment method
- setBillingAddress: Set billing if different
- placeOrder: Complete the order

Why others are incorrect:
- A: Reversed order, can't place order first
- C: Not Magento's mutation names
- D: Not Magento's mutation names`,
            codeExample: `// 1. Create empty cart
mutation {
    createEmptyCart
}
// Returns: "abc123cartId"

// 2. Add products to cart
mutation {
    addProductsToCart(cartId: "abc123", cartItems: [
        {sku: "SKU1", quantity: 2}
    ]) {
        cart { items { id quantity } }
    }
}

// 3. Set shipping address
mutation {
    setShippingAddressesOnCart(input: {
        cart_id: "abc123"
        shipping_addresses: [{
            address: {
                firstname: "John", lastname: "Doe"
                street: ["123 Main St"], city: "Austin"
                region: "TX", postcode: "78701"
                country_code: "US", telephone: "555-1234"
            }
        }]
    }) { cart { shipping_addresses { available_shipping_methods { carrier_code method_code } } } }
}

// 4. Set shipping method
mutation {
    setShippingMethodsOnCart(input: {
        cart_id: "abc123"
        shipping_methods: [{ carrier_code: "flatrate", method_code: "flatrate" }]
    }) { cart { shipping_addresses { selected_shipping_method { carrier_code } } } }
}

// 5. Set payment method
mutation {
    setPaymentMethodOnCart(input: {
        cart_id: "abc123"
        payment_method: { code: "checkmo" }
    }) { cart { selected_payment_method { code } } }
}

// 6. Place order
mutation {
    placeOrder(input: { cart_id: "abc123" }) {
        order { order_number }
    }
}`
          },
          {
            id: 80,
            category: "GraphQL",
            difficulty: "Medium",
            question: "How is customer authentication handled in GraphQL queries and mutations?",
            options: [
              { id: "A", text: "Session cookies are automatically sent with each request" },
              { id: "B", text: "Customer token in Authorization header as Bearer token" },
              { id: "C", text: "API key passed as query parameter" },
              { id: "D", text: "Username and password in each request body" }
            ],
            correctAnswers: ["B"],
            explanation: `GraphQL uses Bearer token authentication for customer operations.

Why B is correct:
- Generate token via generateCustomerToken mutation
- Pass token in Authorization: Bearer header
- Token required for customer-specific operations
- Token validates customer identity for each request
- Can revoke token via revokeCustomerToken

Why others are incorrect:
- A: GraphQL is stateless, no sessions
- C: No API key mechanism in GraphQL
- D: Credentials only used for token generation`,
            codeExample: `// 1. Generate customer token
mutation {
    generateCustomerToken(
        email: "customer@example.com"
        password: "password123"
    ) {
        token
    }
}
// Returns: { "token": "abc123customertoken..." }

// 2. Use token in subsequent requests
// HTTP Header: Authorization: Bearer abc123customertoken...

query {
    customer {
        firstname
        lastname
        email
        orders {
            items {
                order_number
                total { grand_total { value currency } }
            }
        }
    }
}

// 3. For mutations requiring auth
mutation {
    updateCustomer(input: {
        firstname: "Jane"
    }) {
        customer {
            firstname
        }
    }
}

// 4. Revoke token on logout
mutation {
    revokeCustomerToken {
        result
    }
}

// GraphQL Context provides customer info
// $context->getUserId() returns customer ID if authenticated`
          },
          {
            id: 81,
            category: "GraphQL",
            difficulty: "Medium",
            question: "What files are required to create a custom GraphQL endpoint in Magento 2?",
            options: [
              { id: "A", text: "Only schema.graphqls file" },
              { id: "B", text: "schema.graphqls, resolver class, and di.xml registration" },
              { id: "C", text: "webapi.xml with GraphQL route type" },
              { id: "D", text: "graphql.xml configuration file" }
            ],
            correctAnswers: ["B"],
            explanation: `A custom GraphQL endpoint requires schema definition, resolver, and DI configuration.

Why B is correct:
- schema.graphqls: Define types, queries, mutations
- Resolver class: Implement business logic
- di.xml: Register resolver class (if using interfaces)
- @resolver directive connects schema to PHP class
- Optional: DataProvider for data preparation

Why others are incorrect:
- A: Schema alone doesn't provide implementation
- C: webapi.xml is for REST/SOAP, not GraphQL
- D: No such file in Magento GraphQL`,
            codeExample: `# 1. etc/schema.graphqls
type Query {
    customEndpoint(id: Int!): CustomData
        @resolver(class: "Vendor\\Module\\Model\\Resolver\\CustomData")
        @doc(description: "Get custom data by ID")
        @cache(cacheIdentity: "Vendor\\Module\\Model\\Resolver\\CustomData\\Identity")
}

type CustomData {
    id: Int
    name: String
    value: Float
}

# 2. Model/Resolver/CustomData.php
namespace Vendor\\Module\\Model\\Resolver;

use Magento\\Framework\\GraphQl\\Query\\ResolverInterface;

class CustomData implements ResolverInterface
{
    public function resolve($field, $context, $info, $value = null, $args = null)
    {
        $id = $args['id'];
        return [
            'id' => $id,
            'name' => 'Custom Item',
            'value' => 99.99
        ];
    }
}

# 3. etc/di.xml (if needed for dependencies)
<type name="Vendor\\Module\\Model\\Resolver\\CustomData">
    <arguments>
        <argument name="repository" xsi:type="object">
            Vendor\\Module\\Api\\CustomRepositoryInterface
        </argument>
    </arguments>
</type>`
          },
          {
            id: 82,
            category: "GraphQL",
            difficulty: "Medium",
            question: "How should errors be handled in GraphQL resolvers to return proper error responses?",
            options: [
              { id: "A", text: "Return null and let the framework handle it" },
              { id: "B", text: "Throw GraphQlInputException or GraphQlAuthorizationException" },
              { id: "C", text: "Return an array with 'error' key" },
              { id: "D", text: "Use try-catch and return empty result" }
            ],
            correctAnswers: ["B"],
            explanation: `GraphQL has specific exception types for different error scenarios.

Why B is correct:
- GraphQlInputException: Invalid input data (400-level)
- GraphQlAuthorizationException: Auth failures (401/403)
- GraphQlNoSuchEntityException: Resource not found (404)
- GraphQlAlreadyExistsException: Duplicate resource
- Exceptions formatted in GraphQL errors array

Why others are incorrect:
- A: Null doesn't explain the error
- C: Not standard GraphQL error format
- D: Silent failures hide problems`,
            codeExample: `namespace Vendor\\Module\\Model\\Resolver;

use Magento\\Framework\\GraphQl\\Exception\\GraphQlInputException;
use Magento\\Framework\\GraphQl\\Exception\\GraphQlAuthorizationException;
use Magento\\Framework\\GraphQl\\Exception\\GraphQlNoSuchEntityException;

class CustomResolver implements ResolverInterface
{
    public function resolve($field, $context, $info, $value = null, $args = null)
    {
        // Validation error
        if (empty($args['id'])) {
            throw new GraphQlInputException(
                __('ID is required')
            );
        }

        // Authorization check
        if (!$context->getUserId()) {
            throw new GraphQlAuthorizationException(
                __('Customer must be logged in')
            );
        }

        // Not found
        $item = $this->repository->getById($args['id']);
        if (!$item->getId()) {
            throw new GraphQlNoSuchEntityException(
                __('Item with ID %1 not found', $args['id'])
            );
        }

        return $item->getData();
    }
}

// Response format for errors:
{
    "errors": [{
        "message": "ID is required",
        "extensions": {
            "category": "graphql-input"
        },
        "path": ["customEndpoint"]
    }],
    "data": { "customEndpoint": null }
}`
          },
          {
            id: 83,
            category: "Message Queue",
            difficulty: "Hard",
            question: "What configuration files are required to set up a custom message queue topology in Magento 2?",
            options: [
              { id: "A", text: "queue.xml only" },
              { id: "B", text: "communication.xml for topics, queue_topology.xml for exchanges/queues, queue_consumer.xml for consumers" },
              { id: "C", text: "amqp.xml for RabbitMQ configuration" },
              { id: "D", text: "events.xml with queue attribute" }
            ],
            correctAnswers: ["B"],
            explanation: `Message queue topology requires three configuration files working together.

Why B is correct:
- communication.xml: Define topics (message types) and handlers
- queue_topology.xml: Define exchanges, queues, and bindings
- queue_consumer.xml: Define consumers that process messages
- queue_publisher.xml: Optional, for custom publishers
- All in module's etc/ directory

Why others are incorrect:
- A: queue.xml is deprecated, replaced by three files
- C: No such file, AMQP config is in env.php
- D: events.xml is for observers, not queues`,
            codeExample: `<!-- etc/communication.xml - Define topics -->
<config>
    <topic name="custom.topic.name" request="Vendor\\Module\\Api\\Data\\MessageInterface">
        <handler name="customHandler" type="Vendor\\Module\\Model\\Consumer" method="process"/>
    </topic>
</config>

<!-- etc/queue_topology.xml - Define queues -->
<config>
    <exchange name="magento" type="topic" connection="amqp">
        <binding id="customBinding" topic="custom.topic.name"
                 destinationType="queue" destination="custom.queue"/>
    </exchange>
</config>

<!-- etc/queue_consumer.xml - Define consumers -->
<config>
    <consumer name="customConsumer"
              queue="custom.queue"
              handler="Vendor\\Module\\Model\\Consumer::process"
              consumerInstance="Magento\\Framework\\MessageQueue\\Consumer"
              connection="amqp"/>
</config>

// Run consumer: bin/magento queue:consumers:start customConsumer`
          },
          {
            id: 84,
            category: "Message Queue",
            difficulty: "Medium",
            question: "When should an architect choose asynchronous message queue processing over synchronous processing?",
            options: [
              { id: "A", text: "When immediate response is required for the user" },
              { id: "B", text: "When the operation is time-consuming and doesn't need immediate completion" },
              { id: "C", text: "When processing simple database queries" },
              { id: "D", text: "When the operation must be atomic with the triggering action" }
            ],
            correctAnswers: ["B"],
            explanation: `Async processing is ideal for time-consuming operations that can be deferred.

Why B is correct:
- Long-running operations (email sending, export generation)
- Operations that can fail and retry
- High-volume operations (bulk imports)
- External API calls that may be slow
- Tasks that don't block user experience

Why others are incorrect:
- A: Immediate response needs sync processing
- C: Simple queries don't need async overhead
- D: Atomic operations require sync processing`,
            codeExample: `// Async: Publish to queue (returns immediately)
class ProductExportService
{
    public function __construct(
        private PublisherInterface $publisher
    ) {}

    public function exportProducts(array $productIds): void
    {
        // Returns immediately - processing happens later
        foreach ($productIds as $productId) {
            $this->publisher->publish(
                'product.export',
                json_encode(['product_id' => $productId])
            );
        }
    }
}

// Sync: Process immediately (blocks until done)
class ProductService
{
    public function updateStock(int $productId, int $qty): void
    {
        // Must complete before returning
        $this->stockRepository->updateQty($productId, $qty);
        $this->indexer->reindexRow($productId);
        // User waits for all this to complete
    }
}

// Use async when:
// - Sending emails, notifications
// - Generating reports, exports
// - Processing bulk operations
// - Calling external APIs`
          },
          {
            id: 85,
            category: "Message Queue",
            difficulty: "Medium",
            question: "How is RabbitMQ configured as the message queue backend in Adobe Commerce?",
            options: [
              { id: "A", text: "In app/etc/config.php under queue section" },
              { id: "B", text: "In app/etc/env.php under queue configuration" },
              { id: "C", text: "In Admin panel under System > Configuration" },
              { id: "D", text: "In composer.json as a dependency" }
            ],
            correctAnswers: ["B"],
            explanation: `RabbitMQ connection settings are configured in env.php.

Why B is correct:
- env.php contains environment-specific configuration
- Queue section defines connection parameters
- Supports AMQP (RabbitMQ) and MySQL backends
- Configuration includes host, port, user, password, virtualhost
- Can have multiple connections for different purposes

Why others are incorrect:
- A: config.php is for module states, not queue config
- C: Admin panel doesn't have queue connection settings
- D: composer.json is for dependencies, not runtime config`,
            codeExample: `// app/etc/env.php
'queue' => [
    'amqp' => [
        'host' => 'rabbitmq.local',
        'port' => '5672',
        'user' => 'magento',
        'password' => 'magento',
        'virtualhost' => '/',
        'ssl' => false,
        'ssl_options' => []
    ],
    // Optional: Configure consumers
    'consumers_wait_for_messages' => 0,
    'only_spawn_when_message_available' => 1
],

// For MySQL-based queue (simpler, less performant)
'queue' => [
    'default' => 'db'  // Uses MySQL instead of AMQP
],

// Check queue status
// bin/magento queue:consumers:list
// bin/magento queue:consumers:start <consumer_name>

// Cloud: Configured in .magento.env.yaml
// stage:
//   deploy:
//     QUEUE_CONFIGURATION:
//       amqp:
//         host: rabbitmq.internal`
          },
          {
            id: 86,
            category: "Message Queue",
            difficulty: "Hard",
            question: "How does Magento's Bulk API use message queues for asynchronous processing?",
            options: [
              { id: "A", text: "Each bulk request creates a database transaction" },
              { id: "B", text: "Operations are published to queue, tracked in bulk tables, processed by consumers" },
              { id: "C", text: "Bulk requests are processed synchronously in batches" },
              { id: "D", text: "External scheduler triggers bulk processing" }
            ],
            correctAnswers: ["B"],
            explanation: `Bulk API leverages message queues with tracking tables for async operations.

Why B is correct:
- magento_bulk: Tracks bulk operation metadata
- magento_operation: Individual operation status
- Messages published to async.operations.* queues
- Consumers process messages asynchronously
- Status queryable via API during processing

Why others are incorrect:
- A: Transactions are per-operation, not per-bulk
- C: Processing is async via queue, not sync batches
- D: No external scheduler, uses queue consumers`,
            codeExample: `// Bulk API Flow
// 1. Client sends bulk request
POST /rest/V1/products (with multiple items)

// 2. BulkManagement creates tracking records
$bulkUuid = $this->bulkManagement->scheduleBulk(
    $bulkUuid,
    $operations,  // Array of OperationInterface
    'Bulk Product Import',
    $userId
);

// 3. Operations published to queue
// Topic: async.operations.all
// Each operation serialized and queued

// 4. Consumer processes operations
// bin/magento queue:consumers:start async.operations.all

// 5. Client checks status
GET /rest/V1/bulk/{bulkUuid}/status

// Response:
{
    "operations_list": [
        {"id": 1, "status": 1, "result_message": "Success"},
        {"id": 2, "status": 2, "result_message": "Processing"},
        {"id": 3, "status": 4, "error_code": 500}
    ],
    "user_type": 2,
    "bulk_id": "uuid-here"
}

// Status codes: 1=Complete, 2=Processing, 3=NotStarted, 4=Failed`
          },
          {
            id: 87,
            category: "Message Queue",
            difficulty: "Medium",
            question: "What are deferred operations in Magento and when are they used?",
            options: [
              { id: "A", text: "Operations that run only at night during low traffic" },
              { id: "B", text: "Operations postponed until necessary, like stock reservation or total calculation" },
              { id: "C", text: "Deprecated operations scheduled for removal" },
              { id: "D", text: "Operations that require manual admin approval" }
            ],
            correctAnswers: ["B"],
            explanation: `Deferred operations postpone processing until the result is actually needed.

Why B is correct:
- Stock reservations: Deferred until checkout
- Quote totals: Recalculated when needed
- Index updates: Batched for efficiency
- Reduces unnecessary processing
- Improves performance for abandoned carts

Why others are incorrect:
- A: Not time-based scheduling
- C: Not about deprecation
- D: Not about approval workflow`,
            codeExample: `// Deferred Stock Reservation (MSI)
// Reservation not immediately deducted from inventory

class PlaceReservationsForSalesEvent
{
    public function execute(array $items, int $stockId): void
    {
        // Reservations are "pending" until order ships
        $reservations = [];
        foreach ($items as $item) {
            $reservations[] = $this->reservationBuilder
                ->setSku($item->getSku())
                ->setQuantity(-$item->getQty()) // Negative = reserved
                ->setStockId($stockId)
                ->setMetadata($metadata)
                ->build();
        }
        // Saved to inventory_reservation table
        $this->appendReservations->execute($reservations);
    }
}

// Deferred Total Calculation
class Quote
{
    private $totalsCollectedFlag = false;

    public function getGrandTotal()
    {
        if (!$this->totalsCollectedFlag) {
            // Only calculate when actually requested
            $this->collectTotals();
        }
        return $this->getData('grand_total');
    }
}`
          },
          {
            id: 88,
            category: "Message Queue",
            difficulty: "Hard",
            question: "How does Magento handle failed message queue operations and poison messages?",
            options: [
              { id: "A", text: "Failed messages are immediately deleted" },
              { id: "B", text: "Messages are retried based on configuration, then moved to error queue after max retries" },
              { id: "C", text: "All failures are logged but messages continue processing" },
              { id: "D", text: "Failed messages block the entire queue" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento implements retry logic and poison message handling for failed operations.

Why B is correct:
- maxRetries configuration in queue_consumer.xml
- Failed messages requeued for retry
- After max retries, moved to *.failed queue
- Poison messages don't block other messages
- Errors logged for investigation

Why others are incorrect:
- A: Messages aren't immediately deleted, they retry
- C: Failures do affect message disposition
- D: Parallel processing continues`,
            codeExample: `<!-- etc/queue_consumer.xml -->
<consumer name="product.import"
          queue="product.import.queue"
          handler="Vendor\\Module\\Model\\Consumer::process"
          maxRetries="3"  <!-- Retry 3 times before failing -->
          connection="amqp"/>

// Consumer with error handling
class Consumer
{
    public function process(string $message): void
    {
        try {
            $data = json_decode($message, true);
            $this->importProduct($data);
        } catch (\\Exception $e) {
            // Log error - message will be requeued
            $this->logger->error('Import failed: ' . $e->getMessage());
            // Throw exception to trigger retry
            throw $e;
        }
    }
}

// After maxRetries, message goes to:
// product.import.queue.failed (poison queue)

// Monitor failed messages:
// RabbitMQ Management UI shows failed queue
// Or query: SELECT * FROM queue_message WHERE status = 'failed'

// Reprocess failed messages manually:
// Move from .failed queue back to main queue`
          },
          {
            id: 89,
            category: "Adobe Commerce Cloud",
            difficulty: "Medium",
            question: "What is the purpose of .magento.app.yaml in Adobe Commerce Cloud?",
            options: [
              { id: "A", text: "Define database schema migrations" },
              { id: "B", text: "Configure application type, relationships, hooks, and runtime settings" },
              { id: "C", text: "Set environment variables for production" },
              { id: "D", text: "Define GraphQL schema extensions" }
            ],
            correctAnswers: ["B"],
            explanation: `.magento.app.yaml is the main application configuration file for Cloud.

Why B is correct:
- Defines application type (php:8.1)
- Configures relationships to services (database, redis, elasticsearch)
- Sets up build/deploy hooks
- Configures disk mounts and web locations
- Defines cron jobs and workers

Why others are incorrect:
- A: Schema is in db_schema.xml
- C: Environment vars are in .magento.env.yaml
- D: GraphQL schema is in schema.graphqls`,
            codeExample: `# .magento.app.yaml
name: mymagento
type: php:8.2
build:
    flavor: none

relationships:
    database: "mysql:mysql"
    redis: "redis:redis"
    opensearch: "opensearch:opensearch"

web:
    locations:
        "/":
            root: "pub"
            passthru: "/index.php"
            index: ["index.php"]
            scripts: true
        "/media":
            root: "pub/media"
            scripts: false
            allow: true

disk: 5120

mounts:
    "var": "shared:files/var"
    "pub/media": "shared:files/media"
    "pub/static": "shared:files/static"

hooks:
    build: |
        set -e
        php ./vendor/bin/ece-tools run scenario/build/generate.xml
        php ./vendor/bin/ece-tools run scenario/build/transfer.xml
    deploy: |
        php ./vendor/bin/ece-tools run scenario/deploy.xml
    post_deploy: |
        php ./vendor/bin/ece-tools run scenario/post-deploy.xml

crons:
    cronrun:
        spec: "*/1 * * * *"
        cmd: "php bin/magento cron:run"`
          },
          {
            id: 90,
            category: "Adobe Commerce Cloud",
            difficulty: "Medium",
            question: "How are environment-specific variables configured in Adobe Commerce Cloud?",
            options: [
              { id: "A", text: "In app/etc/config.php for all environments" },
              { id: "B", text: "In .magento.env.yaml with stage-specific sections" },
              { id: "C", text: "Through Admin panel configuration only" },
              { id: "D", text: "In composer.json extra section" }
            ],
            correctAnswers: ["B"],
            explanation: `.magento.env.yaml allows stage-specific environment configuration.

Why B is correct:
- Define variables per stage: global, build, deploy, post-deploy
- Override default ece-tools behavior
- Set SCD, database, caching options
- Environment hierarchy: .magento.env.yaml < Project < Environment
- Cloud Console can override file settings

Why others are incorrect:
- A: config.php is for module states, not Cloud config
- C: Admin config is stored in database
- D: composer.json is for dependencies`,
            codeExample: `# .magento.env.yaml
stage:
    global:
        SCD_ON_DEMAND: true
        SKIP_HTML_MINIFICATION: true

    build:
        SCD_STRATEGY: "compact"
        SCD_THREADS: 4
        SKIP_SCD: false

    deploy:
        DATABASE_CONFIGURATION:
            _merge: true
            slave_connection:
                host: mysql-slave.internal
        REDIS_BACKEND: "\\Magento\\Framework\\Cache\\Backend\\Redis"
        CACHE_CONFIGURATION:
            frontend:
                default:
                    backend: cache
                page_cache:
                    backend: cache
        QUEUE_CONFIGURATION:
            amqp:
                host: rabbitmq.internal

    post-deploy:
        WARM_UP_PAGES:
            - "index.php"
            - "index.php/customer/account/create"

# Environment variable override (Cloud Console or CLI):
# magento-cloud variable:set VARIABLE_NAME value --level environment`
          },
          {
            id: 91,
            category: "Adobe Commerce Cloud",
            difficulty: "Medium",
            question: "How are custom domains and routes configured in Adobe Commerce Cloud?",
            options: [
              { id: "A", text: "In Magento Admin under Stores > Configuration > Web" },
              { id: "B", text: "In routes.yaml with upstream and redirect definitions" },
              { id: "C", text: "Through DNS settings only" },
              { id: "D", text: "In .htaccess file" }
            ],
            correctAnswers: ["B"],
            explanation: `routes.yaml defines how incoming requests are routed in Cloud.

Why B is correct:
- Maps domains to application upstream
- Configures redirects (www to non-www, HTTP to HTTPS)
- Supports multiple domains per environment
- SSI (Server Side Includes) configuration
- Cache configuration per route

Why others are incorrect:
- A: Admin settings stored in DB, not routing
- C: DNS points to Cloud, routes.yaml handles routing
- D: No .htaccess in Cloud (nginx-based)`,
            codeExample: `# routes.yaml

# Primary domain with HTTPS redirect
"https://{default}/":
    type: upstream
    upstream: "mymagento:http"
    cache:
        enabled: true
        default_ttl: 300

# Redirect www to non-www
"https://www.{default}/":
    type: redirect
    to: "https://{default}/"

# Multi-store routing
"https://store-b.{default}/":
    type: upstream
    upstream: "mymagento:http"
    id: "store-b"
    cache:
        enabled: true

# Admin with separate caching rules
"https://{default}/admin":
    type: upstream
    upstream: "mymagento:http"
    cache:
        enabled: false  # Don't cache admin

# {default} resolves to:
# - master branch: your-project.ent.magento.cloud
# - staging: staging-xxx.ent.magento.cloud
# - Production: your-domain.com`
          },
          {
            id: 92,
            category: "Adobe Commerce Cloud",
            difficulty: "Medium",
            question: "How are services like MySQL, Redis, and Elasticsearch defined in Adobe Commerce Cloud?",
            options: [
              { id: "A", text: "Installed manually on the server" },
              { id: "B", text: "In services.yaml with service type and version" },
              { id: "C", text: "In docker-compose.yml" },
              { id: "D", text: "In Magento's app/etc/env.php" }
            ],
            correctAnswers: ["B"],
            explanation: `services.yaml declares external services for your Cloud environment.

Why B is correct:
- Declares service type and version
- Cloud platform provisions services automatically
- Relationships in .magento.app.yaml connect app to services
- Supports MySQL, Redis, Elasticsearch/OpenSearch, RabbitMQ
- Service configuration persisted across deployments

Why others are incorrect:
- A: Cloud manages services, no manual installation
- C: docker-compose is for local development only
- D: env.php is auto-generated from relationships`,
            codeExample: `# services.yaml

mysql:
    type: mysql:10.6
    disk: 5120
    configuration:
        schemas:
            - main
        endpoints:
            mysql:
                default_schema: main
                privileges:
                    main: admin

redis:
    type: redis:7.0

opensearch:
    type: opensearch:2
    disk: 1024
    configuration:
        plugins:
            - analysis-icu
            - analysis-phonetic

rabbitmq:
    type: rabbitmq:3.9
    disk: 512

# .magento.app.yaml relationships
relationships:
    database: "mysql:mysql"
    redis: "redis:redis"
    opensearch: "opensearch:opensearch"
    rabbitmq: "rabbitmq:rabbitmq"

# Relationships auto-generate env.php config`
          },
          {
            id: 93,
            category: "Adobe Commerce Cloud",
            difficulty: "Hard",
            question: "What is the key difference between Build and Deploy phases in Adobe Commerce Cloud?",
            options: [
              { id: "A", text: "Build runs on production, Deploy runs on staging" },
              { id: "B", text: "Build phase has no service access, Deploy phase has full service access" },
              { id: "C", text: "Build is manual, Deploy is automatic" },
              { id: "D", text: "Build runs composer, Deploy runs database migrations" }
            ],
            correctAnswers: ["B"],
            explanation: `Build and Deploy phases have fundamentally different service access.

Why B is correct:
- BUILD Phase:
  - No database, Redis, or other service access
  - Runs composer install, compiles code
  - Generates DI, static content (if configured)
  - Read-only application mount

- DEPLOY Phase:
  - Full access to all services
  - Runs database migrations
  - Imports configuration
  - Warm-up caches
  - Site is in maintenance mode

Why others are incorrect:
- A: Both phases run in same environment
- C: Both are automated on git push
- D: Both can run various commands`,
            codeExample: `# .magento.app.yaml hooks

hooks:
    # BUILD PHASE - No services available!
    build: |
        set -e
        # composer install runs here (no DB needed)
        php ./vendor/bin/ece-tools run scenario/build/generate.xml
        php ./vendor/bin/ece-tools run scenario/build/transfer.xml
        # Static content deployment if configured
        # Cannot access: database, redis, elasticsearch

    # DEPLOY PHASE - Services available
    deploy: |
        php ./vendor/bin/ece-tools run scenario/deploy.xml
        # Database migrations run here
        # Configuration import from config.php
        # Cache flush and warm-up

    # POST-DEPLOY - Site is live
    post_deploy: |
        php ./vendor/bin/ece-tools run scenario/post-deploy.xml
        # Cache warming
        # Log cleanup

# Key insight:
# If SCD needs database (admin locales), must run in deploy
# If SCD can run without DB, better in build (faster deploys)`
          },
          {
            id: 94,
            category: "Adobe Commerce Cloud",
            difficulty: "Medium",
            question: "What do the different SCD_STRATEGY options control in Adobe Commerce Cloud?",
            options: [
              { id: "A", text: "Database connection pooling strategy" },
              { id: "B", text: "How static content is deployed across themes and locales" },
              { id: "C", text: "Cache invalidation approach" },
              { id: "D", text: "JavaScript bundling method" }
            ],
            correctAnswers: ["B"],
            explanation: `SCD_STRATEGY controls static content deployment parallelization and scope.

Why B is correct:
- standard: Deploy all themes/locales in parallel (most resources)
- quick: Deploy themes in parallel, locales sequentially (balanced)
- compact: Deploy locales per theme, share common files (least disk)
- Affects deployment time and disk usage
- Choose based on store complexity

Why others are incorrect:
- A: Database connections configured separately
- C: Cache has its own configuration
- D: JS bundling is separate (RequireJS bundling)`,
            codeExample: `# .magento.env.yaml

stage:
    build:
        SCD_STRATEGY: "compact"  # Options: standard, quick, compact
        SCD_THREADS: 4
        SCD_MATRIX:
            "Magento/backend":
                language:
                    - en_US
            "Magento/luma":
                language:
                    - en_US
                    - de_DE
                    - fr_FR

# Strategy comparison:
# standard:
#   - All combinations in parallel
#   - Fastest but uses most memory
#   - Best for few themes/locales

# quick:
#   - Themes parallel, locales sequential
#   - Good balance
#   - Default strategy

# compact:
#   - Shares static files across locales
#   - Smallest disk footprint
#   - Best for many locales
#   - May be slower

# Monitor SCD time in deploy log:
# Static content deployment time: 45.23s`
          },
          {
            id: 95,
            category: "Adobe Commerce Cloud",
            difficulty: "Hard",
            question: "What are the requirements for achieving zero-downtime deployment in Adobe Commerce Cloud?",
            options: [
              { id: "A", text: "Using only synchronous operations" },
              { id: "B", text: "Separate static content, configuration via config.php, proper SCD strategy" },
              { id: "C", text: "Disabling all caching during deployment" },
              { id: "D", text: "Running deployment only during off-peak hours" }
            ],
            correctAnswers: ["B"],
            explanation: `Zero-downtime deployment requires specific configuration patterns.

Why B is correct:
- SCD during build phase (no service dependency)
- Configuration stored in config.php (not database)
- No database schema changes that lock tables
- Proper cache warmup in post-deploy
- Ideally: Run SCD in build, not deploy phase

Why others are incorrect:
- A: Sync/async irrelevant to deployment downtime
- C: Caching should remain enabled
- D: Timing doesn't affect downtime duration`,
            codeExample: `# Zero-downtime requirements

# 1. SCD in build phase (no DB dependency)
stage:
    global:
        SCD_ON_DEMAND: false  # Generate during build
    build:
        SCD_STRATEGY: "quick"
        SKIP_SCD: false  # Don't skip!

# 2. Configuration via config.php (not admin)
# bin/magento app:config:dump
# Commits scopes, themes, i18n to config.php

# 3. Static content deployment strategy
# Build phase: bin/magento setup:static-content:deploy
# Mounts shared between build and deploy

# 4. No blocking database operations
# Avoid: Large ALTER TABLE during deploy
# Use: Declarative schema with async indexing

# 5. Post-deploy warmup
stage:
    post-deploy:
        WARM_UP_PAGES:
            - "/"
            - "/customer/account/login"

# Verify zero-downtime:
# During deploy, previous container serves traffic
# New container starts only after deploy completes
# Symlink switch is atomic`
          },
          {
            id: 96,
            category: "Adobe Commerce Cloud",
            difficulty: "Medium",
            question: "What is the hierarchy of environment variable precedence in Adobe Commerce Cloud?",
            options: [
              { id: "A", text: "Environment > Project > .magento.env.yaml" },
              { id: "B", text: ".magento.env.yaml > Project > Environment" },
              { id: "C", text: "Project > Environment > .magento.env.yaml" },
              { id: "D", text: "All sources have equal priority" }
            ],
            correctAnswers: ["A"],
            explanation: `Environment variables follow a specific override hierarchy.

Why A is correct:
- Environment-level (highest priority)
- Project-level (applies to all branches)
- .magento.env.yaml (in repository)
- Allows per-environment customization
- Cloud Console or CLI sets env/project vars

Why others are incorrect:
- B, C: Incorrect order
- D: Clear hierarchy exists`,
            codeExample: `# Variable precedence (highest to lowest):

# 1. Environment-level (Cloud Console or CLI)
# Overrides everything for specific environment
magento-cloud variable:set VAR_NAME "value" --level environment

# 2. Project-level (applies to all environments)
# Default for all branches unless overridden
magento-cloud variable:set VAR_NAME "value" --level project

# 3. .magento.env.yaml (in repository)
stage:
    global:
        SCD_ON_DEMAND: true
    deploy:
        REDIS_BACKEND: "Cm_Cache_Backend_Redis"

# Practical example:
# .magento.env.yaml: SCD_THREADS: 4 (default)
# Project variable: SCD_THREADS: 2 (staging/dev)
# Environment variable: SCD_THREADS: 8 (production only)

# Result: Production uses 8, others use 2

# View effective values:
# magento-cloud ssh -e production
# env | grep MAGENTO`
          },
          {
            id: 97,
            category: "Adobe Commerce Cloud",
            difficulty: "Hard",
            question: "How are custom Fastly VCL snippets deployed in Adobe Commerce Cloud?",
            options: [
              { id: "A", text: "Uploaded directly to Fastly dashboard" },
              { id: "B", text: "Through Magento Admin Fastly module configuration with version activation" },
              { id: "C", text: "In .magento.app.yaml vcl section" },
              { id: "D", text: "Via composer package installation" }
            ],
            correctAnswers: ["B"],
            explanation: `Custom VCL snippets are managed through the Magento Fastly module.

Why B is correct:
- Admin > Stores > Configuration > Advanced > System > Fastly
- Upload custom VCL snippets with priority
- Create new service version with changes
- Activate version to apply changes
- Supports edge dictionaries, ACLs, custom conditions

Why others are incorrect:
- A: Magento manages Fastly config, not direct dashboard access
- C: VCL not in .magento.app.yaml
- D: Composer is for PHP packages, not VCL`,
            codeExample: `# VCL Snippet Management

# 1. Access Fastly Configuration
# Admin > Stores > Configuration > Advanced > System > Fastly Configuration

# 2. Create Custom VCL Snippet
# - Click "Custom VCL Snippets"
# - Add snippet with name, type (recv/deliver/fetch), priority, content

# Example: Block specific IPs
sub vcl_recv {
    if (req.http.Fastly-Client-IP ~ blocklist) {
        error 403 "Forbidden";
    }
}

# Example: Custom cache TTL for specific paths
sub vcl_fetch {
    if (bereq.url ~ "^/api/") {
        set beresp.ttl = 60s;  # Cache API for 60 seconds
    }
}

# 3. Deployment process:
# - Create new version (clones active)
# - Add/modify snippets
# - Validate VCL syntax
# - Activate new version (instant, no downtime)

# Priority determines execution order:
# 50 = Normal (default Magento VCL)
# 100 = Custom additions (after defaults)
# 10 = Early execution (before defaults)

# Edge Dictionaries for dynamic data:
# Store IP blocks, redirects, A/B test rules`
          },
          {
            id: 98,
            category: "Adobe Commerce Cloud",
            difficulty: "Medium",
            question: "How is New Relic APM configured for Adobe Commerce Cloud?",
            options: [
              { id: "A", text: "Install New Relic module via composer only" },
              { id: "B", text: "Configure in .magento.app.yaml runtime extensions and environment variables" },
              { id: "C", text: "New Relic is not supported on Cloud" },
              { id: "D", text: "Through Magento Admin panel integration" }
            ],
            correctAnswers: ["B"],
            explanation: `New Relic APM is configured through Cloud configuration files.

Why B is correct:
- New Relic PHP extension enabled in .magento.app.yaml
- License key set as environment variable
- App name configured per environment
- Pro plan includes New Relic by default
- Starter requires license from New Relic

Why others are incorrect:
- A: Extension also needs configuration
- C: New Relic is fully supported
- D: Configuration is in files, not Admin`,
            codeExample: `# .magento.app.yaml
runtime:
    extensions:
        - newrelic

# Set environment variables (Cloud Console or CLI)
# NEW_RELIC_LICENSE_KEY: your-license-key
# NEW_RELIC_APP_NAME: MyStore-Production

# Or in .magento.env.yaml
stage:
    global:
        NEW_RELIC_URL: "https://api.newrelic.com/"

# For detailed transaction naming
# app/etc/env.php (auto-configured)
'newrelic' => [
    'appname' => 'MyStore-Production',
    'license' => 'xxx',
    'enabled' => true
],

# Key New Relic features for Magento:
# - Transaction tracing (slow pages)
# - Error tracking
# - Deployment markers
# - Database query analysis
# - External service monitoring

# Add deployment marker via CLI:
# newrelic-admin record-deploy "Description" --revision=xyz`
          },
          {
            id: 99,
            category: "Adobe Commerce Cloud",
            difficulty: "Medium",
            question: "What is the 'relationships' configuration in .magento.app.yaml and how does it work?",
            options: [
              { id: "A", text: "Defines API connections to external services" },
              { id: "B", text: "Maps service endpoints to environment variables accessible by the application" },
              { id: "C", text: "Configures database table relationships" },
              { id: "D", text: "Sets up microservice communication" }
            ],
            correctAnswers: ["B"],
            explanation: `Relationships connect your application to services defined in services.yaml.

Why B is correct:
- Maps service names to application endpoints
- Generates MAGENTO_CLOUD_RELATIONSHIPS environment variable
- Contains connection info: host, port, user, password
- Used by ece-tools to configure env.php automatically
- Format: relationship_name: "service_name:endpoint"

Why others are incorrect:
- A: For internal Cloud services, not external APIs
- C: DB table relationships in schema files
- D: Not for microservices specifically`,
            codeExample: `# .magento.app.yaml
relationships:
    database: "mysql:mysql"
    redis: "redis:redis"
    opensearch: "opensearch:opensearch"
    rabbitmq: "rabbitmq:rabbitmq"

# These generate MAGENTO_CLOUD_RELATIONSHIPS:
{
    "database": [{
        "host": "mysql.internal",
        "port": 3306,
        "username": "user",
        "password": "pass",
        "path": "main"  // database name
    }],
    "redis": [{
        "host": "redis.internal",
        "port": 6379
    }]
}

# ece-tools uses this to configure env.php:
'db' => [
    'connection' => [
        'default' => [
            'host' => 'mysql.internal',
            'dbname' => 'main',
            'username' => 'user',
            'password' => 'pass'
        ]
    ]
],

# Access in PHP:
$relationships = json_decode(
    base64_decode($_ENV['MAGENTO_CLOUD_RELATIONSHIPS']),
    true
);
$dbHost = $relationships['database'][0]['host'];`
          },
          {
            id: 100,
            category: "Adobe Commerce Cloud",
            difficulty: "Medium",
            question: "What happens in the post-deploy phase and why is it important?",
            options: [
              { id: "A", text: "Database migrations run here" },
              { id: "B", text: "Cache warming and cleanup tasks run while site is live" },
              { id: "C", text: "Static content is generated" },
              { id: "D", text: "Composer dependencies are installed" }
            ],
            correctAnswers: ["B"],
            explanation: `Post-deploy phase runs after the site is live, handling non-critical tasks.

Why B is correct:
- Site is already serving traffic
- Cache warming for critical pages
- Log rotation and cleanup
- Health checks
- Notification webhooks
- Non-blocking operations only

Why others are incorrect:
- A: DB migrations in deploy phase (maintenance mode)
- C: SCD in build or deploy phase
- D: Composer in build phase`,
            codeExample: `# .magento.app.yaml
hooks:
    post_deploy: |
        php ./vendor/bin/ece-tools run scenario/post-deploy.xml

# .magento.env.yaml - Post-deploy configuration
stage:
    post-deploy:
        WARM_UP_PAGES:
            - "index.php"
            - "index.php/customer/account/create"
            - "index.php/customer/account/login"
            - "index.php/catalogsearch/result?q=test"

        WARM_UP_CONCURRENCY: 4  # Parallel requests
        CLEAN_STATIC_FILES: true

        # Notify external services
        WEBHOOKS:
            newrelic: true
            slack:
                hook_url: "https://hooks.slack.com/..."
                message: "Deployment complete"

# What ece-tools does in post-deploy:
# 1. Warm configured pages (populates FPC)
# 2. Clean old static files (optional)
# 3. Record deployment in New Relic
# 4. Run health checks
# 5. Send notifications

# Custom post-deploy tasks:
hooks:
    post_deploy: |
        php ./vendor/bin/ece-tools run scenario/post-deploy.xml
        # Custom: Notify monitoring system
        curl -X POST $MONITORING_URL -d "status=deployed"`
          },
          {
            id: 101,
            category: "Caching",
            difficulty: "Hard",
            question: "How can Varnish VCL be customized to implement custom caching rules for specific URLs?",
            options: [
              { id: "A", text: "Edit the core varnish.vcl file directly" },
              { id: "B", text: "Use vcl_recv and vcl_backend_response functions in custom VCL includes" },
              { id: "C", text: "Configure caching in Magento Admin only" },
              { id: "D", text: "Modify cache tags in PHP code" }
            ],
            correctAnswers: ["B"],
            explanation: `Custom VCL uses specific functions to control cache behavior at different stages.

Why B is correct:
- vcl_recv: Process incoming requests (normalize, decide cacheability)
- vcl_backend_response (formerly vcl_fetch): Modify backend response before caching
- vcl_deliver: Modify response before sending to client
- Include custom VCL via Magento's Varnish module
- Maintains upgradeability

Why others are incorrect:
- A: Direct editing breaks upgrades
- C: Admin config limited, VCL more powerful
- D: Cache tags for invalidation, not routing rules`,
            codeExample: `# Custom VCL snippet for Magento

# vcl_recv - Incoming request handling
sub vcl_recv {
    # Custom TTL for specific paths
    if (req.url ~ "^/api/v1/products") {
        set req.http.X-Custom-TTL = "120";  # 2 minutes
    }

    # Force cache bypass for certain cookies
    if (req.http.Cookie ~ "custom_nocache=1") {
        return (pass);
    }

    # Normalize query parameters for better cache hit rate
    set req.url = std.querysort(req.url);
}

# vcl_backend_response - Modify response before caching
sub vcl_backend_response {
    # Apply custom TTL from request
    if (bereq.http.X-Custom-TTL) {
        set beresp.ttl = std.duration(bereq.http.X-Custom-TTL + "s", 60s);
    }

    # Cache specific content types longer
    if (beresp.http.Content-Type ~ "image/") {
        set beresp.ttl = 1d;  # Cache images for 1 day
    }

    # Grace period for stale content during revalidation
    set beresp.grace = 1h;
}

# vcl_deliver - Modify final response
sub vcl_deliver {
    # Debug headers (remove in production)
    if (resp.http.X-Debug) {
        set resp.http.X-Cache-Hits = obj.hits;
    }
}`
          },
          {
            id: 102,
            category: "Caching",
            difficulty: "Medium",
            question: "How should Redis be configured for different caching purposes in Magento 2?",
            options: [
              { id: "A", text: "Use a single Redis instance for all cache types" },
              { id: "B", text: "Separate databases or instances for cache, session, and FPC" },
              { id: "C", text: "Redis is only suitable for sessions" },
              { id: "D", text: "Use file-based caching instead of Redis" }
            ],
            correctAnswers: ["B"],
            explanation: `Separating Redis usage improves performance and manageability.

Why B is correct:
- Different eviction policies per use case
- Sessions: noeviction or volatile-lru
- Cache: allkeys-lru (can evict any key)
- FPC: allkeys-lru (large values)
- Easier monitoring and scaling
- Prevents cache pollution affecting sessions

Why others are incorrect:
- A: Single instance creates contention
- C: Redis excellent for all cache types
- D: File caching much slower`,
            codeExample: `// app/etc/env.php

// Default cache backend (Redis DB 0)
'cache' => [
    'frontend' => [
        'default' => [
            'backend' => 'Magento\\Framework\\Cache\\Backend\\Redis',
            'backend_options' => [
                'server' => 'redis-cache',
                'port' => '6379',
                'database' => '0',
                'compress_data' => '1',
                'compression_lib' => 'gzip'
            ]
        ],
        // Full Page Cache (Redis DB 1)
        'page_cache' => [
            'backend' => 'Magento\\Framework\\Cache\\Backend\\Redis',
            'backend_options' => [
                'server' => 'redis-fpc',
                'port' => '6379',
                'database' => '1',
                'compress_data' => '1'
            ]
        ]
    ]
],

// Session storage (Redis DB 2)
'session' => [
    'save' => 'redis',
    'redis' => [
        'host' => 'redis-session',
        'port' => '6379',
        'database' => '2',
        'disable_locking' => '1',
        'max_concurrency' => '6',
        'bot_lifetime' => '7200'
    ]
],

// Redis config recommendations:
// cache/fpc: maxmemory-policy allkeys-lru
// session: maxmemory-policy volatile-lru or noeviction`
          },
          {
            id: 103,
            category: "Caching",
            difficulty: "Hard",
            question: "How does Magento implement hole punching for dynamic content in full page cache?",
            options: [
              { id: "A", text: "Ajax calls after page load for all dynamic content" },
              { id: "B", text: "Edge Side Includes (ESI) via Varnish and private-content-version cookie" },
              { id: "C", text: "Disabling FPC for pages with dynamic content" },
              { id: "D", text: "Server-side caching only, no client involvement" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento uses ESI for public content and private content version for customer-specific data.

Why B is correct:
- ESI: Varnish fetches dynamic fragments separately
- private-content-version: Cookie triggers JS fetch
- Customer sections loaded via customer/section/load
- Combines cached page with fresh dynamic parts
- Optimal balance of caching and personalization

Why others are incorrect:
- A: Not all content via Ajax, ESI for some
- C: FPC remains enabled, just with holes
- D: Client-side (cookies/JS) integral to solution`,
            codeExample: `// Hole Punching Mechanisms

// 1. ESI (Edge Side Includes) - Server-side
// Layout XML with ttl for ESI-cacheable block
<block class="Vendor\\Module\\Block\\Dynamic" name="dynamic.block">
    <arguments>
        <argument name="ttl" xsi:type="number">3600</argument>
    </arguments>
</block>

// Generated ESI tag in HTML:
// <esi:include src="/page_cache/block/esi/blocks/[encoded]" />

// 2. Private Content - Client-side JavaScript
// sections.xml - defines customer-specific sections
<config>
    <action name="checkout/cart/add">
        <section name="cart"/>
        <section name="messages"/>
    </action>
</config>

// private-content-version cookie changes on action
// customer-data.js fetches: /customer/section/load?sections=cart,messages

// 3. Block prevents caching entire page
<!-- Layout: page NOT cached at all -->
<block cacheable="false" .../>

// Best practices:
// - Use sections for customer data (cart, wishlist)
// - ESI for shared dynamic content (stock status)
// - Avoid cacheable="false" when possible`
          },
          {
            id: 104,
            category: "Caching",
            difficulty: "Medium",
            question: "What interface must a block implement to support cache tags for proper invalidation?",
            options: [
              { id: "A", text: "Magento\\Framework\\Cache\\CacheInterface" },
              { id: "B", text: "Magento\\Framework\\DataObject\\IdentityInterface" },
              { id: "C", text: "Magento\\Framework\\View\\Element\\BlockInterface" },
              { id: "D", text: "Magento\\Framework\\Cache\\TagInterface" }
            ],
            correctAnswers: ["B"],
            explanation: `IdentityInterface provides cache tags for automatic invalidation.

Why B is correct:
- getIdentities() returns array of cache tags
- Tags format: entity_type_id (e.g., 'cat_p_123')
- When entity changes, tags invalidate related cache
- Framework collects tags from all blocks on page
- Varnish/FPC uses tags for targeted invalidation

Why others are incorrect:
- A: CacheInterface is for cache backends
- C: BlockInterface defines block rendering
- D: No such interface`,
            codeExample: `// Block implementing IdentityInterface
namespace Vendor\\Module\\Block;

use Magento\\Framework\\DataObject\\IdentityInterface;
use Magento\\Framework\\View\\Element\\Template;

class ProductList extends Template implements IdentityInterface
{
    public function getIdentities()
    {
        $identities = [];

        foreach ($this->getProducts() as $product) {
            // Add product-specific cache tags
            $identities[] = \\Magento\\Catalog\\Model\\Product::CACHE_TAG . '_' . $product->getId();
            // e.g., 'cat_p_123'
        }

        // Add category tag
        $identities[] = \\Magento\\Catalog\\Model\\Category::CACHE_TAG . '_' . $this->getCategoryId();
        // e.g., 'cat_c_456'

        return $identities;
    }
}

// Model also implements IdentityInterface
class Product implements IdentityInterface
{
    const CACHE_TAG = 'cat_p';

    public function getIdentities()
    {
        return [self::CACHE_TAG . '_' . $this->getId()];
    }
}

// When product 123 is saved:
// Cache entries with tag 'cat_p_123' are invalidated
// Varnish receives: PURGE with X-Magento-Tags-Pattern: cat_p_123`
          },
          {
            id: 105,
            category: "Caching",
            difficulty: "Medium",
            question: "What happens when a block has cacheable='false' attribute in layout XML?",
            options: [
              { id: "A", text: "Only that block is not cached" },
              { id: "B", text: "The entire page becomes non-cacheable by full page cache" },
              { id: "C", text: "Block uses a separate cache storage" },
              { id: "D", text: "Block content is loaded via Ajax" }
            ],
            correctAnswers: ["B"],
            explanation: `cacheable='false' disables FPC for the entire page containing the block.

Why B is correct:
- ANY cacheable='false' block prevents page FPC
- Entire page served dynamically each request
- Common performance mistake
- Should use private content or ESI instead
- Check layout with: bin/magento dev:template-hints:enable

Why others are incorrect:
- A: Affects entire page, not just block
- C: No separate cache storage mechanism
- D: Doesn't trigger Ajax loading`,
            codeExample: `<!-- BAD: Disables FPC for entire page -->
<block class="Vendor\\Module\\Block\\CustomerInfo"
       name="customer.info"
       template="customer-info.phtml"
       cacheable="false"/>

<!-- Result: Page never cached, always dynamic -->
<!-- Response headers: X-Magento-Cache-Debug: MISS (always) -->

<!-- BETTER: Use private content sections -->
<!-- 1. Register section in sections.xml -->
<config>
    <action name="customer/account/loginPost">
        <section name="customer"/>
    </action>
</config>

<!-- 2. Create section data source -->
<!-- Customer section loaded via JS from /customer/section/load -->

<!-- 3. In template, use Knockout.js -->
<span data-bind="text: customer().fullname">Guest</span>

<!-- BETTER for shared dynamic: Use ESI -->
<block class="Vendor\\Module\\Block\\StockStatus"
       name="stock.status"
       template="stock.phtml">
    <arguments>
        <!-- TTL enables ESI in Varnish -->
        <argument name="ttl" xsi:type="number">60</argument>
    </arguments>
</block>

<!-- Check for problematic blocks: -->
<!-- grep -r "cacheable=\"false\"" app/design/ vendor/ -->`
          },
          {
            id: 106,
            category: "Performance",
            difficulty: "Hard",
            question: "How can you identify and fix N+1 query problems in Magento 2?",
            options: [
              { id: "A", text: "N+1 problems don't occur in Magento due to its ORM" },
              { id: "B", text: "Use profiler to identify repeated queries, then use eager loading with collections" },
              { id: "C", text: "Disable database logging to improve performance" },
              { id: "D", text: "Increase database connection pool size" }
            ],
            correctAnswers: ["B"],
            explanation: `N+1 problems are common and identifiable through profiling.

Why B is correct:
- Enable SQL profiler: dev/debug/profiler (DB profiler)
- Look for repeated queries with different IDs
- Solution: Load related data in collections
- Use addAttributeToSelect() for EAV
- Use joins for related data

Why others are incorrect:
- A: N+1 very common in Magento, especially EAV
- C: Logging doesn't cause N+1
- D: Connection pool doesn't fix query patterns`,
            codeExample: `// N+1 Problem Example
foreach ($products as $product) {
    // Each iteration = new query!
    $category = $product->getCategoryCollection()->getFirstItem();
    // Also bad:
    $stockItem = $this->stockRegistry->getStockItem($product->getId());
}
// 100 products = 200+ queries!

// Solution 1: Eager load with collection
$collection = $this->productCollectionFactory->create();
$collection
    ->addAttributeToSelect(['name', 'price', 'status'])
    ->addCategoryIds()  // Loads category IDs in one query
    ->joinField(
        'qty',
        'cataloginventory_stock_item',
        'qty',
        'product_id=entity_id',
        null,
        'left'
    );

// Solution 2: Batch load related data
$productIds = $collection->getAllIds();
$stockItems = $this->stockRegistry->getStockItemsBySku(
    $collection->getColumnValues('sku')
);

// Solution 3: Use ResourceConnection for complex queries
$connection = $this->resourceConnection->getConnection();
$select = $connection->select()
    ->from(['e' => 'catalog_product_entity'])
    ->joinLeft(['s' => 'cataloginventory_stock_item'], 'e.entity_id = s.product_id')
    ->where('e.entity_id IN (?)', $productIds);

// Profiling: bin/magento dev:profiler:enable
// Or: MAGE_PROFILER=1 in env.php`
          },
          {
            id: 107,
            category: "Performance",
            difficulty: "Medium",
            question: "What is the purpose of indexer dimensions and how do they improve performance?",
            options: [
              { id: "A", text: "Dimensions limit index size by removing old data" },
              { id: "B", text: "Dimensions enable partial indexing by scope (store, customer group)" },
              { id: "C", text: "Dimensions create backup copies of indexes" },
              { id: "D", text: "Dimensions control index storage location" }
            ],
            correctAnswers: ["B"],
            explanation: `Indexer dimensions allow scoped, partial reindexing for better performance.

Why B is correct:
- Dimensions: Store, Customer Group, Website
- Partial reindex: Only affected scope rebuilt
- Example: Price change in Store 1 only reindexes Store 1
- Reduces reindex time significantly
- Configured in indexer.xml

Why others are incorrect:
- A: Dimensions about scope, not data retention
- C: Not backup mechanism
- D: Storage separate from dimensions`,
            codeExample: `<!-- indexer.xml - Dimensional indexer -->
<indexer id="catalog_product_price"
         class="Magento\\Catalog\\Model\\Indexer\\Product\\Price">
    <dimensions>
        <dimension name="website_id" iterator="\\Magento\\Store\\Model\\Indexer\\WebsiteIterator"/>
        <dimension name="customer_group_id" iterator="\\Magento\\Customer\\Model\\Indexer\\CustomerGroupIterator"/>
    </dimensions>
</indexer>

// How dimensions work:
// 1. Full reindex creates index per dimension combination
//    website_1_customer_group_0, website_1_customer_group_1, etc.

// 2. Partial reindex (e.g., price rule change for website 2)
$indexer->executeByDimensions(
    ['website_id' => 2],  // Only reindex website 2
    $productIds
);

// 3. Query uses appropriate dimension
$select->where('website_id = ?', $websiteId)
       ->where('customer_group_id = ?', $customerGroupId);

// Configuration
bin/magento indexer:set-dimensions-mode catalog_product_price website
// Options: none, website, customer_group, website_and_customer_group

// Check current mode
bin/magento indexer:show-dimensions-mode`
          },
          {
            id: 108,
            category: "Performance",
            difficulty: "Medium",
            question: "What static content optimization strategies are available in Magento 2?",
            options: [
              { id: "A", text: "Minification, bundling, and merging through configuration" },
              { id: "B", text: "Only server-side compression is available" },
              { id: "C", text: "CDN is the only optimization option" },
              { id: "D", text: "Static content cannot be optimized" }
            ],
            correctAnswers: ["A"],
            explanation: `Magento offers multiple static content optimization options.

Why A is correct:
- CSS/JS minification: Removes whitespace, comments
- JS bundling: Combines files (requires configuration)
- CSS/JS merging: Single file per type
- Deferred JS loading: async/defer attributes
- Configured in Admin or config.php

Why others are incorrect:
- B: Multiple optimization methods available
- C: CDN complementary, not only option
- D: Extensive optimization capabilities`,
            codeExample: `// Admin: Stores > Configuration > Advanced > Developer

// CSS Settings
'css' => [
    'minify_files' => '1',       // Remove whitespace
    'merge_css_files' => '1',    // Combine into one file
    'use_css_critical_path' => '1' // Critical CSS inline
],

// JavaScript Settings
'js' => [
    'minify_files' => '1',
    'enable_js_bundling' => '1',  // Combine JS modules
    'merge_files' => '1',
    'move_script_to_bottom' => '1' // Defer JS loading
],

// Template Settings
'template' => [
    'minify_html' => '1'
],

// Production mode automatically enables:
bin/magento deploy:mode:set production

// Advanced JS bundling (requirejs-config.js)
var config = {
    bundles: {
        'bundles/common': [
            'jquery',
            'jquery/ui',
            'mage/translate'
        ],
        'bundles/cart': [
            'Magento_Checkout/js/model/cart/cache'
        ]
    }
};

// Critical CSS: Load above-fold CSS inline
// Configure paths in: dev/css/use_css_critical_path`
          },
          {
            id: 109,
            category: "Performance",
            difficulty: "Medium",
            question: "How should images be optimized for performance in Magento 2?",
            options: [
              { id: "A", text: "Store original images only, Magento cannot resize" },
              { id: "B", text: "Use image resize on upload, WebP format, and lazy loading" },
              { id: "C", text: "Disable all product images" },
              { id: "D", text: "Use only external image URLs" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento provides comprehensive image optimization capabilities.

Why B is correct:
- Automatic resize during import/upload
- WebP format support (better compression)
- Lazy loading via JavaScript
- Image cache for resized variants
- Quality settings configurable

Why others are incorrect:
- A: Magento has extensive image processing
- C: Images critical for ecommerce
- D: Internal processing preferred for optimization`,
            codeExample: `// Image optimization configuration

// 1. View.xml - Define image sizes per context
<media>
    <images module="Magento_Catalog">
        <image id="category_page_list" type="small_image">
            <width>240</width>
            <height>300</height>
        </image>
        <image id="product_page_image_large" type="image">
            <width>700</width>
            <height>700</height>
        </image>
    </images>
</media>

// 2. WebP conversion (Magento 2.4+)
// Stores > Configuration > Advanced > Developer > Image Processing
// 'webp' => 1

// 3. Lazy loading in templates
<img src="placeholder.jpg"
     data-src="<?= $image->getUrl() ?>"
     class="lazyload" />

// 4. Resize during import
// bin/magento catalog:images:resize

// 5. Image quality settings (env.php)
'image' => [
    'default_quality' => 80,
    'webp_quality' => 75
],

// 6. CDN for images (Stores > Configuration > Web > Base URLs)
// Media Base URL: https://cdn.example.com/media/

// Clear image cache:
// bin/magento catalog:images:resize -f
// rm -rf pub/media/catalog/product/cache/`
          },
          {
            id: 110,
            category: "Performance",
            difficulty: "Medium",
            question: "What is the Proxy pattern used for in Magento 2 and when should it be applied?",
            options: [
              { id: "A", text: "For caching database queries" },
              { id: "B", text: "For lazy loading expensive dependencies that aren't always used" },
              { id: "C", text: "For routing requests to different servers" },
              { id: "D", text: "For encrypting sensitive data" }
            ],
            correctAnswers: ["B"],
            explanation: `Proxy provides lazy instantiation for performance optimization.

Why B is correct:
- Defers object creation until first use
- Auto-generated by Magento (ClassName\\Proxy)
- Reduces constructor overhead
- Ideal for conditionally-used heavy dependencies
- Implements same interface as wrapped class

Why others are incorrect:
- A: Query caching is separate mechanism
- C: Routing handled by webserver/framework
- D: Encryption is separate concern`,
            codeExample: `// Without Proxy - Heavy dependency always instantiated
class OrderService
{
    public function __construct(
        private HeavyReportGenerator $reportGenerator // ALWAYS created
    ) {}

    public function processOrder($order) {
        // reportGenerator created even if never used
        return $this->orderRepository->save($order);
    }

    public function generateReport($order) {
        // Only here is reportGenerator actually needed
        return $this->reportGenerator->generate($order);
    }
}

// With Proxy - Lazy instantiation
<!-- di.xml -->
<type name="Vendor\\Module\\Service\\OrderService">
    <arguments>
        <argument name="reportGenerator" xsi:type="object">
            Vendor\\Module\\Service\\HeavyReportGenerator\\Proxy
        </argument>
    </arguments>
</type>

// Generated Proxy class (simplified)
class HeavyReportGenerator\\Proxy extends HeavyReportGenerator
{
    private $subject;
    private $objectManager;

    public function generate($order) {
        // First call: creates real instance
        return $this->getSubject()->generate($order);
    }

    private function getSubject() {
        if (!$this->subject) {
            $this->subject = $this->objectManager->get(HeavyReportGenerator::class);
        }
        return $this->subject;
    }
}

// Best for:
// - Heavy services used conditionally
// - Circular dependency resolution
// - CLI commands with expensive deps`
          },
          {
            id: 111,
            category: "Security",
            difficulty: "Hard",
            question: "How is Content Security Policy (CSP) implemented in Magento 2?",
            options: [
              { id: "A", text: "Through .htaccess configuration only" },
              { id: "B", text: "Through csp_whitelist.xml to define allowed sources per directive" },
              { id: "C", text: "CSP is not supported in Magento" },
              { id: "D", text: "Through JavaScript runtime checks" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento implements CSP through a dedicated XML configuration system.

Why B is correct:
- csp_whitelist.xml per module defines allowed sources
- Supports all CSP directives (script-src, style-src, etc.)
- Report-only mode for testing
- Nonce generation for inline scripts
- Admin and storefront separate policies

Why others are incorrect:
- A: Managed by Magento, not webserver
- C: Full CSP support since 2.3.5
- D: Server-side headers, not JS`,
            codeExample: `<!-- etc/csp_whitelist.xml -->
<csp_whitelist>
    <policies>
        <policy id="script-src">
            <values>
                <value id="google-analytics" type="host">
                    www.google-analytics.com
                </value>
                <value id="google-tag" type="host">
                    www.googletagmanager.com
                </value>
            </values>
        </policy>

        <policy id="style-src">
            <values>
                <value id="google-fonts" type="host">
                    fonts.googleapis.com
                </value>
            </values>
        </policy>

        <policy id="font-src">
            <values>
                <value id="google-fonts-static" type="host">
                    fonts.gstatic.com
                </value>
            </values>
        </policy>

        <policy id="img-src">
            <values>
                <value id="cdn" type="host">
                    cdn.example.com
                </value>
            </values>
        </policy>
    </policies>
</csp_whitelist>

<!-- Admin config: Stores > Configuration > Security > CSP -->
<!-- Mode: report-only (testing) or restrict (enforcing) -->

<!-- Inline scripts with nonce -->
<?php $cspNonceProvider = $block->getCspNonceProvider(); ?>
<scr` + `ipt nonce="<?= $cspNonceProvider->generateNonce() ?>">
    // Inline script with valid nonce
</scr` + `ipt>`
          },
          {
            id: 112,
            category: "Security",
            difficulty: "Medium",
            question: "How is two-factor authentication (2FA) implemented in Magento 2 admin?",
            options: [
              { id: "A", text: "Through third-party extension only" },
              { id: "B", text: "Built-in module supporting Google Authenticator, Duo, Authy, and U2F" },
              { id: "C", text: "SMS-based verification only" },
              { id: "D", text: "2FA is not available for Magento admin" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento includes comprehensive 2FA support out of the box.

Why B is correct:
- Magento_TwoFactorAuth module (core)
- Providers: Google Authenticator, Duo Security, Authy, U2F
- Required for all admin users
- Emergency reset via CLI
- Can be disabled (not recommended) or customized

Why others are incorrect:
- A: Built into core since 2.4.0
- C: Multiple methods, not just SMS
- D: Full 2FA support included`,
            codeExample: `// 2FA is required by default in Magento 2.4+

// Disable 2FA (development only!)
bin/magento module:disable Magento_TwoFactorAuth

// Reset 2FA for specific user
bin/magento security:tfa:reset admin_username google

// Configure providers in Admin
// Stores > Configuration > Security > 2FA

// Force specific provider
// Stores > Configuration > Security > 2FA
// General > Force Providers = google

// Programmatic 2FA check
class AdminController
{
    public function execute()
    {
        if (!$this->tfaSession->isGranted()) {
            return $this->resultRedirectFactory->create()
                ->setPath('tfa/tfa/index');
        }
        // Proceed with admin action
    }
}

// Custom 2FA provider implementation
class CustomProvider implements ProviderInterface
{
    public function getCode(): string { return 'custom'; }
    public function getName(): string { return 'Custom 2FA'; }
    public function isEnabled(): bool { return true; }
    public function verify(UserInterface $user, DataObject $request): bool
    {
        // Verification logic
    }
}`
          },
          {
            id: 113,
            category: "Security",
            difficulty: "Medium",
            question: "What is the correct way to prevent SQL injection in custom Magento code?",
            options: [
              { id: "A", text: "Escape user input with htmlspecialchars()" },
              { id: "B", text: "Use prepared statements and parameter binding through Magento's DB abstraction" },
              { id: "C", text: "Validate input length only" },
              { id: "D", text: "Use base64 encoding for all inputs" }
            ],
            correctAnswers: ["B"],
            explanation: `Prepared statements with parameter binding prevent SQL injection.

Why B is correct:
- ResourceConnection provides safe query building
- Parameters automatically escaped/quoted
- Use bind parameters, not string concatenation
- Zend_Db_Select handles quoting
- Collections use safe methods by default

Why others are incorrect:
- A: htmlspecialchars is for XSS, not SQL injection
- C: Length validation doesn't prevent injection
- D: Encoding doesn't sanitize SQL`,
            codeExample: `// WRONG - SQL Injection vulnerable
$userId = $request->getParam('user_id');
$sql = "SELECT * FROM users WHERE id = " . $userId;  // DANGER!

// CORRECT - Using parameter binding
$connection = $this->resourceConnection->getConnection();

// Method 1: Named parameters
$select = $connection->select()
    ->from('users')
    ->where('id = :user_id');
$result = $connection->fetchRow($select, ['user_id' => $userId]);

// Method 2: Positional parameters
$select = $connection->select()
    ->from('users')
    ->where('id = ?', $userId);

// Method 3: quoteInto for complex cases
$sql = $connection->quoteInto(
    'SELECT * FROM users WHERE status = ? AND created > ?',
    ['active', '2024-01-01']
);

// Method 4: Using collections (safest)
$collection = $this->userCollectionFactory->create();
$collection->addFieldToFilter('id', ['eq' => $userId]);

// For IN clauses
$ids = [1, 2, 3];  // Even if from user input
$select->where('id IN (?)', $ids);  // Properly escaped

// NEVER do this:
$ids = implode(',', $userInput);  // Could contain SQL injection!
$select->where('id IN (' . $ids . ')');  // VULNERABLE!`
          },
          {
            id: 114,
            category: "Security",
            difficulty: "Medium",
            question: "How should output be escaped to prevent XSS (Cross-Site Scripting) in Magento templates?",
            options: [
              { id: "A", text: "Use strip_tags() on all output" },
              { id: "B", text: "Use $escaper methods appropriate to the context (HTML, URL, JS, CSS)" },
              { id: "C", text: "Only escape user input, not database content" },
              { id: "D", text: "Use base64 encoding for display" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento's Escaper class provides context-specific escaping methods.

Why B is correct:
- $escaper available in all templates
- escapeHtml(): HTML content
- escapeHtmlAttr(): HTML attributes
- escapeUrl(): URL parameters
- escapeJs(): JavaScript strings
- escapeCss(): CSS values
- Context matters for proper escaping

Why others are incorrect:
- A: strip_tags removes content, doesn't escape
- C: ALL output should be escaped
- D: Encoding not for display purposes`,
            codeExample: `<?php
// In Magento 2 templates, $escaper is available
// Block also has $block->escapeHtml() methods

// HTML content escaping
<p><?= $escaper->escapeHtml($product->getName()) ?></p>

// HTML attribute escaping (more restrictive)
<div title="<?= $escaper->escapeHtmlAttr($product->getDescription()) ?>">

// URL escaping
<a href="<?= $escaper->escapeUrl($block->getUrl('catalog/product/view', ['id' => $id])) ?>">

// JavaScript escaping
<scr` + `ipt>
    var productName = "<?= $escaper->escapeJs($product->getName()) ?>";
    var config = <?= /* @noEscape */ $block->getJsonConfig() ?>; // JSON already safe
</scr` + `ipt>

// CSS escaping
<div style="background-color: <?= $escaper->escapeCss($color) ?>">

// Allow specific HTML tags
<?= $escaper->escapeHtml($content, ['p', 'br', 'strong', 'em']) ?>

// WRONG - XSS vulnerable
<p><?= $product->getName() ?></p>  // No escaping!
<a href="<?= $untrustedUrl ?>">    // Could be javascript:

// @noEscape annotation for already-safe content (use sparingly)
<?= /* @noEscape */ $block->getChildHtml('content') ?>
?>`
          },
          {
            id: 115,
            category: "Security",
            difficulty: "Medium",
            question: "How does Magento protect against CSRF (Cross-Site Request Forgery) attacks?",
            options: [
              { id: "A", text: "Through IP address validation only" },
              { id: "B", text: "Using form_key token validation for state-changing requests" },
              { id: "C", text: "HTTPS encryption alone prevents CSRF" },
              { id: "D", text: "CSRF protection is not implemented" }
            ],
            correctAnswers: ["B"],
            explanation: `Magento uses form_key tokens to validate legitimate requests.

Why B is correct:
- form_key: Unique token per session
- Required for POST/PUT/DELETE requests
- Validated automatically by framework
- Stored in session, sent with forms
- AJAX requests include form_key header

Why others are incorrect:
- A: IP can be spoofed, not reliable
- C: HTTPS encrypts, doesn't verify intent
- D: Full CSRF protection implemented`,
            codeExample: `<!-- Form with CSRF protection (automatic in Magento forms) -->
<form action="<?= $block->getUrl('module/action/save') ?>" method="post">
    <!-- Form key automatically added by Magento form blocks -->
    <?= $block->getBlockHtml('formkey') ?>
    <!-- Or manually: -->
    <input type="hidden" name="form_key" value="<?= $block->getFormKey() ?>"/>

    <input type="text" name="data"/>
    <button type="submit">Save</button>
</form>

// Controller validation (automatic with parent classes)
class SaveController extends Action
{
    // CsrfAwareActionInterface for custom validation
    public function execute()
    {
        // Form key validated automatically before reaching here
        // If invalid: 403 error returned
    }
}

// AJAX with form_key
require(['jquery', 'mage/url'], function($, urlBuilder) {
    $.ajax({
        url: urlBuilder.build('module/action/save'),
        type: 'POST',
        data: {
            form_key: $.mage.cookies.get('form_key'),
            custom_data: 'value'
        }
    });
});

// Skip CSRF for specific actions (webhooks, APIs)
class WebhookController extends Action implements CsrfAwareActionInterface
{
    public function createCsrfValidationException(RequestInterface $request): ?InvalidRequestException
    {
        return null;  // Skip CSRF
    }

    public function validateForCsrf(RequestInterface $request): ?bool
    {
        return true;  // Always valid
    }
}`
          },
          {
            id: 116,
            category: "Security",
            difficulty: "Medium",
            question: "What security measures should be implemented for the Magento admin panel?",
            options: [
              { id: "A", text: "No special measures needed beyond default configuration" },
              { id: "B", text: "Custom admin URL, IP restrictions, session lifetime, 2FA, and login attempt limits" },
              { id: "C", text: "Only password complexity requirements" },
              { id: "D", text: "Public access is safe with strong passwords" }
            ],
            correctAnswers: ["B"],
            explanation: `Multiple layers of security should protect the admin panel.

Why B is correct:
- Custom admin URL: Obscures admin location
- IP whitelist: Restrict access to known IPs
- Session lifetime: Limit session duration
- 2FA: Second authentication factor
- Lockout: Prevent brute force attacks
- CAPTCHA: Additional bot protection

Why others are incorrect:
- A: Default config insufficient
- C: Passwords alone not enough
- D: Public access risky`,
            codeExample: `// 1. Custom Admin URL (env.php or during install)
'backend' => [
    'frontName' => 'secret-admin-path'  // Not 'admin'!
],

// 2. IP Restriction (in Admin or .htaccess)
// Stores > Configuration > Advanced > Admin > Security
// Admin Session Lifetime: 900 (15 minutes)

// nginx.conf example
location /secret-admin-path {
    allow 192.168.1.0/24;
    allow 10.0.0.1;
    deny all;

    try_files $uri $uri/ /index.php?$args;
}

// 3. Session Security (env.php)
'session' => [
    'save' => 'redis',
    'redis' => [
        'disable_locking' => 1,
        'max_concurrency' => 6,
        // Session timeout
    ]
],

// 4. Login security (Admin configuration)
// Stores > Configuration > Advanced > Admin > Security
// - Add Secret Key to URLs: Yes
// - Login is Case Sensitive: Yes
// - Admin Session Lifetime: 900
// - Max Login Failures: 6
// - Lockout Time: 30

// 5. Force HTTPS for admin
// Stores > Configuration > General > Web > Base URLs (Secure)
// Use Secure URLs in Admin: Yes

// 6. Captcha (Admin configuration)
// Stores > Configuration > Customers > CAPTCHA
// Enable CAPTCHA in Admin: Yes
// Forms: Login, Forgot Password`
          },
          {
            id: 117,
            category: "Testing",
            difficulty: "Medium",
            question: "What is the difference between integration tests and unit tests in Magento 2?",
            options: [
              { id: "A", text: "Integration tests are faster than unit tests" },
              { id: "B", text: "Unit tests mock dependencies; integration tests use real Magento framework and database" },
              { id: "C", text: "Unit tests require database; integration tests don't" },
              { id: "D", text: "There is no difference in Magento" }
            ],
            correctAnswers: ["B"],
            explanation: `Unit and integration tests have fundamentally different approaches.

Why B is correct:
- Unit tests: Isolated, mock all dependencies
- Integration tests: Real framework, database, DI
- Unit: Fast, focused on single class
- Integration: Slower, tests component interaction
- Both important for comprehensive coverage

Why others are incorrect:
- A: Unit tests are faster (no framework)
- C: Reversed - integration needs DB
- D: Significant architectural differences`,
            codeExample: `// Unit Test - Isolated, mocked dependencies
namespace Vendor\\Module\\Test\\Unit\\Model;

class ProductServiceTest extends \\PHPUnit\\Framework\\TestCase
{
    private $productRepository;
    private $productService;

    protected function setUp(): void
    {
        // Mock dependencies
        $this->productRepository = $this->createMock(ProductRepositoryInterface::class);
        $this->productService = new ProductService($this->productRepository);
    }

    public function testGetProduct(): void
    {
        $mockProduct = $this->createMock(ProductInterface::class);
        $mockProduct->method('getSku')->willReturn('SKU123');

        $this->productRepository->method('get')->willReturn($mockProduct);

        $result = $this->productService->getProduct('SKU123');
        $this->assertEquals('SKU123', $result->getSku());
    }
}
// Run: vendor/bin/phpunit -c dev/tests/unit/phpunit.xml.dist

// Integration Test - Real framework
namespace Vendor\\Module\\Test\\Integration\\Model;

class ProductServiceTest extends \\Magento\\TestFramework\\TestCase\\AbstractController
{
    /**
     * @magentoDataFixture Magento/Catalog/_files/product_simple.php
     */
    public function testGetProduct(): void
    {
        // Uses real DI, real database
        $productRepository = Bootstrap::getObjectManager()
            ->get(ProductRepositoryInterface::class);

        $product = $productRepository->get('simple');

        $this->assertEquals('simple', $product->getSku());
    }
}
// Run: vendor/bin/phpunit -c dev/tests/integration/phpunit.xml.dist`
          },
          {
            id: 118,
            category: "Testing",
            difficulty: "Hard",
            question: "What are the main components of MFTF (Magento Functional Testing Framework) tests?",
            options: [
              { id: "A", text: "PHPUnit classes and annotations" },
              { id: "B", text: "Test, ActionGroup, Section, and Data entities in XML format" },
              { id: "C", text: "JavaScript test files with Jasmine" },
              { id: "D", text: "Docker containers for test isolation" }
            ],
            correctAnswers: ["B"],
            explanation: `MFTF uses XML-based entities for browser automation testing.

Why B is correct:
- Test: Defines test flow, calls action groups
- ActionGroup: Reusable action sequences
- Section: Page element selectors
- Data: Test data entities
- All defined in XML files
- Generates PHP/Codeception tests

Why others are incorrect:
- A: MFTF uses XML, not PHPUnit directly
- C: Not JavaScript-based
- D: Docker optional, not core component`,
            codeExample: `<!-- Test/Mftf/Test/CreateSimpleProductTest.xml -->
<tests>
    <test name="CreateSimpleProductTest">
        <annotations>
            <title value="Create Simple Product"/>
            <severity value="CRITICAL"/>
        </annotations>

        <!-- Steps reference ActionGroups -->
        <actionGroup ref="AdminLoginActionGroup"/>
        <actionGroup ref="AdminNavigateToProductGridActionGroup"/>
        <actionGroup ref="CreateSimpleProductActionGroup">
            <argument name="product" value="SimpleProduct"/>
        </actionGroup>

        <see selector="{{AdminProductMessagesSection.successMessage}}"
             userInput="You saved the product."/>
    </test>
</tests>

<!-- ActionGroup/AdminLoginActionGroup.xml -->
<actionGroups>
    <actionGroup name="AdminLoginActionGroup">
        <amOnPage url="{{AdminLoginPage.url}}" stepKey="goToAdmin"/>
        <fillField selector="{{AdminLoginFormSection.username}}"
                   userInput="{{_ENV.MAGENTO_ADMIN_USERNAME}}" stepKey="enterUsername"/>
        <fillField selector="{{AdminLoginFormSection.password}}"
                   userInput="{{_ENV.MAGENTO_ADMIN_PASSWORD}}" stepKey="enterPassword"/>
        <click selector="{{AdminLoginFormSection.signIn}}" stepKey="clickLogin"/>
        <waitForPageLoad stepKey="waitForDashboard"/>
    </actionGroup>
</actionGroups>

<!-- Section/AdminLoginFormSection.xml -->
<sections>
    <section name="AdminLoginFormSection">
        <element name="username" type="input" selector="#username"/>
        <element name="password" type="input" selector="#login"/>
        <element name="signIn" type="button" selector=".action-login"/>
    </section>
</sections>

<!-- Data/SimpleProductData.xml -->
<entities>
    <entity name="SimpleProduct" type="product">
        <data key="sku">simple-product-{{unique}}</data>
        <data key="name">Simple Product {{unique}}</data>
        <data key="price">100.00</data>
    </entity>
</entities>

<!-- Run: vendor/bin/mftf run:test CreateSimpleProductTest -->`
          },
          {
            id: 119,
            category: "Testing",
            difficulty: "Medium",
            question: "How is PHPStan configured for static analysis in Magento 2 projects?",
            options: [
              { id: "A", text: "PHPStan cannot be used with Magento" },
              { id: "B", text: "Through phpstan.neon configuration with Magento-specific rules and level settings" },
              { id: "C", text: "Only via composer.json scripts" },
              { id: "D", text: "Through Magento Admin panel configuration" }
            ],
            correctAnswers: ["B"],
            explanation: `PHPStan uses neon configuration files for Magento analysis.

Why B is correct:
- phpstan.neon: Main configuration file
- Levels 0-9: Increasing strictness
- Magento extension: Understands Magento patterns
- Baseline: Ignore existing issues
- CI/CD integration common

Why others are incorrect:
- A: PHPStan fully supported
- C: Configuration in neon file, not just composer
- D: CLI tool, not admin panel`,
            codeExample: `# phpstan.neon
includes:
    - vendor/bitexpert/phpstan-magento/extension.neon

parameters:
    level: 6  # Strictness level (0-8, 9=max)

    paths:
        - app/code/Vendor

    excludePaths:
        - */Test/*
        - */Setup/*

    # Magento-specific settings
    magentoRootPath: %rootDir%/../../../

    # Ignore specific errors
    ignoreErrors:
        - '#Call to an undefined method#'

    # Use baseline for existing code
    baseline: phpstan-baseline.neon

# Magento extension handles:
# - Generated classes (Factories, Proxies)
# - Plugin method signatures
# - ObjectManager patterns
# - EAV magic methods

# Run analysis
vendor/bin/phpstan analyse --memory-limit=4G

# Generate baseline (ignore existing issues)
vendor/bin/phpstan analyse --generate-baseline

# Common levels:
# Level 0: Basic checks
# Level 5: Method return types, parameter types
# Level 6: Strict mixed type checks (recommended)
# Level 8: No mixed allowed

# composer.json integration
"scripts": {
    "phpstan": "phpstan analyse -c phpstan.neon"
}`
          },
          {
            id: 120,
            category: "Testing",
            difficulty: "Medium",
            question: "How are test fixtures used in Magento 2 integration tests?",
            options: [
              { id: "A", text: "Fixtures are deprecated in Magento 2" },
              { id: "B", text: "@magentoDataFixture annotation runs PHP files that set up/tear down test data" },
              { id: "C", text: "Fixtures are JSON files loaded automatically" },
              { id: "D", text: "Only database dumps are used as fixtures" }
            ],
            correctAnswers: ["B"],
            explanation: `Data fixtures are PHP files that prepare the database state for tests.

Why B is correct:
- @magentoDataFixture: Loads fixture before test
- Fixtures are PHP files in Test/_files/
- Rollback files (*_rollback.php) clean up
- Can create products, customers, orders, etc.
- Isolation: Each test starts with known state

Why others are incorrect:
- A: Fixtures are core testing feature
- C: PHP files, not JSON
- D: PHP fixtures, not DB dumps`,
            codeExample: `// Test class with fixtures
namespace Vendor\\Module\\Test\\Integration;

class OrderServiceTest extends \\Magento\\TestFramework\\TestCase\\AbstractController
{
    /**
     * @magentoDataFixture Magento/Sales/_files/order.php
     * @magentoDataFixture Vendor_Module::Test/_files/custom_data.php
     */
    public function testOrderProcessing(): void
    {
        // Fixtures loaded before this runs
        $order = $this->orderRepository->get('100000001');
        $this->assertEquals('pending', $order->getStatus());
    }
}

// Fixture file: Test/_files/custom_data.php
<?php
declare(strict_types=1);

use Magento\\TestFramework\\Helper\\Bootstrap;

$objectManager = Bootstrap::getObjectManager();

// Create test data
$product = $objectManager->create(\\Magento\\Catalog\\Model\\Product::class);
$product->setSku('test-product')
    ->setName('Test Product')
    ->setPrice(99.99)
    ->setTypeId('simple')
    ->setAttributeSetId(4)
    ->setStatus(1)
    ->setVisibility(4)
    ->save();

// Rollback file: Test/_files/custom_data_rollback.php
<?php
use Magento\\TestFramework\\Helper\\Bootstrap;
use Magento\\Framework\\Registry;

$objectManager = Bootstrap::getObjectManager();
$registry = $objectManager->get(Registry::class);
$registry->register('isSecureArea', true);

// Clean up test data
$product = $objectManager->create(\\Magento\\Catalog\\Model\\Product::class);
$product->load('test-product', 'sku');
if ($product->getId()) {
    $product->delete();
}

$registry->unregister('isSecureArea');`
          },
          {
            id: 121,
            category: "Testing",
            difficulty: "Hard",
            question: "How are Web API functional tests structured in Magento 2?",
            options: [
              { id: "A", text: "Using JavaScript and browser automation" },
              { id: "B", text: "Extending WebapiAbstract with _webApiCall() and fixtures in _files directory" },
              { id: "C", text: "Only manual API testing is supported" },
              { id: "D", text: "Through GraphQL playground exclusively" }
            ],
            correctAnswers: ["B"],
            explanation: `Web API tests extend special base classes for REST/SOAP testing.

Why B is correct:
- WebapiAbstract: Base class for API tests
- _webApiCall(): Makes authenticated API requests
- Supports REST and SOAP
- Fixtures for test data setup
- Runs against real Magento instance

Why others are incorrect:
- A: PHP-based, not JavaScript
- C: Automated testing supported
- D: REST/SOAP, not just GraphQL`,
            codeExample: `// Web API Functional Test
namespace Vendor\\Module\\Test\\Api;

use Magento\\TestFramework\\TestCase\\WebapiAbstract;

class ProductApiTest extends WebapiAbstract
{
    const RESOURCE_PATH = '/V1/products';

    /**
     * @magentoApiDataFixture Magento/Catalog/_files/product_simple.php
     */
    public function testGetProduct(): void
    {
        $sku = 'simple';

        $serviceInfo = [
            'rest' => [
                'resourcePath' => self::RESOURCE_PATH . '/' . $sku,
                'httpMethod' => \\Magento\\Framework\\Webapi\\Rest\\Request::HTTP_METHOD_GET,
            ],
            'soap' => [
                'service' => 'catalogProductRepositoryV1',
                'operation' => 'catalogProductRepositoryV1Get',
            ],
        ];

        $response = $this->_webApiCall($serviceInfo);

        $this->assertEquals($sku, $response['sku']);
        $this->assertEquals('Simple Product', $response['name']);
    }

    public function testCreateProduct(): void
    {
        $productData = [
            'product' => [
                'sku' => 'test-api-product',
                'name' => 'Test API Product',
                'price' => 99.99,
                'status' => 1,
                'type_id' => 'simple',
                'attribute_set_id' => 4,
            ]
        ];

        $serviceInfo = [
            'rest' => [
                'resourcePath' => self::RESOURCE_PATH,
                'httpMethod' => \\Magento\\Framework\\Webapi\\Rest\\Request::HTTP_METHOD_POST,
            ],
        ];

        $response = $this->_webApiCall($serviceInfo, $productData);

        $this->assertArrayHasKey('id', $response);
    }
}

// Run: vendor/bin/phpunit -c dev/tests/api-functional/phpunit.xml.dist
// Requires: TESTS_BASE_URL, TESTS_WEBSERVICE_USER, TESTS_WEBSERVICE_APIKEY`
          }
        ];

        // Styles
        const styles = {
          container: {
            minHeight: '100vh',
            background: 'linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%)',
            fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
            color: '#e4e4e7',
            padding: '20px',
          },
          header: { textAlign: 'center', marginBottom: '25px', padding: '15px' },
          title: {
            fontSize: '2rem',
            fontWeight: '700',
            background: 'linear-gradient(90deg, #f97316, #fb923c, #fbbf24)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent',
            marginBottom: '8px',
          },
          subtitle: { fontSize: '0.95rem', color: '#94a3b8' },
          statsBar: { display: 'flex', justifyContent: 'center', gap: '15px', marginBottom: '15px', flexWrap: 'wrap' },
          statItem: { background: 'rgba(30, 41, 59, 0.6)', padding: '8px 16px', borderRadius: '8px', fontSize: '0.85rem' },
          filterBar: { display: 'flex', justifyContent: 'center', gap: '8px', marginBottom: '15px', flexWrap: 'wrap' },
          filterButton: {
            padding: '6px 12px', borderRadius: '6px', border: '1px solid rgba(148, 163, 184, 0.3)',
            background: 'rgba(30, 41, 59, 0.6)', color: '#e2e8f0', cursor: 'pointer', fontSize: '0.8rem',
          },
          filterButtonActive: { background: 'rgba(249, 115, 22, 0.3)', borderColor: '#f97316' },
          card: {
            background: 'rgba(30, 41, 59, 0.8)', backdropFilter: 'blur(10px)', borderRadius: '14px',
            border: '1px solid rgba(148, 163, 184, 0.1)', padding: '22px', maxWidth: '900px', margin: '0 auto',
            boxShadow: '0 20px 40px -12px rgba(0, 0, 0, 0.5)',
          },
          questionHeader: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px', flexWrap: 'wrap', gap: '6px' },
          badge: { display: 'inline-flex', alignItems: 'center', gap: '4px', padding: '4px 8px', borderRadius: '12px', fontSize: '0.75rem', fontWeight: '500' },
          categoryBadge: { background: 'rgba(59, 130, 246, 0.2)', color: '#60a5fa', border: '1px solid rgba(59, 130, 246, 0.3)' },
          difficultyBadge: { background: 'rgba(249, 115, 22, 0.2)', color: '#fb923c', border: '1px solid rgba(249, 115, 22, 0.3)' },
          question: { fontSize: '1rem', lineHeight: '1.65', color: '#f1f5f9', marginBottom: '18px', whiteSpace: 'pre-wrap' },
          optionsContainer: { display: 'flex', flexDirection: 'column', gap: '8px', marginBottom: '18px' },
          option: {
            display: 'flex', alignItems: 'flex-start', gap: '10px', padding: '10px 12px', borderRadius: '8px',
            border: '2px solid rgba(148, 163, 184, 0.2)', cursor: 'pointer', transition: 'all 0.2s',
            background: 'rgba(15, 23, 42, 0.5)',
          },
          optionSelected: { borderColor: '#f97316', background: 'rgba(249, 115, 22, 0.15)' },
          optionCorrect: { borderColor: '#22c55e', background: 'rgba(34, 197, 94, 0.15)' },
          optionIncorrect: { borderColor: '#ef4444', background: 'rgba(239, 68, 68, 0.15)' },
          optionLetter: {
            width: '24px', height: '24px', borderRadius: '50%', display: 'flex', alignItems: 'center',
            justifyContent: 'center', fontWeight: '600', fontSize: '0.8rem', flexShrink: 0,
            background: 'rgba(148, 163, 184, 0.2)', color: '#94a3b8',
          },
          optionText: { flex: 1, lineHeight: '1.45', fontSize: '0.9rem' },
          button: {
            display: 'inline-flex', alignItems: 'center', gap: '6px', padding: '9px 18px', borderRadius: '7px',
            fontWeight: '600', fontSize: '0.9rem', cursor: 'pointer', transition: 'all 0.2s', border: 'none',
          },
          primaryButton: { background: 'linear-gradient(135deg, #f97316, #fb923c)', color: 'white' },
          secondaryButton: { background: 'rgba(148, 163, 184, 0.2)', color: '#e2e8f0', border: '1px solid rgba(148, 163, 184, 0.3)' },
          buttonContainer: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', flexWrap: 'wrap', gap: '8px', marginTop: '12px' },
          progressBar: { height: '4px', background: 'rgba(148, 163, 184, 0.2)', borderRadius: '2px', marginBottom: '20px', overflow: 'hidden' },
          progressFill: { height: '100%', background: 'linear-gradient(90deg, #f97316, #fbbf24)', borderRadius: '2px', transition: 'width 0.3s' },
          explanationCard: { background: 'rgba(15, 23, 42, 0.7)', borderRadius: '8px', padding: '15px', marginTop: '12px', border: '1px solid rgba(148, 163, 184, 0.1)' },
          explanationTitle: { display: 'flex', alignItems: 'center', gap: '6px', fontSize: '0.95rem', fontWeight: '600', color: '#fbbf24', marginBottom: '10px' },
          explanationText: { lineHeight: '1.6', color: '#cbd5e1', whiteSpace: 'pre-wrap', fontSize: '0.85rem' },
          codeBlock: {
            background: '#0f172a', borderRadius: '6px', padding: '12px', marginTop: '10px', overflow: 'auto',
            fontFamily: "'Consolas', monospace", fontSize: '0.75rem', lineHeight: '1.45',
            border: '1px solid rgba(148, 163, 184, 0.1)', maxHeight: '300px', color: '#a5f3fc',
          },
          statsGrid: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(120px, 1fr))', gap: '10px', marginBottom: '20px' },
          statCard: { background: 'rgba(15, 23, 42, 0.6)', borderRadius: '8px', padding: '12px', textAlign: 'center', border: '1px solid rgba(148, 163, 184, 0.1)' },
          statValue: { fontSize: '1.6rem', fontWeight: '700', marginBottom: '2px' },
          statLabel: { fontSize: '0.8rem', color: '#94a3b8' },
        };

        function App() {
          const [currentQuestion, setCurrentQuestion] = useState(0);
          const [selectedAnswers, setSelectedAnswers] = useState({});
          const [showResult, setShowResult] = useState(false);
          const [quizCompleted, setQuizCompleted] = useState(false);
          const [score, setScore] = useState(0);
          const [categoryFilter, setCategoryFilter] = useState('All');
          const [filteredQuestions, setFilteredQuestions] = useState(quizQuestions);
          const [answeredQuestions, setAnsweredQuestions] = useState(new Set());

          const categories = ['All', ...new Set(quizQuestions.map(q => q.category))];

          useEffect(() => {
            if (categoryFilter === 'All') {
              setFilteredQuestions(quizQuestions);
            } else {
              setFilteredQuestions(quizQuestions.filter(q => q.category === categoryFilter));
            }
            setCurrentQuestion(0);
            setSelectedAnswers({});
            setShowResult(false);
            setScore(0);
            setQuizCompleted(false);
            setAnsweredQuestions(new Set());
          }, [categoryFilter]);

          const question = filteredQuestions[currentQuestion];
          const isMultiSelect = question?.correctAnswers.length > 1;
          const currentSelected = selectedAnswers[currentQuestion] || [];

          const handleOptionSelect = (optionId) => {
            if (showResult) return;
            if (isMultiSelect) {
              const newSelected = currentSelected.includes(optionId)
                ? currentSelected.filter(id => id !== optionId)
                : [...currentSelected, optionId];
              setSelectedAnswers({ ...selectedAnswers, [currentQuestion]: newSelected });
            } else {
              setSelectedAnswers({ ...selectedAnswers, [currentQuestion]: [optionId] });
            }
          };

          const checkAnswer = () => {
            setShowResult(true);
            const isCorrect = currentSelected.length === question.correctAnswers.length &&
              currentSelected.every(a => question.correctAnswers.includes(a));
            if (isCorrect && !answeredQuestions.has(currentQuestion)) {
              setScore(score + 1);
            }
            setAnsweredQuestions(new Set([...answeredQuestions, currentQuestion]));
          };

          const nextQuestion = () => {
            if (currentQuestion < filteredQuestions.length - 1) {
              setCurrentQuestion(currentQuestion + 1);
              setShowResult(false);
            } else {
              setQuizCompleted(true);
            }
          };

          const prevQuestion = () => {
            if (currentQuestion > 0) {
              setCurrentQuestion(currentQuestion - 1);
              setShowResult(false);
            }
          };

          const restartQuiz = () => {
            setCurrentQuestion(0);
            setSelectedAnswers({});
            setShowResult(false);
            setQuizCompleted(false);
            setScore(0);
            setAnsweredQuestions(new Set());
          };

          const shuffleQuestions = () => {
            const shuffled = [...filteredQuestions].sort(() => Math.random() - 0.5);
            setFilteredQuestions(shuffled);
            restartQuiz();
          };

          const getOptionStyle = (optionId) => {
            let style = { ...styles.option };
            if (showResult) {
              if (question.correctAnswers.includes(optionId)) style = { ...style, ...styles.optionCorrect };
              else if (currentSelected.includes(optionId)) style = { ...style, ...styles.optionIncorrect };
            } else if (currentSelected.includes(optionId)) {
              style = { ...style, ...styles.optionSelected };
            }
            return style;
          };

          const getLetterStyle = (optionId) => {
            let style = { ...styles.optionLetter };
            if (showResult) {
              if (question.correctAnswers.includes(optionId)) style = { ...style, background: '#22c55e', color: 'white' };
              else if (currentSelected.includes(optionId)) style = { ...style, background: '#ef4444', color: 'white' };
            } else if (currentSelected.includes(optionId)) {
              style = { ...style, background: '#f97316', color: 'white' };
            }
            return style;
          };

          if (!question) return <div style={styles.container}>Loading...</div>;

          if (quizCompleted) {
            const percentage = Math.round((score / filteredQuestions.length) * 100);
            const passed = percentage >= 68;
            
            return (
              <div style={styles.container}>
                <div style={styles.header}>
                  <h1 style={styles.title}>Quiz Complete!</h1>
                  <p style={styles.subtitle}>Adobe Commerce Architect (AD0-E722)</p>
                </div>
                <div style={styles.card}>
                  <div style={{ textAlign: 'center' }}>
                    <Award size={60} style={{ color: passed ? '#22c55e' : '#f97316', marginBottom: '12px' }} />
                    <h2 style={{ fontSize: '1.6rem', marginBottom: '6px', color: passed ? '#22c55e' : '#f97316' }}>
                      {passed ? 'Congratulations!' : 'Keep Practicing!'}
                    </h2>
                    <p style={{ color: '#94a3b8', fontSize: '0.95rem', marginBottom: '20px' }}>
                      {passed ? "You're on track to pass!" : 'Review explanations and try again.'}
                    </p>
                  </div>
                  <div style={styles.statsGrid}>
                    <div style={styles.statCard}>
                      <div style={{ ...styles.statValue, color: '#60a5fa' }}>{score}/{filteredQuestions.length}</div>
                      <div style={styles.statLabel}>Correct</div>
                    </div>
                    <div style={styles.statCard}>
                      <div style={{ ...styles.statValue, color: passed ? '#22c55e' : '#f97316' }}>{percentage}%</div>
                      <div style={styles.statLabel}>Score</div>
                    </div>
                    <div style={styles.statCard}>
                      <div style={{ ...styles.statValue, color: '#a78bfa' }}>68%</div>
                      <div style={styles.statLabel}>Required</div>
                    </div>
                  </div>
                  <div style={{ display: 'flex', justifyContent: 'center', gap: '8px', flexWrap: 'wrap' }}>
                    <button style={{ ...styles.button, ...styles.primaryButton }} onClick={restartQuiz}>
                      <RotateCcw /> Try Again
                    </button>
                    <button style={{ ...styles.button, ...styles.secondaryButton }} onClick={shuffleQuestions}>
                      <Shuffle /> Shuffle
                    </button>
                  </div>
                </div>
              </div>
            );
          }

          return (
            <div style={styles.container}>
              <div style={styles.header}>
                <h1 style={styles.title}>Adobe Commerce Architect</h1>
                <p style={styles.subtitle}>Master Certification (AD0-E722)  {filteredQuestions.length} Questions</p>
              </div>
              
              <div style={styles.statsBar}>
                <div style={styles.statItem}><strong>Question:</strong> {currentQuestion + 1}/{filteredQuestions.length}</div>
                <div style={styles.statItem}><strong>Score:</strong> {score} correct</div>
              </div>

              <div style={styles.filterBar}>
                <Filter />
                {categories.map(cat => (
                  <button key={cat}
                    style={{ ...styles.filterButton, ...(categoryFilter === cat ? styles.filterButtonActive : {}) }}
                    onClick={() => setCategoryFilter(cat)}>
                    {cat}
                  </button>
                ))}
              </div>
              
              <div style={styles.card}>
                <div style={styles.progressBar}>
                  <div style={{ ...styles.progressFill, width: `${((currentQuestion + 1) / filteredQuestions.length) * 100}%` }} />
                </div>
                
                <div style={styles.questionHeader}>
                  <span style={{ ...styles.badge, ...styles.categoryBadge }}><BookOpen /> {question.category}</span>
                  <span style={{ ...styles.badge, ...styles.difficultyBadge }}><Target /> {question.difficulty}</span>
                  {isMultiSelect && (
                    <span style={{ ...styles.badge, background: 'rgba(139, 92, 246, 0.2)', color: '#a78bfa', border: '1px solid rgba(139, 92, 246, 0.3)' }}>
                      Select {question.correctAnswers.length}
                    </span>
                  )}
                </div>
                
                <p style={styles.question}>{question.question}</p>
                
                <div style={styles.optionsContainer}>
                  {question.options.map((option) => (
                    <div key={option.id} style={getOptionStyle(option.id)} onClick={() => handleOptionSelect(option.id)}>
                      <div style={getLetterStyle(option.id)}>
                        {showResult && question.correctAnswers.includes(option.id) ? <Check /> :
                         showResult && currentSelected.includes(option.id) ? <X /> : option.id}
                      </div>
                      <span style={styles.optionText}>{option.text}</span>
                    </div>
                  ))}
                </div>
                
                {showResult && (
                  <div style={styles.explanationCard}>
                    <div style={styles.explanationTitle}><Lightbulb /> Explanation</div>
                    <div style={styles.explanationText}>{question.explanation}</div>
                    {question.codeExample && (
                      <>
                        <div style={{ ...styles.explanationTitle, marginTop: '12px', color: '#60a5fa' }}><Code /> Code Example</div>
                        <pre style={styles.codeBlock}><code>{question.codeExample}</code></pre>
                      </>
                    )}
                  </div>
                )}
                
                <div style={styles.buttonContainer}>
                  <button style={{ ...styles.button, ...styles.secondaryButton, opacity: currentQuestion === 0 ? 0.5 : 1 }}
                    onClick={prevQuestion} disabled={currentQuestion === 0}>
                    <ChevronLeft /> Previous
                  </button>
                  <div style={{ display: 'flex', gap: '6px' }}>
                    {!showResult ? (
                      <button style={{ ...styles.button, ...styles.primaryButton, opacity: currentSelected.length === 0 ? 0.5 : 1 }}
                        onClick={checkAnswer} disabled={currentSelected.length === 0}>
                        <Check /> Check
                      </button>
                    ) : (
                      <button style={{ ...styles.button, ...styles.primaryButton }} onClick={nextQuestion}>
                        {currentQuestion < filteredQuestions.length - 1 ? <>Next <ChevronRight /></> : <><Award /> Results</>}
                      </button>
                    )}
                  </div>
                </div>
              </div>
            </div>
          );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
