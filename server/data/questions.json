[
  {
    "id": 1,
    "category": "Configuration & XML",
    "difficulty": "Hard",
    "question": "An Adobe Commerce Architect is working on a scanner that will pull prices from multiple external product feeds. The Architect has a list of vendors and decides to create a new config file marketplace_feeds.xml. Which three steps can the Architect take to ensure validation of the configuration files with unique validation rules for the individual and merged files?",
    "options": [
      {
        "id": "A",
        "text": "Implement validation rules in the Converter class for the Config Reader."
      },
      {
        "id": "B",
        "text": "Create validation rules in marketplace_schema.xsd."
      },
      {
        "id": "C",
        "text": "Provide schema to validate a merged file."
      },
      {
        "id": "D",
        "text": "Add the Uniform Resource Name (URN) to the XSD file in the config XML file."
      },
      {
        "id": "E",
        "text": "Provide schema to validate an individual file."
      },
      {
        "id": "F",
        "text": "Create a class that implements \\Magento\\Framework\\Config\\DataInterface."
      }
    ],
    "correctAnswers": [
      "C",
      "D",
      "E"
    ],
    "explanation": "For custom XML configuration validation in Magento 2, you need three key components:\n\n1. Provide schema to validate an individual file (E): Individual file schemas validate each module's XML file before merging.\n\n2. Provide schema to validate a merged file (C): Merged schemas validate the combined XML after all modules' configs are collected.\n\n3. Add the URN to the XSD file in the config XML file (D): The URN links the XML to its schema for IDE and runtime validation.\n\nWhy not the others:\n- A: Converter classes transform XML to arrays, not validate\n- B: Schema file should match the XML filename pattern\n- F: DataInterface is for accessing config data, not validation",
    "codeExample": "// SchemaLocator.php\nclass SchemaLocator implements SchemaLocatorInterface\n{\n    protected $schema;        // For merged file\n    protected $perFileSchema; // For individual files\n    \n    public function __construct(Reader $moduleReader) {\n        $configDir = $moduleReader->getModuleDir(Dir::MODULE_ETC_DIR, 'Vendor_Module');\n        $this->schema = $configDir . '/marketplace_feeds.xsd';\n        $this->perFileSchema = $configDir . '/marketplace_feeds_file.xsd';\n    }\n    \n    public function getSchema() { return $this->schema; }\n    public function getPerFileSchema() { return $this->perFileSchema; }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "xml-configuration",
      "merge-rules",
      "scope-configuration"
    ]
  },
  {
    "id": 2,
    "category": "EAV & Attributes",
    "difficulty": "Medium",
    "question": "A merchant asks to add a new reward card functionality for customers. The reward_card_number attribute is causing the customer attribute to be unavailable in the My Account/My Rewards page template. What should be added to set the customer attribute correctly?",
    "options": [
      {
        "id": "A",
        "text": "group property should be added with a value of 1"
      },
      {
        "id": "B",
        "text": "system property should be added with a value of true"
      },
      {
        "id": "C",
        "text": "scope property should be added with a value of global"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "The group property determines which attribute group the attribute belongs to and affects its visibility in templates.\n\nWhy Option A is correct:\nThe group property with a value of 1 assigns the attribute to the \"General Information\" group, making it visible in frontend templates including My Account pages.\n\nWhy B and C are incorrect:\n- system = true: Makes it a system attribute, which HIDES it from frontend and admin forms\n- scope = global: Controls whether the attribute value is shared across websites, not visibility",
    "codeExample": "$customerSetup->addAttribute(Customer::ENTITY, 'reward_card_number', [\n    'type' => 'varchar',\n    'label' => 'Reward Card Number',\n    'input' => 'text',\n    'required' => false,\n    'visible' => true,\n    'user_defined' => true,\n    'system' => false,    // Must be false for custom attributes\n    'group' => 1,         // KEY: Assigns to General group for visibility\n]);",
    "examDomain": "Design",
    "objectiveTags": [
      "eav",
      "catalog-modeling"
    ]
  },
  {
    "id": 3,
    "category": "Indexing",
    "difficulty": "Hard",
    "question": "A custom product feed export module shows correct prices in testing but incorrect prices in production. Unit and integration tests pass. Which two steps should resolve this issue?",
    "options": [
      {
        "id": "A",
        "text": "Reduce the frequency of the cron job to 5 minutes."
      },
      {
        "id": "B",
        "text": "Make sure no custom or third-party modules modify the changelog and indexing process."
      },
      {
        "id": "C",
        "text": "Make sure the version_id for the price indexer in mview_state is not higher than the changelog table and synchronize."
      },
      {
        "id": "D",
        "text": "Invalidate the catalog_product_price indexer in Admin Panel."
      },
      {
        "id": "E",
        "text": "Manually reindex from command line: bin/magento indexer:reindex catalog_product_price"
      }
    ],
    "correctAnswers": [
      "B",
      "C"
    ],
    "explanation": "This is a classic MView indexing synchronization issue.\n\nWhy B is correct:\nCustom or third-party modules may interfere with changelog tables (*_cl) or the indexing process, causing data inconsistencies.\n\nWhy C is correct:\nThe mview_state table tracks version_id values. If version_id is higher than changelog entries, the indexer skips records, causing stale data.\n\nWhy A, D, E are not optimal:\n- A: Changing cron frequency doesn't fix synchronization\n- D & E: Reindexing temporarily fixes but doesn't address root cause",
    "codeExample": "-- Check MView synchronization\nSELECT * FROM mview_state WHERE view_id = 'catalog_product_price';\nSELECT MAX(version_id) FROM catalog_product_price_cl;\n\n-- Fix: Reset version_id if higher than changelog\nUPDATE mview_state \nSET version_id = (SELECT IFNULL(MAX(version_id), 0) FROM catalog_product_price_cl)\nWHERE view_id = 'catalog_product_price';",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "indexing",
      "operational-readiness"
    ]
  },
  {
    "id": 4,
    "category": "Session & Architecture",
    "difficulty": "Hard",
    "question": "After deploying a distributed architecture with multiple webservers behind a Load Balancer, users cannot access Customer Dashboard after logging in. Session is configured as:\n'session' => ['save' => 'files', 'save_path' => '/var/www/html/var/session']\n\nWhat should the Architect do?",
    "options": [
      {
        "id": "A",
        "text": "Update the session host value to a shared Redis instance"
      },
      {
        "id": "B",
        "text": "Increase the session size with config:set system/security/max_session_size_admin"
      },
      {
        "id": "C",
        "text": "Utilize the Remote Storage module to synchronize sessions between servers"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "In distributed/load-balanced architectures, file-based sessions cause authentication failures because each server has its own local filesystem.\n\nWhy A is correct:\nRedis provides centralized session storage accessible by all servers. All web servers connect to the same Redis instance, ensuring session data is available regardless of which server handles the request.\n\nWhy B and C are incorrect:\n- B: Session size limits are unrelated to distributed session sharing\n- C: Remote Storage module is for media files, not session management",
    "codeExample": "// Correct env.php for distributed architecture\n'session' => [\n    'save' => 'redis',\n    'redis' => [\n        'host' => 'redis.internal',\n        'port' => '6379',\n        'database' => '2',  // Separate from cache\n        'disable_locking' => '0',\n        'max_concurrency' => '6',\n    ]\n],",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "session-management",
      "distributed-architecture"
    ]
  },
  {
    "id": 5,
    "category": "Deployment & Cloud",
    "difficulty": "Hard",
    "question": "For optimal zero-downtime deployment on Adobe Commerce Cloud, when should static content be generated?",
    "options": [
      {
        "id": "A",
        "text": "During the deploy phase with SCD_ON_DEMAND enabled"
      },
      {
        "id": "B",
        "text": "During the build phase with config:dump to move locales to config.php"
      },
      {
        "id": "C",
        "text": "During the post-deploy phase using WARM_UP_PAGES"
      },
      {
        "id": "D",
        "text": "On-demand when users request pages for the first time"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "For zero-downtime deployments, static content should be generated during the build phase.\n\nWhy B is correct:\n- Build phase has no database access, but locales can be stored in config.php\n- Static content is generated before site goes into maintenance mode\n- Content is symlinked during deploy, making it available instantly\n- No maintenance downtime for static content generation\n\nWhy others are suboptimal:\n- A: Deploy phase puts site in maintenance mode\n- C: Post-deploy is too late, users already accessing site\n- D: On-demand adds load time to user requests",
    "codeExample": "# .magento.env.yaml for optimal SCD\nstage:\n  build:\n    SKIP_SCD: false  # Generate during build\n    SCD_STRATEGY: compact\n  deploy:\n    SKIP_SCD: true  # Skip during deploy\n\n# Before deployment, run:\nbin/magento app:config:dump",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "deployment-strategy",
      "release-safety"
    ]
  },
  {
    "id": 6,
    "category": "Plugins & DI",
    "difficulty": "Medium",
    "question": "A developer needs to modify the product save operation to add custom validation and prevent saving if conditions are not met. Which approach should the Architect recommend?",
    "options": [
      {
        "id": "A",
        "text": "Create an after plugin on save() to validate and throw exception if validation fails"
      },
      {
        "id": "B",
        "text": "Create a before plugin on save() to validate and prevent execution"
      },
      {
        "id": "C",
        "text": "Create an around plugin on save() to validate and skip proceed() if validation fails"
      },
      {
        "id": "D",
        "text": "Create a preference for the Product model and override save()"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "When you need to potentially prevent a method from executing, an around plugin is the correct choice.\n\nWhy C is correct:\nAn around plugin allows you to:\n1. Execute code before the original method\n2. Decide whether to call proceed()\n3. Execute code after if needed\n4. Completely bypass the original method\n\nWhy others are incorrect:\n- A (after): Save already happened - too late\n- B (before): Cannot prevent method execution\n- D (preference): Causes conflicts with other extensions",
    "codeExample": "class ProductSaveValidation\n{\n    public function aroundSave(\n        \\Magento\\Catalog\\Model\\Product $subject,\n        callable $proceed\n    ) {\n        if (!$this->validateProduct($subject)) {\n            throw new LocalizedException(__('Validation failed.'));\n        }\n        return $proceed(); // Only call if validation passes\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "plugins",
      "di",
      "extensibility"
    ]
  },
  {
    "id": 7,
    "category": "Plugins & DI",
    "difficulty": "Hard",
    "question": "Which of the following CANNOT be intercepted using plugins in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Public methods of any class"
      },
      {
        "id": "B",
        "text": "Final methods and final classes"
      },
      {
        "id": "C",
        "text": "Protected methods with public wrapper"
      },
      {
        "id": "D",
        "text": "Interface methods with concrete implementations"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento 2 plugins have specific limitations:\n\nCannot intercept:\n- Final classes and final methods\n- Private and protected methods\n- Static methods\n- __construct() methods\n- Virtual types\n- Objects instantiated before Interception is bootstrapped\n- Objects not instantiated by ObjectManager\n\nWhy B is correct:\nPHP's final keyword prevents inheritance, and Magento's interceptor pattern requires generating a subclass.",
    "codeExample": "// These CANNOT be intercepted:\n\n// 1. Final class\nfinal class FinalClass {\n    public function doSomething() { }  // Cannot intercept\n}\n\n// 2. Final method\nclass SomeClass {\n    final public function finalMethod() { }  // Cannot intercept\n    public function normalMethod() { }       // CAN intercept\n}\n\n// 3. Constructor\nclass AnyClass {\n    public function __construct() { }  // Cannot intercept\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "plugins",
      "di",
      "extensibility"
    ]
  },
  {
    "id": 8,
    "category": "Service Contracts",
    "difficulty": "Medium",
    "question": "An Architect is designing a module to expose product data through REST API. Which approach ensures proper API exposure following Adobe Commerce best practices?",
    "options": [
      {
        "id": "A",
        "text": "Implement ExtensibleDataInterface for the data model"
      },
      {
        "id": "B",
        "text": "Create a repository interface extending SearchCriteriaInterface"
      },
      {
        "id": "C",
        "text": "Implement a repository pattern with interface annotated with @api and configure webapi.xml"
      },
      {
        "id": "D",
        "text": "Create a controller extending HttpGetActionInterface"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "Adobe Commerce's Web API is designed around Service Contracts using the repository pattern.\n\nWhy C is correct:\n- Repository interfaces with @api annotation mark them as public API\n- webapi.xml maps HTTP routes to service contract methods\n- Ensures backward compatibility and proper API versioning\n\nWhy others are incorrect:\n- A: ExtensibleDataInterface is for data models, not API exposure\n- B: SearchCriteriaInterface is for filtering, not repository definition\n- D: Controllers are for browser requests, not API endpoints",
    "codeExample": "// Api/CustomRepositoryInterface.php\n/**\n * @api\n */\ninterface CustomRepositoryInterface\n{\n    /**\n     * @param int $id\n     * @return CustomInterface\n     */\n    public function getById($id);\n}\n\n// etc/webapi.xml\n<route url=\"/V1/custom/:id\" method=\"GET\">\n    <service class=\"Vendor\\Module\\Api\\CustomRepositoryInterface\" method=\"getById\"/>\n    <resources><resource ref=\"Vendor_Module::view\"/></resources>\n</route>",
    "examDomain": "Design",
    "objectiveTags": [
      "service-contracts",
      "api-design",
      "backward-compatibility"
    ]
  },
  {
    "id": 9,
    "category": "GraphQL",
    "difficulty": "Medium",
    "question": "An Architect needs to create a custom GraphQL query. Which file must be created to define the GraphQL schema?",
    "options": [
      {
        "id": "A",
        "text": "etc/graphql.xml"
      },
      {
        "id": "B",
        "text": "etc/schema.graphqls"
      },
      {
        "id": "C",
        "text": "etc/webapi_graphql.xml"
      },
      {
        "id": "D",
        "text": "etc/graphql/schema.xml"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "GraphQL schemas in Magento 2 are defined in schema.graphqls files.\n\nWhy B is correct:\n- Located in etc/schema.graphqls\n- Uses GraphQL Schema Definition Language (SDL)\n- Automatically merged with other modules' schemas\n- Defines types, queries, mutations, and resolvers\n\nFile naming convention:\n- Must be named exactly schema.graphqls\n- Must be in the etc directory",
    "codeExample": "# etc/schema.graphqls\ntype Query {\n    customProducts(\n        pageSize: Int = 20\n    ): CustomProductsOutput\n        @resolver(class: \"Vendor\\\\Module\\\\Model\\\\Resolver\\\\CustomProducts\")\n        @doc(description: \"Get custom products\")\n}\n\ntype CustomProductsOutput {\n    items: [CustomProduct]\n    total_count: Int\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 10,
    "category": "GraphQL",
    "difficulty": "Hard",
    "question": "When implementing a GraphQL resolver for a mutation that modifies customer data, how should authorization be checked?",
    "options": [
      {
        "id": "A",
        "text": "Check $context->getUserId() is not null"
      },
      {
        "id": "B",
        "text": "Check $context->getExtensionAttributes()->getIsCustomer() is true"
      },
      {
        "id": "C",
        "text": "Use ACL resources in schema.graphqls"
      },
      {
        "id": "D",
        "text": "Implement PolicyInterface"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "GraphQL context provides customer authentication status through extension attributes.\n\nWhy B is correct:\nThe getIsCustomer() method on context extension attributes is the standard way to verify customer authentication in GraphQL resolvers.\n\nPattern:\n- Check context for authentication\n- Throw GraphQlAuthorizationException if not authenticated\n- Then proceed with business logic",
    "codeExample": "class UpdateCustomerData implements ResolverInterface\n{\n    public function resolve(Field $field, $context, ResolveInfo $info, array $value = null, array $args = null)\n    {\n        // Check if customer is authenticated\n        if (false === $context->getExtensionAttributes()->getIsCustomer()) {\n            throw new GraphQlAuthorizationException(__('Not authorized.'));\n        }\n        \n        $customerId = $context->getUserId();\n        return $this->updateCustomerData($customerId, $args['input']);\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 11,
    "category": "Message Queues",
    "difficulty": "Hard",
    "question": "An Architect is implementing asynchronous processing for large product imports that must survive server restarts. Which configuration approach should be used?",
    "options": [
      {
        "id": "A",
        "text": "Use MySQL-based message queues with queue_topology.xml and queue_consumer.xml"
      },
      {
        "id": "B",
        "text": "Implement Redis pub/sub for real-time message handling"
      },
      {
        "id": "C",
        "text": "Configure cron jobs to process files from a shared directory"
      },
      {
        "id": "D",
        "text": "Use PHP sessions to store pending operations"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "For reliable asynchronous processing that survives server restarts, MySQL-based message queues (or RabbitMQ) are the proper solution.\n\nWhy A is correct:\n- Messages are persisted in the database\n- Survives server restarts\n- Supports multiple consumers\n- Built-in retry mechanisms\n\nWhy others are incorrect:\n- B: Redis pub/sub is volatile - messages lost on restart\n- C: Cron-based file processing lacks queue semantics\n- D: Sessions are per-user and volatile",
    "codeExample": "<!-- etc/queue_topology.xml -->\n<exchange name=\"vendor.exchange\" type=\"topic\" connection=\"db\">\n    <binding id=\"importBinding\" topic=\"vendor.product.import\" \n             destinationType=\"queue\" destination=\"vendor.import.queue\"/>\n</exchange>\n\n<!-- etc/queue_consumer.xml -->\n<consumer name=\"importConsumer\" queue=\"vendor.import.queue\"\n          handler=\"Vendor\\Module\\Model\\Consumer::process\" connection=\"db\"/>",
    "examDomain": "Design",
    "objectiveTags": [
      "message-queue",
      "asynchronous-operations"
    ]
  },
  {
    "id": 12,
    "category": "Performance",
    "difficulty": "Hard",
    "question": "Category pages are slow despite FPC being enabled. The first request to each page is still slow. Which optimization should be implemented?",
    "options": [
      {
        "id": "A",
        "text": "Implement Varnish ESI (Edge Side Includes) for dynamic blocks"
      },
      {
        "id": "B",
        "text": "Enable flat catalog tables for categories and products"
      },
      {
        "id": "C",
        "text": "Increase PHP memory_limit and max_execution_time"
      },
      {
        "id": "D",
        "text": "Disable all third-party modules temporarily"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "When FPC is working but initial requests are slow, the issue is often dynamic content that fragments the cache.\n\nWhy A is correct:\n- Varnish ESI allows caching the main page while loading dynamic blocks separately\n- Reduces cache fragmentation\n- Dynamic content loads asynchronously\n- Main page content can be cached longer\n\nWhy others are less optimal:\n- B: Flat catalogs are deprecated\n- C: Addresses symptoms, not root cause\n- D: Diagnostic step, not a solution",
    "codeExample": "<!-- Mark block as ESI in layout XML -->\n<block class=\"Vendor\\Module\\Block\\DynamicContent\" \n       name=\"dynamic.content\"\n       ttl=\"0\">  <!-- ttl=\"0\" = private/dynamic -->\n</block>\n\n// Block must implement IdentityInterface\nclass DynamicContent extends Template implements IdentityInterface\n{\n    public function getIdentities() {\n        return ['dynamic_content_' . $this->getCustomerId()];\n    }\n}",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "performance-optimization",
      "scalability"
    ]
  },
  {
    "id": 13,
    "category": "EAV & Attributes",
    "difficulty": "Hard",
    "question": "An Architect needs to create a product attribute requiring custom validation before saving and custom formatting when displayed. Which EAV model components should be implemented?",
    "options": [
      {
        "id": "A",
        "text": "Backend model for validation, Frontend model for display formatting"
      },
      {
        "id": "B",
        "text": "Source model for validation, Backend model for display formatting"
      },
      {
        "id": "C",
        "text": "Frontend model for validation, Source model for display formatting"
      },
      {
        "id": "D",
        "text": "Backend model for both validation and display formatting"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "EAV attributes use three specialized model types:\n\nBackend Model: Handles data processing during save/load\n- beforeSave() - validation and transformation\n- afterSave() - post-save operations\n- afterLoad() - data processing on load\n\nFrontend Model: Controls how values are displayed\n- getValue() - formats the value for display\n\nSource Model: Provides option values for select/multiselect\n\nWhy A is correct:\nBackend model's validate() handles validation, Frontend model's getValue() handles display formatting.",
    "codeExample": "// Backend Model - for validation\nclass CustomValidation extends AbstractBackend\n{\n    public function validate($object) {\n        $value = $object->getData($this->getAttribute()->getAttributeCode());\n        if (!$this->isValid($value)) {\n            throw new LocalizedException(__('Invalid value'));\n        }\n        return true;\n    }\n}\n\n// Frontend Model - for display\nclass CustomDisplay extends AbstractFrontend\n{\n    public function getValue(DataObject $object) {\n        $value = $object->getData($this->getAttribute()->getAttributeCode());\n        return '<strong>' . htmlspecialchars($value) . '</strong>';\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "eav",
      "catalog-modeling"
    ]
  },
  {
    "id": 14,
    "category": "Multi-Store",
    "difficulty": "Medium",
    "question": "For a multi-language, multi-currency site, which attribute scope should be used for product prices that need different values per website?",
    "options": [
      {
        "id": "A",
        "text": "SCOPE_GLOBAL"
      },
      {
        "id": "B",
        "text": "SCOPE_WEBSITE"
      },
      {
        "id": "C",
        "text": "SCOPE_STORE"
      },
      {
        "id": "D",
        "text": "SCOPE_STOREVIEW"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Product prices typically use SCOPE_WEBSITE for multi-currency setups.\n\nScope levels:\n- GLOBAL: Same value across all websites/stores\n- WEBSITE: Different value per website (currency level)\n- STORE: Different value per store (rarely used for price)\n- STOREVIEW: Different value per store view (language level)\n\nWhy B is correct:\nPrices are tied to currency, and currency is configured at the website level. Each website can have its own base currency and price values.",
    "codeExample": "$eavSetup->addAttribute(Product::ENTITY, 'special_price_b2b', [\n    'type' => 'decimal',\n    'label' => 'B2B Special Price',\n    'input' => 'price',\n    'global' => ScopedAttributeInterface::SCOPE_WEBSITE,  // Website scope\n    'visible' => true,\n    'required' => false,\n]);\n\n// Scopes: SCOPE_GLOBAL=1, SCOPE_WEBSITE=2, SCOPE_STORE=0",
    "examDomain": "Design",
    "objectiveTags": [
      "multi-site",
      "scope-hierarchy"
    ]
  },
  {
    "id": 15,
    "category": "Security",
    "difficulty": "Medium",
    "question": "An Architect needs to implement a custom admin action that modifies sensitive data. Which security measure is required to prevent CSRF attacks?",
    "options": [
      {
        "id": "A",
        "text": "Add 'form_key' parameter validation in the controller"
      },
      {
        "id": "B",
        "text": "Implement custom authentication middleware"
      },
      {
        "id": "C",
        "text": "Use HTTPS for all requests"
      },
      {
        "id": "D",
        "text": "Add IP whitelist in .htaccess"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "Magento's form_key mechanism protects against CSRF attacks.\n\nWhy A is correct:\n- form_key is a unique token generated per session\n- Must be included in all state-changing requests\n- Validated automatically by extending correct base classes\n\nImplementation:\n- Admin controllers should extend \\Magento\\Backend\\App\\Action\n- Use _isAllowed() for ACL checks\n- Form key validation is built-in",
    "codeExample": "class Save extends \\Magento\\Backend\\App\\Action\n{\n    const ADMIN_RESOURCE = 'Vendor_Module::save';\n    \n    public function execute() {\n        // Form key is automatically validated by parent\n        // Manual validation if needed:\n        if (!$this->_formKeyValidator->validate($this->getRequest())) {\n            throw new LocalizedException(__('Invalid form key.'));\n        }\n    }\n    \n    protected function _isAllowed() {\n        return $this->_authorization->isAllowed(self::ADMIN_RESOURCE);\n    }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "security-hardening",
      "secure-coding",
      "compliance"
    ]
  },
  {
    "id": 16,
    "category": "Database",
    "difficulty": "Hard",
    "question": "An Architect needs to create a custom table with a foreign key to catalog_product_entity. Which db_schema approach ensures referential integrity while handling product deletion properly?",
    "options": [
      {
        "id": "A",
        "text": "Use CASCADE for onDelete action"
      },
      {
        "id": "B",
        "text": "Use SET NULL for onDelete action with nullable column"
      },
      {
        "id": "C",
        "text": "Use NO ACTION and handle deletion in observer"
      },
      {
        "id": "D",
        "text": "Skip foreign key and use application-level validation"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "For custom tables referencing products, CASCADE is typically the correct choice.\n\nWhy A is correct:\n- When a product is deleted, related custom data is automatically deleted\n- Maintains referential integrity at database level\n- No orphaned records\n- Standard practice for dependent data\n\nConsiderations:\n- CASCADE: Delete dependent records automatically\n- SET NULL: Keep record but remove reference\n- NO ACTION: Prevent deletion if references exist",
    "codeExample": "<!-- db_schema.xml -->\n<table name=\"vendor_product_custom\" resource=\"default\" engine=\"innodb\">\n    <column xsi:type=\"int\" name=\"entity_id\" nullable=\"false\" identity=\"true\"/>\n    <column xsi:type=\"int\" name=\"product_id\" nullable=\"false\"/>\n    <column xsi:type=\"varchar\" name=\"custom_data\" length=\"255\"/>\n    \n    <constraint xsi:type=\"primary\" referenceId=\"PRIMARY\">\n        <column name=\"entity_id\"/>\n    </constraint>\n    \n    <constraint xsi:type=\"foreign\" referenceId=\"FK_PRODUCT_ID\"\n                table=\"vendor_product_custom\" column=\"product_id\"\n                referenceTable=\"catalog_product_entity\" referenceColumn=\"entity_id\"\n                onDelete=\"CASCADE\"/>\n</table>",
    "examDomain": "Review",
    "objectiveTags": [
      "database-design",
      "query-optimization",
      "data-integrity"
    ]
  },
  {
    "id": 17,
    "category": "Testing",
    "difficulty": "Medium",
    "question": "Which testing framework should be used for testing service contracts and repositories?",
    "options": [
      {
        "id": "A",
        "text": "Unit tests with PHPUnit mocks"
      },
      {
        "id": "B",
        "text": "Integration tests with the Magento testing framework"
      },
      {
        "id": "C",
        "text": "API functional tests with REST/GraphQL"
      },
      {
        "id": "D",
        "text": "MFTF (Magento Functional Testing Framework) tests"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Service contracts and repositories should be tested with Integration tests.\n\nWhy B is correct:\n- Integration tests use real database and Magento infrastructure\n- Test actual DI configuration and preferences\n- Verify repository methods work with real data\n- Test the complete service layer\n\nTest type guidelines:\n- Unit tests: Isolated class logic with mocked dependencies\n- Integration tests: Service contracts, repositories, modules\n- API functional tests: REST/GraphQL endpoint behavior\n- MFTF: UI/browser-based scenarios",
    "codeExample": "class CustomRepositoryTest extends \\PHPUnit\\Framework\\TestCase\n{\n    protected function setUp(): void {\n        $this->objectManager = Bootstrap::getObjectManager();\n        $this->repository = $this->objectManager->get(CustomRepositoryInterface::class);\n    }\n    \n    /**\n     * @magentoDataFixture Vendor_Module::Test/_files/custom_entity.php\n     */\n    public function testGetById() {\n        $entity = $this->repository->getById(1);\n        $this->assertEquals('Test Name', $entity->getName());\n    }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "testing-strategy",
      "integration-tests",
      "mftf"
    ]
  },
  {
    "id": 18,
    "category": "Events & Observers",
    "difficulty": "Medium",
    "question": "When should an Architect recommend using an observer instead of a plugin?",
    "options": [
      {
        "id": "A",
        "text": "When modifying method return values"
      },
      {
        "id": "B",
        "text": "When responding to specific application events dispatched by Magento"
      },
      {
        "id": "C",
        "text": "When preventing a method from executing"
      },
      {
        "id": "D",
        "text": "When modifying method input parameters"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Observers and plugins serve different purposes:\n\nObservers are best for:\n- Responding to dispatched events (event-driven architecture)\n- Multiple unrelated actions after an event\n- Cross-cutting concerns that shouldn't modify core behavior\n\nPlugins are best for:\n- Modifying specific method behavior\n- Changing inputs/outputs of methods\n- Conditional method execution\n\nWhy B is correct:\nObservers listen to specific events and react to them, which is their primary purpose.",
    "codeExample": "// Observer - responds to event\n// events.xml\n<event name=\"sales_order_place_after\">\n    <observer name=\"vendor_notification\" instance=\"Vendor\\Module\\Observer\\OrderPlaceAfter\"/>\n</event>\n\nclass OrderPlaceAfter implements ObserverInterface\n{\n    public function execute(Observer $observer) {\n        $order = $observer->getEvent()->getOrder();\n        $this->sendNotification($order);\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "events-observers",
      "extensibility"
    ]
  },
  {
    "id": 19,
    "category": "Code Architecture",
    "difficulty": "Medium",
    "question": "According to Adobe Commerce best practices, where should business logic be placed?",
    "options": [
      {
        "id": "A",
        "text": "In Controllers"
      },
      {
        "id": "B",
        "text": "In Blocks/ViewModels"
      },
      {
        "id": "C",
        "text": "In Service classes and Models"
      },
      {
        "id": "D",
        "text": "In Helpers"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "Business logic should be encapsulated in Service classes and Models following the Service Contract pattern.\n\nWhy C is correct:\n- Service classes expose business operations through interfaces\n- Models contain entity-specific logic\n- Promotes reusability across REST, GraphQL, and UI\n- Enables proper unit testing\n\nLayer responsibilities:\n- Controllers: Request handling, routing\n- Blocks/ViewModels: Presentation logic only\n- Services/Models: Business logic\n- Helpers: Utility functions (minimal use recommended)",
    "codeExample": "// Service class with business logic\nclass OrderProcessor implements OrderProcessorInterface\n{\n    public function processOrder(OrderInterface $order): ProcessResultInterface {\n        $this->validateOrder($order);\n        $this->calculateTotals($order);\n        return $this->createResult($order);\n    }\n}\n\n// Controller just delegates to service\nclass Process extends Action\n{\n    public function execute() {\n        $order = $this->orderRepository->get($this->getRequest()->getParam('order_id'));\n        $result = $this->orderProcessor->processOrder($order);\n        return $this->resultJson->setData($result->toArray());\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "solid-principles",
      "module-architecture"
    ]
  },
  {
    "id": 20,
    "category": "Cloud Infrastructure",
    "difficulty": "Hard",
    "question": "On Adobe Commerce Cloud, what is the correct way to add environment-specific configuration that should not be committed to the repository?",
    "options": [
      {
        "id": "A",
        "text": "Modify app/etc/env.php directly on the server"
      },
      {
        "id": "B",
        "text": "Use environment variables in the Cloud Console"
      },
      {
        "id": "C",
        "text": "Create a config.local.php file"
      },
      {
        "id": "D",
        "text": "Use .magento.env.yaml for all configurations"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Adobe Commerce Cloud uses environment variables for environment-specific configuration.\n\nWhy B is correct:\n- Environment variables are set in Cloud Console or CLI\n- Not stored in repository\n- Different values per environment (staging, production)\n- Secure storage for sensitive data\n- Override env.php values at runtime\n\nConfiguration hierarchy:\n1. env.php (committed)\n2. .magento.env.yaml (committed)\n3. Environment variables (not committed) - highest priority",
    "codeExample": "# Set environment variable via CLI:\nmagento-cloud variable:set SOME_API_KEY \"secret_value\" --level environment\n\n# Reference in env.php using MAGENTO_DC_ prefix:\n# MAGENTO_DC_SESSION__SAVE=redis\n# Converts to: 'session' => ['save' => 'redis']\n\n# For sensitive data, use Cloud variables:\n# CRYPT_KEY, DATABASE_URL, REDIS_URL\n# These are automatically injected",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "services-configuration"
    ]
  },
  {
    "id": 21,
    "category": "Configuration & XML",
    "difficulty": "Medium",
    "question": "When a module needs to modify layout updates from another module, which approach should an Architect recommend?",
    "options": [
      {
        "id": "A",
        "text": "Override the original layout XML file in app/design"
      },
      {
        "id": "B",
        "text": "Use layout XML with the same handle name to add, remove, or move elements"
      },
      {
        "id": "C",
        "text": "Create a plugin on the Layout\\Merge class"
      },
      {
        "id": "D",
        "text": "Modify the original module's layout file directly"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento's layout system is designed for declarative customization through XML merging.\n\nWhy B is correct:\n- Layout XML files with the same handle are merged automatically\n- Use <referenceBlock> to modify existing blocks\n- Use <move> to relocate elements\n- Use <remove> to hide elements\n- Non-invasive and upgrade-safe\n\nWhy others are incorrect:\n- A: Theme overrides work but module-level changes should use module layout\n- C: Plugins on Layout\\Merge are complex and error-prone\n- D: Never modify core/vendor files directly",
    "codeExample": "<!-- Vendor/Module/view/frontend/layout/catalog_product_view.xml -->\n<page xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <body>\n        <!-- Modify existing block -->\n        <referenceBlock name=\"product.info.details\">\n            <block class=\"Vendor\\Module\\Block\\CustomTab\" name=\"custom.tab\"\n                   template=\"Vendor_Module::product/tab.phtml\"/>\n        </referenceBlock>\n\n        <!-- Move element -->\n        <move element=\"product.info.sku\" destination=\"product.info.main\" after=\"product.info.price\"/>\n\n        <!-- Remove element -->\n        <referenceBlock name=\"catalog.compare.sidebar\" remove=\"true\"/>\n    </body>\n</page>",
    "examDomain": "Review",
    "objectiveTags": [
      "xml-configuration",
      "merge-rules",
      "scope-configuration"
    ]
  },
  {
    "id": 22,
    "category": "Dependency Injection",
    "difficulty": "Hard",
    "question": "An Architect needs to replace a service implementation only for a specific area (adminhtml). Which di.xml configuration approach is correct?",
    "options": [
      {
        "id": "A",
        "text": "Create di.xml in etc/ with area-specific <preference>"
      },
      {
        "id": "B",
        "text": "Create di.xml in etc/adminhtml/ with the <preference> tag"
      },
      {
        "id": "C",
        "text": "Use a plugin with <area> attribute in etc/di.xml"
      },
      {
        "id": "D",
        "text": "Create separate module for adminhtml area only"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento's area-specific configuration allows different implementations per area.\n\nWhy B is correct:\n- Files in etc/adminhtml/ only apply to admin area\n- etc/frontend/ for storefront\n- etc/webapi_rest/ for REST API\n- etc/graphql/ for GraphQL\n- Preference in area-specific di.xml cleanly replaces only for that area\n\nWhy others are incorrect:\n- A: etc/di.xml applies globally to all areas\n- C: Plugins don't have area attribute in di.xml\n- D: Unnecessary complexity when area-specific config exists",
    "codeExample": "<!-- etc/adminhtml/di.xml - Only applies to admin -->\n<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:framework:ObjectManager/etc/config.xsd\">\n    <preference for=\"Vendor\\Module\\Api\\ServiceInterface\"\n                type=\"Vendor\\Module\\Model\\Admin\\Service\"/>\n</config>\n\n<!-- etc/frontend/di.xml - Only applies to storefront -->\n<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:framework:ObjectManager/etc/config.xsd\">\n    <preference for=\"Vendor\\Module\\Api\\ServiceInterface\"\n                type=\"Vendor\\Module\\Model\\Frontend\\Service\"/>\n</config>",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 23,
    "category": "Dependency Injection",
    "difficulty": "Hard",
    "question": "When should an Architect use a Proxy class in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "When the dependency is always used in every method call"
      },
      {
        "id": "B",
        "text": "When a class has expensive constructor dependencies that aren't always needed"
      },
      {
        "id": "C",
        "text": "When implementing the Observer pattern"
      },
      {
        "id": "D",
        "text": "When creating API endpoints"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Proxies implement lazy loading for expensive dependencies.\n\nWhy B is correct:\n- Proxy delays instantiation until first method call\n- Reduces memory/CPU when dependency isn't used\n- Useful in console commands, cron jobs, or conditional logic\n- Auto-generated by Magento's code generation\n\nWhy others are incorrect:\n- A: If always used, Proxy adds overhead without benefit\n- C: Observers use different pattern (event dispatcher)\n- D: API endpoints don't specifically require proxies",
    "codeExample": "<!-- di.xml - Using Proxy for expensive dependency -->\n<type name=\"Vendor\\Module\\Model\\HeavyProcessor\">\n    <arguments>\n        <!-- Proxy delays instantiation of ExpensiveService -->\n        <argument name=\"expensiveService\"\n                  xsi:type=\"object\">Magento\\Catalog\\Model\\Product\\Gallery\\Processor\\Proxy</argument>\n    </arguments>\n</type>\n\n// PHP class receiving the proxy\nclass HeavyProcessor\n{\n    public function __construct(\n        private readonly Processor $expensiveService  // Actually a Proxy\n    ) {}\n\n    public function process($condition)\n    {\n        if ($condition) {\n            // ExpensiveService only instantiated here when actually needed\n            $this->expensiveService->doSomething();\n        }\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 24,
    "category": "Dependency Injection",
    "difficulty": "Medium",
    "question": "What is the purpose of a Virtual Type in Magento 2's dependency injection?",
    "options": [
      {
        "id": "A",
        "text": "To create abstract classes that cannot be instantiated"
      },
      {
        "id": "B",
        "text": "To create a new class alias with different constructor arguments without writing PHP code"
      },
      {
        "id": "C",
        "text": "To implement interfaces without concrete classes"
      },
      {
        "id": "D",
        "text": "To mock classes for unit testing"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Virtual Types allow creating class variations through configuration only.\n\nWhy B is correct:\n- Virtual Type creates a \"named configuration\" of an existing class\n- Allows different argument values without PHP inheritance\n- Useful for creating specialized instances (e.g., different loggers)\n- Reduces PHP code for simple variations\n\nWhy others are incorrect:\n- A: Abstract classes are PHP constructs, not DI configuration\n- C: Interfaces still need concrete implementations\n- D: Testing uses mocks/stubs, not virtual types",
    "codeExample": "<!-- Creating virtual types for different logger channels -->\n<virtualType name=\"Vendor\\Module\\Logger\\DebugLogger\" type=\"Magento\\Framework\\Logger\\Monolog\">\n    <arguments>\n        <argument name=\"name\" xsi:type=\"string\">vendor_debug</argument>\n        <argument name=\"handlers\" xsi:type=\"array\">\n            <item name=\"debug\" xsi:type=\"object\">Vendor\\Module\\Logger\\Handler\\Debug</item>\n        </argument>\n    </arguments>\n</virtualType>\n\n<virtualType name=\"Vendor\\Module\\Logger\\ErrorLogger\" type=\"Magento\\Framework\\Logger\\Monolog\">\n    <arguments>\n        <argument name=\"name\" xsi:type=\"string\">vendor_error</argument>\n        <argument name=\"handlers\" xsi:type=\"array\">\n            <item name=\"error\" xsi:type=\"object\">Vendor\\Module\\Logger\\Handler\\Error</item>\n        </argument>\n    </arguments>\n</virtualType>\n\n<!-- Using the virtual types -->\n<type name=\"Vendor\\Module\\Model\\SomeClass\">\n    <arguments>\n        <argument name=\"logger\" xsi:type=\"object\">Vendor\\Module\\Logger\\DebugLogger</argument>\n    </arguments>\n</type>",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 25,
    "category": "Caching",
    "difficulty": "Hard",
    "question": "A merchant reports that product updates are not immediately visible on the storefront despite clearing the cache. Which cache mechanism is most likely causing this issue?",
    "options": [
      {
        "id": "A",
        "text": "Block HTML Output cache"
      },
      {
        "id": "B",
        "text": "Full Page Cache with cache tags not properly implemented"
      },
      {
        "id": "C",
        "text": "Configuration cache"
      },
      {
        "id": "D",
        "text": "Layout cache"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Full Page Cache with improper cache tag implementation causes stale content.\n\nWhy B is correct:\n- FPC stores entire HTML pages\n- Cache tags link content to entities (products, categories)\n- If block doesn't declare proper identities, FPC won't invalidate\n- Product updates trigger cache invalidation via cache tags\n\nWhy others are incorrect:\n- A: Block cache is for specific blocks, less common issue\n- C: Config cache doesn't affect product data display\n- D: Layout cache affects structure, not content",
    "codeExample": "// Block must implement IdentityInterface for proper FPC invalidation\nclass ProductInfo extends Template implements IdentityInterface\n{\n    public function getIdentities()\n    {\n        // Return cache tags that will trigger invalidation\n        $identities = [];\n        if ($product = $this->getProduct()) {\n            $identities = $product->getIdentities();\n            // Returns: ['cat_p_123', 'cat_p']\n        }\n        return $identities;\n    }\n}\n\n// Product model already implements this:\nclass Product implements IdentityInterface\n{\n    public function getIdentities()\n    {\n        return [self::CACHE_TAG . '_' . $this->getId(), self::CACHE_TAG];\n    }\n}",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "caching-strategy",
      "fpc-varnish",
      "cache-invalidation"
    ]
  },
  {
    "id": 26,
    "category": "Caching",
    "difficulty": "Medium",
    "question": "Which cache type should be cleared after modifying system configuration values programmatically?",
    "options": [
      {
        "id": "A",
        "text": "Full Page Cache only"
      },
      {
        "id": "B",
        "text": "Configuration cache"
      },
      {
        "id": "C",
        "text": "Layout cache"
      },
      {
        "id": "D",
        "text": "All caches must be cleared"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Configuration cache stores merged system configuration.\n\nWhy B is correct:\n- config cache stores compiled system.xml values\n- After programmatic config changes, this cache must be refreshed\n- Use CacheInterface to clean specific cache type\n- Other caches (FPC, layout) may also need clearing depending on what changed\n\nWhy others are incorrect:\n- A: FPC is for page output, not config storage\n- C: Layout cache is for layout XML, not system config\n- D: Clearing all is wasteful when only config changed",
    "codeExample": "// Programmatically clearing config cache after changes\nuse Magento\\Framework\\App\\Cache\\TypeListInterface;\nuse Magento\\Framework\\App\\Cache\\Type\\Config;\n\nclass ConfigUpdater\n{\n    public function __construct(\n        private TypeListInterface $cacheTypeList,\n        private \\Magento\\Framework\\App\\Config\\Storage\\WriterInterface $configWriter\n    ) {}\n\n    public function updateConfig(string $path, string $value): void\n    {\n        $this->configWriter->save($path, $value);\n\n        // Clean config cache\n        $this->cacheTypeList->cleanType(Config::TYPE_IDENTIFIER);\n\n        // If config affects FPC (e.g., store name), also clean FPC\n        // $this->cacheTypeList->cleanType('full_page');\n    }\n}",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "caching-strategy",
      "fpc-varnish",
      "cache-invalidation"
    ]
  },
  {
    "id": 27,
    "category": "JavaScript & Frontend",
    "difficulty": "Medium",
    "question": "How should an Architect add a custom JavaScript module that depends on jQuery in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Add <script> tag directly in the template"
      },
      {
        "id": "B",
        "text": "Define the module in requirejs-config.js with jquery dependency"
      },
      {
        "id": "C",
        "text": "Include jQuery and the script in the <head> section"
      },
      {
        "id": "D",
        "text": "Use PHP to inject JavaScript into the page"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento 2 uses RequireJS for JavaScript module loading and dependency management.\n\nWhy B is correct:\n- requirejs-config.js defines module paths and dependencies\n- jQuery is available as 'jquery' shim\n- Ensures proper load order and dependency resolution\n- Supports bundling and optimization\n\nWhy others are incorrect:\n- A: Bypasses RequireJS, causes load order issues\n- C: Breaks RequireJS optimization and bundling\n- D: Mixing PHP and JS is poor architecture",
    "codeExample": "// requirejs-config.js\nvar config = {\n    map: {\n        '*': {\n            'customModule': 'Vendor_Module/js/custom-module'\n        }\n    },\n    paths: {\n        'customLibrary': 'Vendor_Module/js/lib/custom-library'\n    }\n};\n\n// js/custom-module.js\ndefine([\n    'jquery',\n    'mage/translate',\n    'customLibrary'\n], function($, $t, customLib) {\n    'use strict';\n\n    return function(config, element) {\n        $(element).on('click', function() {\n            customLib.doSomething();\n            alert($t('Translated message'));\n        });\n    };\n});\n\n// Usage in template with data-mage-init\n<div data-mage-init='{\"customModule\": {\"option\": \"value\"}}'></div>",
    "examDomain": "Design",
    "objectiveTags": [
      "frontend-architecture",
      "ui-components"
    ]
  },
  {
    "id": 28,
    "category": "JavaScript & Frontend",
    "difficulty": "Hard",
    "question": "An Architect needs to customize the checkout address validation in Magento 2. Which approach follows best practices for UI Component customization?",
    "options": [
      {
        "id": "A",
        "text": "Override the checkout_index_index.xml layout completely"
      },
      {
        "id": "B",
        "text": "Create a mixin for the address validation JS component"
      },
      {
        "id": "C",
        "text": "Modify the vendor JavaScript file directly"
      },
      {
        "id": "D",
        "text": "Replace the entire checkout module with a custom one"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Mixins allow extending JavaScript components without full replacement.\n\nWhy B is correct:\n- Mixins extend existing functionality non-invasively\n- Multiple modules can add mixins to same component\n- Preserved during upgrades\n- Minimal code duplication\n\nWhy others are incorrect:\n- A: Full layout override is heavy-handed for validation change\n- C: Never modify vendor files\n- D: Extreme overkill for validation customization",
    "codeExample": "// requirejs-config.js\nvar config = {\n    config: {\n        mixins: {\n            'Magento_Checkout/js/model/address-converter': {\n                'Vendor_Module/js/model/address-converter-mixin': true\n            }\n        }\n    }\n};\n\n// js/model/address-converter-mixin.js\ndefine([], function() {\n    'use strict';\n\n    return function(addressConverter) {\n        // Store original function\n        var originalFormAddressDataToQuoteAddress = addressConverter.formAddressDataToQuoteAddress;\n\n        // Extend with custom validation\n        addressConverter.formAddressDataToQuoteAddress = function(formData) {\n            // Custom validation logic\n            if (!this.validateCustomField(formData)) {\n                throw new Error('Custom validation failed');\n            }\n\n            // Call original\n            return originalFormAddressDataToQuoteAddress.call(this, formData);\n        };\n\n        addressConverter.validateCustomField = function(formData) {\n            // Custom validation\n            return true;\n        };\n\n        return addressConverter;\n    };\n});",
    "examDomain": "Design",
    "objectiveTags": [
      "frontend-architecture",
      "ui-components"
    ]
  },
  {
    "id": 29,
    "category": "Checkout & Orders",
    "difficulty": "Hard",
    "question": "When implementing a custom total collector for the shopping cart, which class should be extended and which configuration file declares it?",
    "options": [
      {
        "id": "A",
        "text": "Extend AbstractTotal and configure in sales.xml"
      },
      {
        "id": "B",
        "text": "Extend Quote\\Address\\Total\\AbstractTotal and configure in sales.xml"
      },
      {
        "id": "C",
        "text": "Implement TotalInterface and configure in di.xml"
      },
      {
        "id": "D",
        "text": "Extend Order\\Total\\AbstractTotal and configure in checkout.xml"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Quote totals are collected by extending AbstractTotal and declaring in sales.xml.\n\nWhy B is correct:\n- Quote\\Address\\Total\\AbstractTotal is the base for quote totals\n- sales.xml defines collectors and their sort order\n- Totals are collected in sequence based on sort_order\n- Supports both quote and order totals configuration\n\nWhy others are incorrect:\n- A: Need specific Quote\\Address\\Total namespace\n- C: No TotalInterface - uses abstract class pattern\n- D: Order totals are separate; checkout.xml doesn't exist for this",
    "codeExample": "<!-- etc/sales.xml -->\n<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:module:Magento_Sales:etc/sales.xsd\">\n    <section name=\"quote\">\n        <group name=\"totals\">\n            <item name=\"custom_fee\" instance=\"Vendor\\Module\\Model\\Total\\CustomFee\" sort_order=\"450\"/>\n        </group>\n    </section>\n</config>\n\n// Model/Total/CustomFee.php\nclass CustomFee extends \\Magento\\Quote\\Model\\Quote\\Address\\Total\\AbstractTotal\n{\n    public function collect(\n        Quote $quote,\n        ShippingAssignmentInterface $shippingAssignment,\n        Total $total\n    ) {\n        parent::collect($quote, $shippingAssignment, $total);\n\n        $fee = 5.00; // Calculate your fee\n        $total->setTotalAmount('custom_fee', $fee);\n        $total->setBaseTotalAmount('custom_fee', $fee);\n\n        return $this;\n    }\n\n    public function fetch(Quote $quote, Total $total)\n    {\n        return [\n            'code' => 'custom_fee',\n            'title' => __('Custom Fee'),\n            'value' => $total->getTotalAmount('custom_fee')\n        ];\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "checkout-architecture",
      "order-lifecycle"
    ]
  },
  {
    "id": 30,
    "category": "Checkout & Orders",
    "difficulty": "Medium",
    "question": "What is the correct way to add a custom step to the Magento 2 checkout process?",
    "options": [
      {
        "id": "A",
        "text": "Modify the checkout_index_index.xml layout file"
      },
      {
        "id": "B",
        "text": "Create a new controller and redirect from the standard checkout"
      },
      {
        "id": "C",
        "text": "Add a UI Component in checkout_index_index.xml and create the corresponding JS component"
      },
      {
        "id": "D",
        "text": "Override the Onepage controller"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "Checkout steps in Magento 2 are UI Components configured in layout XML.\n\nWhy C is correct:\n- Checkout is built with UI Components (Knockout.js based)\n- Steps are defined in checkout_index_index.xml under checkout component\n- Each step has a JS component handling logic and a template for UI\n- Allows adding steps without modifying core\n\nWhy others are incorrect:\n- A: Modifying isn't wrong but must add UI Component specifically\n- B: Redirection breaks the SPA checkout flow\n- D: Checkout uses UI Components, not traditional controllers",
    "codeExample": "<!-- checkout_index_index.xml -->\n<page layout=\"checkout\">\n    <body>\n        <referenceBlock name=\"checkout.root\">\n            <arguments>\n                <argument name=\"jsLayout\" xsi:type=\"array\">\n                    <item name=\"components\" xsi:type=\"array\">\n                        <item name=\"checkout\" xsi:type=\"array\">\n                            <item name=\"children\" xsi:type=\"array\">\n                                <item name=\"steps\" xsi:type=\"array\">\n                                    <item name=\"children\" xsi:type=\"array\">\n                                        <item name=\"custom-step\" xsi:type=\"array\">\n                                            <item name=\"component\" xsi:type=\"string\">Vendor_Module/js/view/custom-step</item>\n                                            <item name=\"sortOrder\" xsi:type=\"string\">1</item>\n                                            <item name=\"children\" xsi:type=\"array\">\n                                                <!-- step children -->\n                                            </item>\n                                        </item>\n                                    </item>\n                                </item>\n                            </item>\n                        </item>\n                    </item>\n                </argument>\n            </arguments>\n        </referenceBlock>\n    </body>\n</page>",
    "examDomain": "Design",
    "objectiveTags": [
      "checkout-architecture",
      "order-lifecycle"
    ]
  },
  {
    "id": 31,
    "category": "Order Management",
    "difficulty": "Medium",
    "question": "An Architect needs to add custom logic when an order transitions from 'pending' to 'processing' state. What is the recommended approach?",
    "options": [
      {
        "id": "A",
        "text": "Create a plugin on the Order save method"
      },
      {
        "id": "B",
        "text": "Create an observer for the sales_order_state_change_before event"
      },
      {
        "id": "C",
        "text": "Modify the Order model directly"
      },
      {
        "id": "D",
        "text": "Override the Order resource model"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento dispatches events for order state changes, making observers ideal.\n\nWhy B is correct:\n- sales_order_state_change_before fires when state changes\n- Observer can access old and new state\n- Non-invasive approach\n- Multiple modules can observe same event\n\nWhy others are incorrect:\n- A: Plugin on save doesn't specifically target state changes\n- C/D: Never modify core classes directly",
    "codeExample": "<!-- events.xml -->\n<event name=\"sales_order_state_change_before\">\n    <observer name=\"vendor_order_state_change\"\n              instance=\"Vendor\\Module\\Observer\\OrderStateChange\"/>\n</event>\n\n// Observer/OrderStateChange.php\nclass OrderStateChange implements ObserverInterface\n{\n    public function execute(Observer $observer)\n    {\n        $order = $observer->getEvent()->getOrder();\n        $oldState = $order->getOrigData('state');\n        $newState = $order->getState();\n\n        if ($oldState === Order::STATE_PENDING_PAYMENT\n            && $newState === Order::STATE_PROCESSING) {\n            // Custom logic for pending -> processing\n            $this->processOrderTransition($order);\n        }\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "order-lifecycle",
      "business-processes"
    ]
  },
  {
    "id": 32,
    "category": "Payment Integration",
    "difficulty": "Hard",
    "question": "When implementing a custom payment method that requires redirect to external gateway, which interface must be implemented?",
    "options": [
      {
        "id": "A",
        "text": "Magento\\Payment\\Model\\MethodInterface"
      },
      {
        "id": "B",
        "text": "Magento\\Payment\\Gateway\\ConfigInterface"
      },
      {
        "id": "C",
        "text": "Magento\\Checkout\\Model\\ConfigProviderInterface and payment gateway facade"
      },
      {
        "id": "D",
        "text": "Magento\\Payment\\Model\\Method\\AbstractMethod"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "Payment methods in Magento 2 use the Payment Gateway framework with config providers.\n\nWhy C is correct:\n- ConfigProviderInterface provides checkout config to JS\n- Payment Gateway facade handles payment operations\n- Supports redirect flow with proper configuration\n- Modern approach replacing deprecated AbstractMethod\n\nWhy others are incorrect:\n- A: MethodInterface is legacy, prefer Gateway\n- B: ConfigInterface is for gateway config, not the full method\n- D: AbstractMethod is deprecated in favor of Gateway",
    "codeExample": "// ConfigProvider for checkout JS\nclass ConfigProvider implements ConfigProviderInterface\n{\n    public function getConfig()\n    {\n        return [\n            'payment' => [\n                'custom_gateway' => [\n                    'redirectUrl' => $this->urlBuilder->getUrl('custom/payment/redirect'),\n                    'isActive' => $this->config->isActive()\n                ]\n            ]\n        ];\n    }\n}\n\n// payment.xml facade configuration\n<virtualType name=\"CustomPaymentFacade\" type=\"Magento\\Payment\\Model\\Method\\Adapter\">\n    <arguments>\n        <argument name=\"code\" xsi:type=\"const\">Vendor\\Module\\Model\\Ui\\ConfigProvider::CODE</argument>\n        <argument name=\"formBlockType\" xsi:type=\"string\">Magento\\Payment\\Block\\Form</argument>\n        <argument name=\"infoBlockType\" xsi:type=\"string\">Vendor\\Module\\Block\\Info</argument>\n        <argument name=\"valueHandlerPool\" xsi:type=\"object\">CustomPaymentValueHandlerPool</argument>\n        <argument name=\"commandPool\" xsi:type=\"object\">CustomPaymentCommandPool</argument>\n    </arguments>\n</virtualType>",
    "examDomain": "Design",
    "objectiveTags": [
      "payment-gateway",
      "checkout-architecture"
    ]
  },
  {
    "id": 33,
    "category": "Shipping",
    "difficulty": "Medium",
    "question": "Which class must be extended to create a custom shipping carrier in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Magento\\Shipping\\Model\\Carrier\\AbstractCarrier"
      },
      {
        "id": "B",
        "text": "Magento\\Quote\\Model\\Quote\\Address\\RateResult\\Method"
      },
      {
        "id": "C",
        "text": "Magento\\Shipping\\Model\\Rate\\Result"
      },
      {
        "id": "D",
        "text": "Magento\\Framework\\DataObject"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "Custom shipping carriers extend AbstractCarrier and implement CarrierInterface.\n\nWhy A is correct:\n- AbstractCarrier provides base shipping carrier functionality\n- Requires implementing collectRates() method\n- Must also implement CarrierInterface\n- Handles configuration, tracking, and rate calculation\n\nWhy others are incorrect:\n- B: Method is a rate result object, not carrier\n- C: Result is collection of rate methods\n- D: DataObject is too generic",
    "codeExample": "class CustomCarrier extends AbstractCarrier implements CarrierInterface\n{\n    protected $_code = 'customcarrier';\n\n    public function collectRates(RateRequest $request)\n    {\n        if (!$this->getConfigFlag('active')) {\n            return false;\n        }\n\n        $result = $this->_rateResultFactory->create();\n        $method = $this->_rateMethodFactory->create();\n\n        $method->setCarrier($this->_code);\n        $method->setCarrierTitle($this->getConfigData('title'));\n        $method->setMethod('standard');\n        $method->setMethodTitle('Standard Delivery');\n        $method->setPrice($this->getConfigData('price'));\n        $method->setCost($this->getConfigData('price'));\n\n        $result->append($method);\n        return $result;\n    }\n\n    public function getAllowedMethods()\n    {\n        return ['standard' => 'Standard Delivery'];\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "shipping-rates",
      "fulfillment"
    ]
  },
  {
    "id": 34,
    "category": "API & Web Services",
    "difficulty": "Hard",
    "question": "When creating a custom REST API endpoint that requires customer authentication, which resource should be specified in webapi.xml?",
    "options": [
      {
        "id": "A",
        "text": "anonymous"
      },
      {
        "id": "B",
        "text": "self"
      },
      {
        "id": "C",
        "text": "Magento_Customer::customer"
      },
      {
        "id": "D",
        "text": "Magento_Backend::admin"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "The 'self' resource allows authenticated customers to access their own data.\n\nWhy B is correct:\n- 'self' is a special resource for customer-specific endpoints\n- Ensures customer can only access their own data\n- Requires valid customer token\n- Maps %customer_id% placeholder to authenticated customer\n\nWhy others are incorrect:\n- A: anonymous allows unauthenticated access\n- C: This is admin ACL resource for managing customers\n- D: This is for admin authentication, not customers",
    "codeExample": "<!-- webapi.xml -->\n<routes xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:module:Magento_Webapi:etc/webapi.xsd\">\n\n    <!-- Customer-authenticated endpoint using 'self' -->\n    <route url=\"/V1/custom/customer/orders\" method=\"GET\">\n        <service class=\"Vendor\\Module\\Api\\CustomerOrderInterface\" method=\"getList\"/>\n        <resources>\n            <resource ref=\"self\"/>\n        </resources>\n        <data>\n            <parameter name=\"customerId\" force=\"true\">%customer_id%</parameter>\n        </data>\n    </route>\n\n    <!-- Public endpoint -->\n    <route url=\"/V1/custom/public/info\" method=\"GET\">\n        <service class=\"Vendor\\Module\\Api\\PublicInterface\" method=\"getInfo\"/>\n        <resources>\n            <resource ref=\"anonymous\"/>\n        </resources>\n    </route>\n</routes>",
    "examDomain": "Design",
    "objectiveTags": [
      "integration-patterns",
      "api-design"
    ]
  },
  {
    "id": 35,
    "category": "API & Web Services",
    "difficulty": "Medium",
    "question": "What annotation is required on a repository interface method for it to be exposed via REST API?",
    "options": [
      {
        "id": "A",
        "text": "@api"
      },
      {
        "id": "B",
        "text": "@webapi"
      },
      {
        "id": "C",
        "text": "@param and @return with proper type definitions"
      },
      {
        "id": "D",
        "text": "@rest"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "REST API relies on @param and @return docblock annotations for type information.\n\nWhy C is correct:\n- Magento uses reflection to read docblock annotations\n- @param defines input types for automatic deserialization\n- @return defines output type for serialization\n- Types must be fully qualified or use data interfaces\n\nWhy others are incorrect:\n- A: @api marks as public API but doesn't enable REST\n- B: @webapi doesn't exist\n- D: @rest doesn't exist",
    "codeExample": "/**\n * @api\n */\ninterface ProductCustomRepositoryInterface\n{\n    /**\n     * Get product by SKU\n     *\n     * @param string $sku\n     * @return \\Vendor\\Module\\Api\\Data\\ProductCustomInterface\n     * @throws \\Magento\\Framework\\Exception\\NoSuchEntityException\n     */\n    public function getBySku($sku);\n\n    /**\n     * Save product custom data\n     *\n     * @param \\Vendor\\Module\\Api\\Data\\ProductCustomInterface $product\n     * @return \\Vendor\\Module\\Api\\Data\\ProductCustomInterface\n     * @throws \\Magento\\Framework\\Exception\\CouldNotSaveException\n     */\n    public function save(ProductCustomInterface $product);\n\n    /**\n     * Get list with search criteria\n     *\n     * @param \\Magento\\Framework\\Api\\SearchCriteriaInterface $searchCriteria\n     * @return \\Vendor\\Module\\Api\\Data\\ProductCustomSearchResultInterface\n     */\n    public function getList(SearchCriteriaInterface $searchCriteria);\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "integration-patterns",
      "api-design"
    ]
  },
  {
    "id": 36,
    "category": "Cron & Scheduling",
    "difficulty": "Medium",
    "question": "What is the correct way to configure a cron job that runs every 5 minutes in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Add cron expression in di.xml"
      },
      {
        "id": "B",
        "text": "Create crontab.xml with group and job definition"
      },
      {
        "id": "C",
        "text": "Configure in system.xml under cron section"
      },
      {
        "id": "D",
        "text": "Define in config.xml under crontab node"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Cron jobs are defined in crontab.xml with group and schedule configuration.\n\nWhy B is correct:\n- crontab.xml is the dedicated file for cron configuration\n- Groups allow organizing related jobs\n- Schedule uses standard cron expression syntax\n- Instance specifies the class with execute() method\n\nWhy others are incorrect:\n- A: di.xml is for dependency injection\n- C: system.xml is for admin config fields\n- D: Magento 2 uses crontab.xml, not config.xml",
    "codeExample": "<!-- etc/crontab.xml -->\n<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:module:Magento_Cron:etc/crontab.xsd\">\n    <group id=\"default\">\n        <job name=\"vendor_module_sync\" instance=\"Vendor\\Module\\Cron\\SyncData\" method=\"execute\">\n            <schedule>*/5 * * * *</schedule>  <!-- Every 5 minutes -->\n        </job>\n    </group>\n\n    <!-- Custom group for heavy jobs -->\n    <group id=\"vendor_heavy_jobs\">\n        <job name=\"vendor_module_import\" instance=\"Vendor\\Module\\Cron\\ImportData\" method=\"execute\">\n            <schedule>0 2 * * *</schedule>  <!-- Daily at 2 AM -->\n        </job>\n    </group>\n</config>\n\n// Cron/SyncData.php\nclass SyncData\n{\n    public function execute()\n    {\n        // Cron job logic\n        $this->logger->info('Running sync cron job');\n        $this->syncService->synchronize();\n    }\n}",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cron",
      "operational-reliability"
    ]
  },
  {
    "id": 37,
    "category": "Import & Export",
    "difficulty": "Hard",
    "question": "When implementing a custom import entity type, which interface must the import model implement?",
    "options": [
      {
        "id": "A",
        "text": "Magento\\ImportExport\\Model\\Import\\EntityInterface"
      },
      {
        "id": "B",
        "text": "Magento\\ImportExport\\Model\\Import\\Entity\\AbstractEntity"
      },
      {
        "id": "C",
        "text": "Magento\\ImportExport\\Model\\ImportInterface"
      },
      {
        "id": "D",
        "text": "Magento\\Framework\\DataObject\\IdentityInterface"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Custom import entities extend AbstractEntity which provides the import framework.\n\nWhy B is correct:\n- AbstractEntity provides base import functionality\n- Handles validation, data processing, and behavior modes\n- Must implement _importData() method\n- Supports add/update/delete behaviors\n\nWhy others are incorrect:\n- A: EntityInterface doesn't exist in this context\n- C: ImportInterface is for the main import model\n- D: IdentityInterface is for cache tags",
    "codeExample": "// Model/Import/CustomEntity.php\nclass CustomEntity extends \\Magento\\ImportExport\\Model\\Import\\Entity\\AbstractEntity\n{\n    const ENTITY_CODE = 'custom_entity';\n\n    protected function _importData()\n    {\n        while ($bunch = $this->_dataSourceModel->getNextBunch()) {\n            foreach ($bunch as $rowNum => $rowData) {\n                if (!$this->validateRow($rowData, $rowNum)) {\n                    continue;\n                }\n\n                if ($this->getErrorAggregator()->hasToBeTerminated()) {\n                    $this->getErrorAggregator()->addRowToSkip($rowNum);\n                    continue;\n                }\n\n                $this->saveEntity($rowData);\n            }\n        }\n        return true;\n    }\n\n    public function getEntityTypeCode()\n    {\n        return self::ENTITY_CODE;\n    }\n\n    public function validateRow(array $rowData, $rowNum)\n    {\n        // Validation logic\n        return true;\n    }\n}",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "data-migration",
      "bulk-operations"
    ]
  },
  {
    "id": 38,
    "category": "Database",
    "difficulty": "Hard",
    "question": "In Magento 2.3+, what is the recommended way to add a new column to an existing table?",
    "options": [
      {
        "id": "A",
        "text": "Create an InstallSchema script"
      },
      {
        "id": "B",
        "text": "Create an UpgradeSchema script with version check"
      },
      {
        "id": "C",
        "text": "Modify db_schema.xml and generate whitelist"
      },
      {
        "id": "D",
        "text": "Run ALTER TABLE SQL directly"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "Declarative Schema (db_schema.xml) is the modern approach for database changes.\n\nWhy C is correct:\n- db_schema.xml declares desired table structure\n- Whitelist (db_schema_whitelist.json) tracks allowed changes\n- System automatically generates migration SQL\n- Supports rollback and version management\n\nWhy others are incorrect:\n- A/B: Install/UpgradeSchema are legacy approaches\n- D: Direct SQL bypasses Magento's schema management",
    "codeExample": "<!-- db_schema.xml - Add column to existing table -->\n<schema xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:framework:Setup/Declaration/Schema/etc/schema.xsd\">\n\n    <table name=\"sales_order\" resource=\"sales\">\n        <!-- New column -->\n        <column xsi:type=\"varchar\" name=\"custom_field\" nullable=\"true\" length=\"255\"\n                comment=\"Custom Order Field\"/>\n    </table>\n</schema>\n\n<!-- Generate whitelist after adding column -->\n# bin/magento setup:db-declaration:generate-whitelist --module-name=Vendor_Module\n\n<!-- db_schema_whitelist.json (auto-generated) -->\n{\n    \"sales_order\": {\n        \"column\": {\n            \"custom_field\": true\n        }\n    }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "database-design",
      "query-optimization",
      "data-integrity"
    ]
  },
  {
    "id": 39,
    "category": "Database",
    "difficulty": "Medium",
    "question": "What is the purpose of Data Patches in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "To modify database schema structure"
      },
      {
        "id": "B",
        "text": "To add or modify data in the database (seed data, configuration)"
      },
      {
        "id": "C",
        "text": "To fix bugs in PHP code"
      },
      {
        "id": "D",
        "text": "To apply security patches"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Data Patches insert or modify data, separate from schema changes.\n\nWhy B is correct:\n- Data Patches populate initial data\n- Used for default configuration, attributes, CMS content\n- Run once and tracked in patch_list table\n- Implement DataPatchInterface\n\nWhy others are incorrect:\n- A: Schema changes use db_schema.xml or SchemaPatchInterface\n- C: Code bugs fixed in PHP files, not patches\n- D: Security patches are separate Composer packages",
    "codeExample": "// Setup/Patch/Data/AddCustomAttribute.php\nclass AddCustomAttribute implements DataPatchInterface, PatchRevertableInterface\n{\n    public function apply()\n    {\n        $this->moduleDataSetup->startSetup();\n\n        $this->eavSetup->addAttribute(\n            Product::ENTITY,\n            'custom_attribute',\n            [\n                'type' => 'varchar',\n                'label' => 'Custom Attribute',\n                'input' => 'text',\n                'required' => false,\n                'visible' => true,\n                'user_defined' => true,\n                'global' => ScopedAttributeInterface::SCOPE_STORE,\n            ]\n        );\n\n        $this->moduleDataSetup->endSetup();\n    }\n\n    public function revert()\n    {\n        $this->eavSetup->removeAttribute(Product::ENTITY, 'custom_attribute');\n    }\n\n    public static function getDependencies()\n    {\n        return [];\n    }\n\n    public function getAliases()\n    {\n        return [];\n    }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "database-design",
      "query-optimization",
      "data-integrity"
    ]
  },
  {
    "id": 40,
    "category": "Elasticsearch",
    "difficulty": "Hard",
    "question": "An Architect needs to add a custom product attribute to Elasticsearch index for searching. Which approach is correct?",
    "options": [
      {
        "id": "A",
        "text": "Modify the Elasticsearch index mapping directly"
      },
      {
        "id": "B",
        "text": "Create attribute with 'searchable' = true and reindex"
      },
      {
        "id": "C",
        "text": "Create a plugin on Elasticsearch DataMapper"
      },
      {
        "id": "D",
        "text": "Configure in elasticsearch.xml"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Product attributes with searchable=true are automatically indexed in Elasticsearch.\n\nWhy B is correct:\n- Attribute configuration controls indexing behavior\n- 'searchable' flag adds to search index\n- 'visible_in_advanced_search' for advanced search form\n- Reindexing updates Elasticsearch mappings\n\nWhy others are incorrect:\n- A: Mappings are generated from attribute config\n- C: Plugins are for custom transformation, not basic indexing\n- D: elasticsearch.xml doesn't exist in this form",
    "codeExample": "// Adding searchable attribute via Data Patch\n$this->eavSetup->addAttribute(\n    Product::ENTITY,\n    'searchable_custom',\n    [\n        'type' => 'varchar',\n        'label' => 'Searchable Custom',\n        'input' => 'text',\n        'required' => false,\n        'searchable' => true,                    // Adds to search index\n        'visible_in_advanced_search' => true,    // Shows in advanced search\n        'filterable' => false,\n        'filterable_in_search' => false,\n        'used_for_sort_by' => false,\n        'global' => ScopedAttributeInterface::SCOPE_STORE,\n    ]\n);\n\n// After adding, reindex:\n// bin/magento indexer:reindex catalogsearch_fulltext\n\n// For custom transformation, use DataProvider plugin:\nclass SearchDataProvider\n{\n    public function afterGetSearchData($subject, $result, $productId, $storeId)\n    {\n        // Add custom data to search document\n        $result['custom_computed_field'] = $this->computeValue($productId);\n        return $result;\n    }\n}",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "search-architecture",
      "catalog-performance"
    ]
  },
  {
    "id": 41,
    "category": "Admin Customization",
    "difficulty": "Medium",
    "question": "What is the correct way to add a new menu item to the Magento Admin panel?",
    "options": [
      {
        "id": "A",
        "text": "Create adminhtml/menu.xml with parent reference"
      },
      {
        "id": "B",
        "text": "Add item in system.xml under menu section"
      },
      {
        "id": "C",
        "text": "Create etc/menu.xml with item definition"
      },
      {
        "id": "D",
        "text": "Modify core admin menu configuration"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "Admin menu items are defined in etc/menu.xml.\n\nWhy C is correct:\n- etc/menu.xml is the configuration file for admin menu\n- Items reference parent for positioning\n- ACL resource controls access\n- Action attribute links to controller\n\nWhy others are incorrect:\n- A: Not in adminhtml/ folder - it's etc/menu.xml\n- B: system.xml is for configuration fields\n- D: Never modify core files",
    "codeExample": "<!-- etc/menu.xml -->\n<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:module:Magento_Backend:etc/menu.xsd\">\n    <menu>\n        <!-- Top-level menu -->\n        <add id=\"Vendor_Module::main_menu\"\n             title=\"Custom Module\"\n             module=\"Vendor_Module\"\n             sortOrder=\"100\"\n             resource=\"Vendor_Module::main\"/>\n\n        <!-- Submenu item -->\n        <add id=\"Vendor_Module::manage\"\n             title=\"Manage Items\"\n             module=\"Vendor_Module\"\n             sortOrder=\"10\"\n             parent=\"Vendor_Module::main_menu\"\n             action=\"custommodule/item/index\"\n             resource=\"Vendor_Module::manage\"/>\n\n        <!-- Under existing menu (e.g., Catalog) -->\n        <add id=\"Vendor_Module::catalog_custom\"\n             title=\"Custom Catalog Feature\"\n             module=\"Vendor_Module\"\n             sortOrder=\"100\"\n             parent=\"Magento_Catalog::catalog\"\n             action=\"custommodule/catalog/custom\"\n             resource=\"Vendor_Module::catalog_custom\"/>\n    </menu>\n</config>",
    "examDomain": "Design",
    "objectiveTags": [
      "admin-ui",
      "acl",
      "ui-components"
    ]
  },
  {
    "id": 42,
    "category": "Admin Customization",
    "difficulty": "Hard",
    "question": "When creating an admin grid using UI Components, which XML file defines the grid configuration?",
    "options": [
      {
        "id": "A",
        "text": "layout/[handle]_index_index.xml"
      },
      {
        "id": "B",
        "text": "ui_component/[listing_name].xml"
      },
      {
        "id": "C",
        "text": "etc/adminhtml/grid.xml"
      },
      {
        "id": "D",
        "text": "view/adminhtml/templates/grid.phtml"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "UI Component grids are defined in view/adminhtml/ui_component/[name].xml.\n\nWhy B is correct:\n- UI Components are in view/[area]/ui_component/\n- Grid listing name matches layout reference\n- Defines columns, filters, mass actions, data source\n- Uses declarative XML structure\n\nWhy others are incorrect:\n- A: Layout references UI Component, doesn't define it\n- C: grid.xml doesn't exist in this pattern\n- D: Templates are for rendering, not configuration",
    "codeExample": "<!-- view/adminhtml/ui_component/vendor_items_listing.xml -->\n<listing xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:noNamespaceSchemaLocation=\"urn:magento:module:Magento_Ui:etc/ui_configuration.xsd\">\n    <argument name=\"data\" xsi:type=\"array\">\n        <item name=\"js_config\" xsi:type=\"array\">\n            <item name=\"provider\" xsi:type=\"string\">vendor_items_listing.vendor_items_listing_data_source</item>\n        </item>\n    </argument>\n\n    <dataSource name=\"vendor_items_listing_data_source\" component=\"Magento_Ui/js/grid/provider\">\n        <argument name=\"dataProvider\" xsi:type=\"configurableObject\">\n            <argument name=\"class\" xsi:type=\"string\">Magento\\Framework\\View\\Element\\UiComponent\\DataProvider\\DataProvider</argument>\n            <argument name=\"name\" xsi:type=\"string\">vendor_items_listing_data_source</argument>\n            <argument name=\"primaryFieldName\" xsi:type=\"string\">entity_id</argument>\n            <argument name=\"requestFieldName\" xsi:type=\"string\">id</argument>\n        </argument>\n    </dataSource>\n\n    <listingToolbar name=\"listing_top\">\n        <massaction name=\"listing_massaction\">\n            <action name=\"delete\">\n                <argument name=\"data\" xsi:type=\"array\">\n                    <item name=\"config\" xsi:type=\"array\">\n                        <item name=\"type\" xsi:type=\"string\">delete</item>\n                        <item name=\"label\" xsi:type=\"string\" translate=\"true\">Delete</item>\n                        <item name=\"url\" xsi:type=\"url\" path=\"*/*/massDelete\"/>\n                    </item>\n                </argument>\n            </action>\n        </massaction>\n    </listingToolbar>\n\n    <columns name=\"vendor_items_columns\">\n        <selectionsColumn name=\"ids\">\n            <argument name=\"data\" xsi:type=\"array\">\n                <item name=\"config\" xsi:type=\"array\">\n                    <item name=\"indexField\" xsi:type=\"string\">entity_id</item>\n                </item>\n            </argument>\n        </selectionsColumn>\n        <column name=\"entity_id\">\n            <argument name=\"data\" xsi:type=\"array\">\n                <item name=\"config\" xsi:type=\"array\">\n                    <item name=\"filter\" xsi:type=\"string\">textRange</item>\n                    <item name=\"label\" xsi:type=\"string\" translate=\"true\">ID</item>\n                </item>\n            </argument>\n        </column>\n    </columns>\n</listing>",
    "examDomain": "Design",
    "objectiveTags": [
      "admin-ui",
      "acl",
      "ui-components"
    ]
  },
  {
    "id": 43,
    "category": "Extension Attributes",
    "difficulty": "Hard",
    "question": "Which file is used to declare extension attributes for a data interface in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "di.xml"
      },
      {
        "id": "B",
        "text": "extension_attributes.xml"
      },
      {
        "id": "C",
        "text": "webapi.xml"
      },
      {
        "id": "D",
        "text": "data_interface.xml"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Extension attributes are declared in etc/extension_attributes.xml.\n\nWhy B is correct:\n- extension_attributes.xml defines additional attributes for data interfaces\n- Generates ExtensionInterface automatically\n- Allows extending core interfaces without modification\n- Preserved during API serialization\n\nWhy others are incorrect:\n- A: di.xml is for dependency injection\n- C: webapi.xml is for API routes\n- D: data_interface.xml doesn't exist",
    "codeExample": "<!-- etc/extension_attributes.xml -->\n<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:framework:Api/etc/extension_attributes.xsd\">\n\n    <!-- Add custom attribute to Product -->\n    <extension_attributes for=\"Magento\\Catalog\\Api\\Data\\ProductInterface\">\n        <attribute code=\"custom_warranty\" type=\"string\"/>\n        <attribute code=\"custom_options\" type=\"Vendor\\Module\\Api\\Data\\CustomOptionInterface[]\"/>\n    </extension_attributes>\n\n    <!-- Add attribute to Order -->\n    <extension_attributes for=\"Magento\\Sales\\Api\\Data\\OrderInterface\">\n        <attribute code=\"delivery_instructions\" type=\"string\"/>\n    </extension_attributes>\n</config>\n\n// Usage in code:\n$product->getExtensionAttributes()->setCustomWarranty('2 years');\n$warranty = $product->getExtensionAttributes()->getCustomWarranty();\n\n// To persist, add plugin on repository save method:\npublic function afterSave(ProductRepositoryInterface $subject, ProductInterface $product)\n{\n    $extensionAttributes = $product->getExtensionAttributes();\n    if ($extensionAttributes && $extensionAttributes->getCustomWarranty()) {\n        $this->saveWarranty($product->getId(), $extensionAttributes->getCustomWarranty());\n    }\n    return $product;\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "extension-attributes",
      "service-contracts"
    ]
  },
  {
    "id": 44,
    "category": "B2B Features",
    "difficulty": "Hard",
    "question": "In Adobe Commerce B2B, how should an Architect implement custom approval rules for company purchase orders?",
    "options": [
      {
        "id": "A",
        "text": "Override the PurchaseOrder model"
      },
      {
        "id": "B",
        "text": "Create a plugin on the approval workflow"
      },
      {
        "id": "C",
        "text": "Implement ApprovalRuleInterface and configure via admin"
      },
      {
        "id": "D",
        "text": "Modify the company permissions directly"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "B2B purchase order approvals use ApprovalRuleInterface for custom rules.\n\nWhy C is correct:\n- ApprovalRuleInterface defines custom approval conditions\n- Rules are configurable by company admins\n- Supports amount thresholds, roles, and custom conditions\n- Integrates with B2B approval workflow\n\nWhy others are incorrect:\n- A: Model override is invasive and not extensible\n- B: Plugins work but interfaces are cleaner for rules\n- D: Permissions are separate from approval rules",
    "codeExample": "// Implementing custom approval rule\nclass CustomApprovalRule implements ApprovalRuleInterface\n{\n    public function validate(PurchaseOrderInterface $purchaseOrder): bool\n    {\n        // Custom validation logic\n        $total = $purchaseOrder->getGrandTotal();\n        $companyId = $purchaseOrder->getCompanyId();\n\n        // Check if order exceeds custom threshold\n        $threshold = $this->getCompanyThreshold($companyId);\n\n        return $total <= $threshold;\n    }\n\n    public function getConditionType(): string\n    {\n        return 'custom_amount_rule';\n    }\n\n    public function getLabel(): string\n    {\n        return __('Custom Amount Threshold');\n    }\n}\n\n// Register in di.xml\n<type name=\"Magento\\PurchaseOrder\\Model\\ApprovalRulePool\">\n    <arguments>\n        <argument name=\"rules\" xsi:type=\"array\">\n            <item name=\"custom_rule\" xsi:type=\"object\">Vendor\\Module\\Model\\ApprovalRule\\CustomApprovalRule</item>\n        </argument>\n    </arguments>\n</type>",
    "examDomain": "Design",
    "objectiveTags": [
      "b2b",
      "company-accounts",
      "shared-catalog"
    ]
  },
  {
    "id": 45,
    "category": "MSI (Inventory)",
    "difficulty": "Medium",
    "question": "In Magento MSI (Multi-Source Inventory), what is the relationship between Sources and Stocks?",
    "options": [
      {
        "id": "A",
        "text": "Sources contain Stocks"
      },
      {
        "id": "B",
        "text": "Stocks are assigned to Sources"
      },
      {
        "id": "C",
        "text": "Sources are linked to Stocks, and Stocks are linked to Sales Channels"
      },
      {
        "id": "D",
        "text": "Sources and Stocks are the same concept"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "MSI architecture: Sources  Stocks  Sales Channels (websites).\n\nWhy C is correct:\n- Sources = physical inventory locations (warehouses)\n- Stocks = aggregation of Sources\n- Stocks are linked to Sales Channels (websites)\n- Allows different inventory views per website\n\nWhy others are incorrect:\n- A: Sources don't contain Stocks, they're linked\n- B: Stocks aggregate Sources, not assigned to them\n- D: They serve different purposes",
    "codeExample": "// MSI Architecture:\n// Source (warehouse) -> Stock (aggregation) -> Sales Channel (website)\n\n// Get salable quantity for a product on a stock\n$salableQty = $this->getProductSalableQty->execute('SKU-123', $stockId);\n\n// Check if product is in stock for specific stock\n$isInStock = $this->isProductSalable->execute('SKU-123', $stockId);\n\n// Programmatically create source assignment\n$sourceItem = $this->sourceItemFactory->create();\n$sourceItem->setSourceCode('warehouse_1');\n$sourceItem->setSku('SKU-123');\n$sourceItem->setQuantity(100);\n$sourceItem->setStatus(SourceItemInterface::STATUS_IN_STOCK);\n$this->sourceItemsSave->execute([$sourceItem]);\n\n// Get stock ID by sales channel (website)\n$stockId = $this->stockResolver->execute(\n    SalesChannelInterface::TYPE_WEBSITE,\n    'base'\n)->getStockId();",
    "examDomain": "Design",
    "objectiveTags": [
      "msi",
      "inventory-reservations"
    ]
  },
  {
    "id": 46,
    "category": "Security",
    "difficulty": "Hard",
    "question": "Which security measure should be implemented when handling user-submitted content that will be displayed on the storefront?",
    "options": [
      {
        "id": "A",
        "text": "Use htmlspecialchars() in PHP before output"
      },
      {
        "id": "B",
        "text": "Use $block->escapeHtml() in templates"
      },
      {
        "id": "C",
        "text": "Store sanitized HTML in database"
      },
      {
        "id": "D",
        "text": "Rely on browser XSS protection headers"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento templates should use block escape methods to prevent XSS.\n\nWhy B is correct:\n- escapeHtml() properly encodes HTML entities\n- Context-aware escaping (escapeUrl, escapeJs, etc.)\n- Consistent with Magento security standards\n- Applied at output time, not storage\n\nWhy others are incorrect:\n- A: Works but block methods are Magento standard\n- C: Sanitizing at storage can lose legitimate content\n- D: Browser headers are defense-in-depth, not primary protection",
    "codeExample": "<!-- Template escaping examples -->\n\n<!-- Basic HTML escaping -->\n<p><?= $block->escapeHtml($userInput) ?></p>\n\n<!-- Escaping with allowed tags -->\n<div><?= $block->escapeHtml($userContent, ['b', 'i', 'a']) ?></div>\n\n<!-- URL escaping -->\n<a href=\"<?= $block->escapeUrl($userProvidedUrl) ?>\">Link</a>\n\n<!-- JavaScript escaping -->\n<script>\n    var userData = <?= $block->escapeJs($jsonData) ?>;\n</script>\n\n<!-- HTML attribute escaping -->\n<input value=\"<?= $block->escapeHtmlAttr($value) ?>\"/>\n\n<!-- CSS escaping -->\n<div style=\"background: <?= $block->escapeCss($color) ?>\"></div>\n\n// In PHP class (ViewModel)\npublic function getSafeContent(): string\n{\n    return $this->escaper->escapeHtml($this->getUserContent());\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "security-hardening",
      "secure-coding",
      "compliance"
    ]
  },
  {
    "id": 47,
    "category": "Logging & Debugging",
    "difficulty": "Medium",
    "question": "What is the recommended way to add custom logging in a Magento 2 module?",
    "options": [
      {
        "id": "A",
        "text": "Use PHP error_log() function"
      },
      {
        "id": "B",
        "text": "Write directly to var/log files"
      },
      {
        "id": "C",
        "text": "Inject Psr\\Log\\LoggerInterface and use its methods"
      },
      {
        "id": "D",
        "text": "Create custom file handling class"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "Magento uses PSR-3 LoggerInterface for standardized logging.\n\nWhy C is correct:\n- PSR-3 LoggerInterface is the standard\n- Injected via dependency injection\n- Supports multiple log levels\n- Configurable handlers and formatters\n\nWhy others are incorrect:\n- A: error_log bypasses Magento logging infrastructure\n- B: Direct file writing is not maintainable\n- D: Custom handlers extend, not replace the system",
    "codeExample": "// Using PSR-3 Logger\nuse Psr\\Log\\LoggerInterface;\n\nclass MyService\n{\n    public function __construct(\n        private LoggerInterface $logger\n    ) {}\n\n    public function process(): void\n    {\n        $this->logger->info('Processing started', ['context' => 'value']);\n\n        try {\n            // Business logic\n            $this->logger->debug('Debug info', $debugData);\n        } catch (\\Exception $e) {\n            $this->logger->error('Processing failed', [\n                'exception' => $e->getMessage(),\n                'trace' => $e->getTraceAsString()\n            ]);\n        }\n\n        $this->logger->warning('Deprecated method used');\n    }\n}\n\n// Custom logger channel (di.xml virtual type)\n<virtualType name=\"Vendor\\Module\\Logger\" type=\"Magento\\Framework\\Logger\\Monolog\">\n    <arguments>\n        <argument name=\"name\" xsi:type=\"string\">vendor_module</argument>\n        <argument name=\"handlers\" xsi:type=\"array\">\n            <item name=\"system\" xsi:type=\"object\">Vendor\\Module\\Logger\\Handler</item>\n        </argument>\n    </arguments>\n</virtualType>",
    "examDomain": "Review",
    "objectiveTags": [
      "observability",
      "logging",
      "diagnostics"
    ]
  },
  {
    "id": 48,
    "category": "Theme Development",
    "difficulty": "Medium",
    "question": "In Magento 2 theme hierarchy, which location takes highest priority for template overrides?",
    "options": [
      {
        "id": "A",
        "text": "Module view/frontend/templates"
      },
      {
        "id": "B",
        "text": "Theme Vendor_Module/templates (app/design/frontend/Vendor/theme/Vendor_Module)"
      },
      {
        "id": "C",
        "text": "Parent theme templates"
      },
      {
        "id": "D",
        "text": "Child theme templates"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "explanation": "Theme fallback hierarchy: Child Theme  Parent Theme  Module.\n\nWhy D is correct:\n- Child theme has highest priority\n- Then parent theme(s) in inheritance chain\n- Finally, module's own templates\n- Allows progressive customization\n\nWhy others are incorrect:\n- A: Module templates have lowest priority\n- B: Theme overrides beat module but not child theme\n- C: Parent theme is checked before module, after child",
    "codeExample": "// Template fallback order (highest to lowest):\n// 1. app/design/frontend/Vendor/child-theme/Vendor_Module/templates/\n// 2. app/design/frontend/Vendor/parent-theme/Vendor_Module/templates/\n// 3. app/code/Vendor/Module/view/frontend/templates/\n// 4. vendor/magento/module-xxx/view/frontend/templates/\n\n// Theme inheritance (theme.xml)\n<!-- app/design/frontend/Vendor/child-theme/theme.xml -->\n<theme xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:noNamespaceSchemaLocation=\"urn:magento:framework:Config/etc/theme.xsd\">\n    <title>Child Theme</title>\n    <parent>Vendor/parent-theme</parent>\n</theme>\n\n// Override module template in theme:\n// app/design/frontend/Vendor/theme/Magento_Catalog/templates/product/view.phtml\n\n// Override layout in theme:\n// app/design/frontend/Vendor/theme/Magento_Catalog/layout/catalog_product_view.xml",
    "examDomain": "Design",
    "objectiveTags": [
      "frontend-architecture",
      "theme-fallback"
    ]
  },
  {
    "id": 49,
    "category": "Catalog Rules",
    "difficulty": "Medium",
    "question": "How are Catalog Price Rules applied to product prices in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Calculated in real-time during page load"
      },
      {
        "id": "B",
        "text": "Pre-calculated and stored in catalogrule_product_price table via indexer"
      },
      {
        "id": "C",
        "text": "Applied only at checkout"
      },
      {
        "id": "D",
        "text": "Stored directly in the product's price attribute"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Catalog rules are pre-indexed for performance.\n\nWhy B is correct:\n- catalogrule_product_price stores calculated rule prices\n- Indexer runs when rules change or on schedule\n- Product collection loads from pre-calculated table\n- Much faster than real-time calculation\n\nWhy others are incorrect:\n- A: Real-time would be too slow for product listings\n- C: That's Cart Price Rules, not Catalog\n- D: Original price is preserved; rule prices are separate",
    "codeExample": "// Catalog rule indexer reindex\n// bin/magento indexer:reindex catalogrule_product\n\n// Tables involved:\n// - catalogrule: Rule definitions\n// - catalogrule_product: Products matching rules\n// - catalogrule_product_price: Final calculated prices\n\n// Get rule price programmatically\n$rulePrice = $this->ruleResource->getRulePrice(\n    $dateTime,\n    $websiteId,\n    $customerGroupId,\n    $productId\n);\n\n// Apply in price collection\n$productCollection->addPriceData();\n// This automatically joins catalogrule_product_price for rule prices\n\n// Product final price considers:\n// 1. Regular price\n// 2. Special price\n// 3. Catalog rule price\n// 4. Tier prices\n// Returns lowest applicable price",
    "examDomain": "Design",
    "objectiveTags": [
      "catalog-pricing",
      "rule-engine"
    ]
  },
  {
    "id": 50,
    "category": "Module Development",
    "difficulty": "Medium",
    "question": "What determines the load order of modules in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Alphabetical order of module names"
      },
      {
        "id": "B",
        "text": "Order in app/etc/config.php"
      },
      {
        "id": "C",
        "text": "Sequence dependencies defined in module.xml"
      },
      {
        "id": "D",
        "text": "Composer package order"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "Module sequence in module.xml controls load order.\n\nWhy C is correct:\n- <sequence> tag defines dependencies\n- Module loads after all listed dependencies\n- Ensures proper plugin/preference order\n- Required for proper configuration merging\n\nWhy others are incorrect:\n- A: Alphabetical is not the mechanism\n- B: config.php lists enabled modules, not order\n- D: Composer handles PHP autoloading, not module sequence",
    "codeExample": "<!-- etc/module.xml -->\n<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:framework:Module/etc/module.xsd\">\n    <module name=\"Vendor_CustomCheckout\">\n        <sequence>\n            <!-- This module loads AFTER these modules -->\n            <module name=\"Magento_Checkout\"/>\n            <module name=\"Magento_Quote\"/>\n            <module name=\"Magento_Customer\"/>\n        </sequence>\n    </module>\n</config>\n\n// Why sequence matters:\n// 1. Configuration merging order\n// 2. Plugin execution order\n// 3. Observer registration order\n// 4. Layout update merging\n\n// Check current module order:\n// bin/magento module:status\n\n// Sequence affects:\n// - etc/*.xml merge order\n// - view/*/layout/*.xml merge order\n// - which plugin executes first when multiple exist",
    "examDomain": "Design",
    "objectiveTags": [
      "module-architecture",
      "upgrade-safe-customization"
    ]
  },
  {
    "id": 51,
    "category": "Performance",
    "difficulty": "Hard",
    "question": "Which technique should be used to optimize database queries for a custom product listing that displays data from multiple EAV attributes?",
    "options": [
      {
        "id": "A",
        "text": "Load each product individually with getById()"
      },
      {
        "id": "B",
        "text": "Use addAttributeToSelect() with specific attributes on collection"
      },
      {
        "id": "C",
        "text": "Enable flat catalog for all attributes"
      },
      {
        "id": "D",
        "text": "Cache the entire product collection in Redis"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Selective attribute loading minimizes EAV joins and improves performance.\n\nWhy B is correct:\n- addAttributeToSelect() only joins needed attribute tables\n- Reduces query complexity significantly\n- Can use addAttributeToSelect('*') carefully\n- Supports addAttributeToFilter for conditions\n\nWhy others are incorrect:\n- A: Individual loads cause N+1 query problem\n- C: Flat catalog is deprecated and limited\n- D: Caching entire collections has memory/invalidation issues",
    "codeExample": "// Optimized collection loading\n$collection = $this->productCollectionFactory->create();\n$collection\n    ->addAttributeToSelect(['name', 'price', 'thumbnail', 'status'])  // Only needed\n    ->addAttributeToFilter('status', Status::STATUS_ENABLED)\n    ->addAttributeToFilter('visibility', ['neq' => Visibility::VISIBILITY_NOT_VISIBLE])\n    ->setPageSize(20);\n\n// DON'T do this - loads ALL attributes:\n// $collection->addAttributeToSelect('*');\n\n// For custom attributes, ensure they exist\nif ($this->eavConfig->getAttribute('catalog_product', 'custom_attr')->getId()) {\n    $collection->addAttributeToSelect('custom_attr');\n}\n\n// Use joins for non-EAV data\n$collection->getSelect()->joinLeft(\n    ['inventory' => $this->resource->getTableName('cataloginventory_stock_item')],\n    'e.entity_id = inventory.product_id',\n    ['qty']\n);\n\n// Benchmark:\n// select('*') with 50 attributes: ~200ms\n// select([5 attrs]): ~20ms",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "performance-optimization",
      "scalability"
    ]
  },
  {
    "id": 52,
    "category": "Dependency Injection",
    "difficulty": "Medium",
    "question": "An Adobe Commerce Architect needs to create new product instances in a service class. Which pattern should be used to create new entity objects that will be saved to the database?",
    "options": [
      {
        "id": "A",
        "text": "Use the Repository pattern with get() method"
      },
      {
        "id": "B",
        "text": "Use the Factory pattern to create new instances"
      },
      {
        "id": "C",
        "text": "Use ObjectManager::create() directly"
      },
      {
        "id": "D",
        "text": "Use the Builder pattern with setData() method"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "The Factory pattern is specifically designed for creating NEW entity instances in Magento 2.\n\nWhy B is correct:\n- Factories create new, empty instances of objects\n- Factory classes are auto-generated by Magento\n- They properly handle dependency injection for the created object\n- Convention: ClassNameFactory->create() returns new instance\n\nWhy others are incorrect:\n- A: Repository->get() retrieves EXISTING entities, not creates new ones\n- C: Direct ObjectManager usage is an anti-pattern (except in factories/tests)\n- D: Builder pattern is not a standard Magento pattern for entity creation",
    "codeExample": "// Correct: Using Factory for new entities\nclass ProductService\n{\n    public function __construct(\n        private ProductInterfaceFactory $productFactory,\n        private ProductRepositoryInterface $productRepository\n    ) {}\n\n    public function createProduct(array $data): ProductInterface\n    {\n        // Factory creates NEW instance\n        $product = $this->productFactory->create();\n        $product->setSku($data['sku']);\n        $product->setName($data['name']);\n\n        // Repository SAVES the entity\n        return $this->productRepository->save($product);\n    }\n}\n\n// Wrong: Using repository to \"create\"\n// $product = $this->productRepository->get($sku); // This GETS existing!",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 53,
    "category": "Dependency Injection",
    "difficulty": "Medium",
    "question": "A developer needs to replace a constructor argument for a specific class in di.xml. The original class has a $logger parameter that should use a custom logger. What is the correct di.xml configuration?",
    "options": [
      {
        "id": "A",
        "text": "Use <preference> to replace the logger class globally"
      },
      {
        "id": "B",
        "text": "Use <type> with <arguments> to override the specific parameter"
      },
      {
        "id": "C",
        "text": "Use <virtualType> to create a new class with different arguments"
      },
      {
        "id": "D",
        "text": "Use <plugin> to intercept the constructor and change the logger"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "The <type> element with <arguments> allows you to override specific constructor arguments for a class.\n\nWhy B is correct:\n- <type name=\"Class\"> targets a specific class\n- <arguments> allows overriding individual constructor parameters\n- This is the standard way to customize DI for existing classes\n- Maintains the original class while changing its dependencies\n\nWhy others are incorrect:\n- A: Preference replaces class globally, affects all usages - overkill for argument change\n- C: VirtualType creates alias with different args, but question asks about existing class\n- D: Plugins cannot intercept constructors in Magento 2",
    "codeExample": "<!-- di.xml - Correct approach -->\n<type name=\"Vendor\\Module\\Service\\MyService\">\n    <arguments>\n        <argument name=\"logger\" xsi:type=\"object\">Vendor\\Module\\Logger\\CustomLogger</argument>\n    </arguments>\n</type>\n\n<!-- Original class -->\nclass MyService\n{\n    public function __construct(\n        private LoggerInterface $logger  // This will receive CustomLogger\n    ) {}\n}\n\n<!-- Wrong: Using preference (global replacement) -->\n<preference for=\"Psr\\Log\\LoggerInterface\" type=\"CustomLogger\"/>\n<!-- This affects ALL classes using LoggerInterface! -->",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 54,
    "category": "Dependency Injection",
    "difficulty": "Hard",
    "question": "When a plugin (interceptor) is defined for a class, how does Magento handle the interceptor class generation and inheritance?",
    "options": [
      {
        "id": "A",
        "text": "The generated interceptor extends the original class and calls parent methods"
      },
      {
        "id": "B",
        "text": "The generated interceptor implements the same interface without extending"
      },
      {
        "id": "C",
        "text": "The original class is modified at runtime to include plugin logic"
      },
      {
        "id": "D",
        "text": "A proxy class wraps the original class without inheritance"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "Magento's interceptor (plugin) mechanism generates a class that extends the original class.\n\nWhy A is correct:\n- Interceptor classes are generated in var/generation (or generated/) directory\n- Generated class naming: Original\\Class\\Interceptor\n- The interceptor EXTENDS the original class\n- Plugin methods (before/after/around) are called via ___callPlugins()\n- Parent methods are called to execute original logic\n\nWhy others are incorrect:\n- B: Interceptors DO extend the original class, not just implement interface\n- C: Original class files are never modified\n- D: Interceptors use inheritance, not composition/wrapping",
    "codeExample": "// Generated Interceptor (simplified)\n// File: generated/code/Vendor/Module/Model/Product/Interceptor.php\n\nnamespace Vendor\\Module\\Model\\Product;\n\nclass Interceptor extends \\Vendor\\Module\\Model\\Product\n    implements \\Magento\\Framework\\Interception\\InterceptorInterface\n{\n    use \\Magento\\Framework\\Interception\\Interceptor;\n\n    public function getName()\n    {\n        // Calls before plugins, then parent::getName(), then after plugins\n        $pluginInfo = $this->pluginList->getNext('getName');\n        return $pluginInfo ? $this->___callPlugins('getName', [], $pluginInfo)\n                          : parent::getName();\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 55,
    "category": "Dependency Injection",
    "difficulty": "Medium",
    "question": "In which scenarios is direct usage of ObjectManager acceptable in Magento 2 code?",
    "options": [
      {
        "id": "A",
        "text": "In controllers when constructor injection is not available"
      },
      {
        "id": "B",
        "text": "In static methods and factory classes generated by Magento"
      },
      {
        "id": "C",
        "text": "In any class when you need to conditionally create objects"
      },
      {
        "id": "D",
        "text": "In helper classes for backward compatibility"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Direct ObjectManager usage is only acceptable in specific framework-level scenarios.\n\nWhy B is correct:\n- Factory classes (auto-generated) use ObjectManager internally\n- Static methods have no constructor, may need ObjectManager\n- Framework bootstrap code before DI is initialized\n- Integration tests that need to retrieve objects\n- Fixtures and scripts outside normal request flow\n\nWhy others are incorrect:\n- A: Controllers have constructor injection available, no excuse\n- C: Use factories or conditional logic with injected dependencies\n- D: Helpers should use constructor injection like any other class",
    "codeExample": "// ACCEPTABLE: Generated Factory (internal use)\nclass ProductFactory\n{\n    public function __construct(\n        \\Magento\\Framework\\ObjectManagerInterface $objectManager\n    ) {\n        $this->_objectManager = $objectManager;\n    }\n\n    public function create(array $data = [])\n    {\n        return $this->_objectManager->create(Product::class, $data);\n    }\n}\n\n// NOT ACCEPTABLE: Direct usage in service class\nclass BadService\n{\n    public function doSomething()\n    {\n        // WRONG - anti-pattern!\n        $product = \\Magento\\Framework\\App\\ObjectManager::getInstance()\n            ->create(ProductInterface::class);\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 56,
    "category": "Dependency Injection",
    "difficulty": "Medium",
    "question": "What is the difference between shared='true' and shared='false' for a type definition in di.xml?",
    "options": [
      {
        "id": "A",
        "text": "shared='true' creates a new instance each time, shared='false' reuses one instance"
      },
      {
        "id": "B",
        "text": "shared='true' reuses one instance (singleton), shared='false' creates new instance each time"
      },
      {
        "id": "C",
        "text": "shared='true' allows the object to be shared across modules"
      },
      {
        "id": "D",
        "text": "shared='false' prevents the class from being overridden by preferences"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "The 'shared' attribute controls whether the object manager returns the same instance or creates a new one.\n\nWhy B is correct:\n- shared=\"true\" (DEFAULT): Object is singleton - same instance returned every time\n- shared=\"false\": New instance created on each request (factory-like behavior)\n- Default is shared=\"true\" for most classes\n- This affects performance and state management\n\nWhy others are incorrect:\n- A: Reversed - shared=true is singleton, shared=false creates new\n- C: \"shared\" refers to instance sharing, not module access\n- D: \"shared\" doesn't affect preference behavior",
    "codeExample": "<!-- di.xml -->\n\n<!-- Singleton (default behavior) - same instance reused -->\n<type name=\"Vendor\\Module\\Service\\CacheService\" shared=\"true\"/>\n\n<!-- Non-shared - new instance each injection -->\n<type name=\"Vendor\\Module\\Model\\Cart\\Item\" shared=\"false\"/>\n\n<!-- Practical example -->\nclass OrderService\n{\n    // If CartItem is shared=false, each injection gets fresh instance\n    public function __construct(\n        private CartItem $cartItem1,  // Instance A\n        private CartItem $cartItem2   // Instance B (different!)\n    ) {}\n}\n\n// With shared=true (default):\n// $cartItem1 === $cartItem2 (same object)",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 57,
    "category": "Dependency Injection",
    "difficulty": "Medium",
    "question": "When should an architect use a virtualType instead of a regular type with argument overrides?",
    "options": [
      {
        "id": "A",
        "text": "When you need to completely replace a class with a different implementation"
      },
      {
        "id": "B",
        "text": "When you need to create an alias with different constructor arguments without creating a PHP class"
      },
      {
        "id": "C",
        "text": "When you need to add plugins to a class"
      },
      {
        "id": "D",
        "text": "When you need to make a class available for unit testing"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "VirtualType creates a DI-level alias with different arguments, without requiring a new PHP class file.\n\nWhy B is correct:\n- VirtualType is a \"configuration-only\" class alias\n- Reuses existing PHP class with different injected dependencies\n- No PHP file needed - purely di.xml configuration\n- Useful for creating specialized versions of generic classes\n\nWhy others are incorrect:\n- A: Use <preference> to replace class implementation\n- C: Plugins are added via <plugin> element, not virtualType\n- D: Testing doesn't require virtualType",
    "codeExample": "<!-- di.xml - VirtualType example -->\n\n<!-- Create specialized logger without new PHP class -->\n<virtualType name=\"Vendor\\Module\\Logger\\PaymentLogger\"\n             type=\"Magento\\Framework\\Logger\\Monolog\">\n    <arguments>\n        <argument name=\"name\" xsi:type=\"string\">payment</argument>\n        <argument name=\"handlers\" xsi:type=\"array\">\n            <item name=\"debug\" xsi:type=\"object\">Vendor\\Module\\Logger\\Handler\\Payment</item>\n        </argument>\n    </arguments>\n</virtualType>\n\n<!-- Use the virtual type -->\n<type name=\"Vendor\\Module\\Service\\PaymentService\">\n    <arguments>\n        <argument name=\"logger\" xsi:type=\"object\">Vendor\\Module\\Logger\\PaymentLogger</argument>\n    </arguments>\n</type>\n\n<!-- No PHP file needed for PaymentLogger! -->",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 58,
    "category": "Dependency Injection",
    "difficulty": "Hard",
    "question": "A service class has an expensive dependency that is only used in certain conditions. What pattern should the architect use to defer the instantiation of this dependency?",
    "options": [
      {
        "id": "A",
        "text": "Use a Factory to create the dependency when needed"
      },
      {
        "id": "B",
        "text": "Use a Proxy class to lazy-load the dependency"
      },
      {
        "id": "C",
        "text": "Use shared='false' to prevent early instantiation"
      },
      {
        "id": "D",
        "text": "Use ObjectManager::get() to retrieve the dependency on demand"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Proxy classes in Magento 2 provide lazy loading - the real object is only instantiated when first used.\n\nWhy B is correct:\n- Proxy delays object creation until first method call\n- Generated automatically by Magento (ClassName\\Proxy)\n- Implements same interface as original class\n- Ideal for expensive dependencies used conditionally\n- Constructor runs instantly, but wrapped object is lazy\n\nWhy others are incorrect:\n- A: Factory creates new instances, doesn't lazy-load existing singleton dependencies\n- C: shared=false affects instance sharing, not lazy loading\n- D: ObjectManager is anti-pattern",
    "codeExample": "<!-- di.xml - Using Proxy for lazy loading -->\n<type name=\"Vendor\\Module\\Service\\OrderService\">\n    <arguments>\n        <!-- Heavy dependency only loaded when actually used -->\n        <argument name=\"reportGenerator\" xsi:type=\"object\">\n            Vendor\\Module\\Service\\HeavyReportGenerator\\Proxy\n        </argument>\n    </arguments>\n</type>\n\n// PHP Service Class\nclass OrderService\n{\n    public function __construct(\n        private HeavyReportGenerator $reportGenerator // Actually a Proxy!\n    ) {\n        // HeavyReportGenerator NOT instantiated yet\n    }\n\n    public function generateReport(): void\n    {\n        // NOW HeavyReportGenerator is instantiated (first use)\n        $this->reportGenerator->generate();\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 59,
    "category": "Dependency Injection",
    "difficulty": "Medium",
    "question": "An architect needs to modify the behavior of a core Magento class. When should they use a Plugin versus a Preference?",
    "options": [
      {
        "id": "A",
        "text": "Plugin for extending behavior, Preference for completely replacing the class"
      },
      {
        "id": "B",
        "text": "Plugin for performance-critical code, Preference for non-critical code"
      },
      {
        "id": "C",
        "text": "Plugin only works on interfaces, Preference works on concrete classes"
      },
      {
        "id": "D",
        "text": "Plugin is deprecated, Preference is the recommended approach"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "Plugins and Preferences serve different purposes in Magento's DI system.\n\nWhy A is correct:\n- PLUGIN: Extends/modifies behavior (before, after, around methods)\n  - Multiple plugins can exist for same method\n  - Original class remains, behavior is augmented\n  - Recommended for most customizations\n\n- PREFERENCE: Completely replaces one class with another\n  - Only one preference per interface/class\n  - Your class must extend/implement original\n  - Use when you need to change class structure\n\nWhy others are incorrect:\n- B: Performance is not the deciding factor\n- C: Both can work on interfaces and concrete classes\n- D: Plugins are the current recommended approach, not deprecated",
    "codeExample": "<!-- Plugin: EXTEND behavior (recommended) -->\n<type name=\"Magento\\Catalog\\Model\\Product\">\n    <plugin name=\"my_product_plugin\"\n            type=\"Vendor\\Module\\Plugin\\ProductPlugin\"/>\n</type>\n\nclass ProductPlugin\n{\n    public function afterGetName(Product $subject, $result)\n    {\n        return $result . ' - On Sale!';  // Extends, doesn't replace\n    }\n}\n\n<!-- Preference: REPLACE class (use sparingly) -->\n<preference for=\"Magento\\Catalog\\Api\\ProductRepositoryInterface\"\n            type=\"Vendor\\Module\\Model\\ProductRepository\"/>\n\n// Must implement/extend original\nclass ProductRepository implements ProductRepositoryInterface\n{\n    // Complete replacement of all methods\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 60,
    "category": "Dependency Injection",
    "difficulty": "Hard",
    "question": "A module needs to register multiple implementations of the same interface that should all be executed. Which pattern does Magento use for this scenario?",
    "options": [
      {
        "id": "A",
        "text": "Chain of Responsibility pattern with plugins"
      },
      {
        "id": "B",
        "text": "Composite pattern using an array argument in di.xml"
      },
      {
        "id": "C",
        "text": "Observer pattern with multiple event listeners"
      },
      {
        "id": "D",
        "text": "Strategy pattern with runtime switching"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento uses the Composite pattern to handle multiple implementations of an interface.\n\nWhy B is correct:\n- Composite class receives array of implementations via di.xml\n- Each implementation is iterated and executed\n- Examples: ValidatorPool, CommandPool, Collectors\n- Common in payment methods, validators, data collectors\n\nWhy others are incorrect:\n- A: Chain of Responsibility is different (sequential with early exit)\n- C: Observers are for events, not interface implementations\n- D: Strategy is for selecting ONE implementation, not running multiple",
    "codeExample": "<!-- di.xml - Composite Pattern -->\n<type name=\"Vendor\\Module\\Model\\ValidatorComposite\">\n    <arguments>\n        <argument name=\"validators\" xsi:type=\"array\">\n            <item name=\"stock\" xsi:type=\"object\">Vendor\\Module\\Model\\Validator\\Stock</item>\n            <item name=\"price\" xsi:type=\"object\">Vendor\\Module\\Model\\Validator\\Price</item>\n            <item name=\"status\" xsi:type=\"object\">Vendor\\Module\\Model\\Validator\\Status</item>\n        </argument>\n    </arguments>\n</type>\n\n// Composite class runs all validators\nclass ValidatorComposite implements ValidatorInterface\n{\n    public function __construct(\n        private array $validators  // All implementations injected\n    ) {}\n\n    public function validate($entity): bool\n    {\n        foreach ($this->validators as $validator) {\n            if (!$validator->validate($entity)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "di",
      "interception",
      "object-manager"
    ]
  },
  {
    "id": 61,
    "category": "Service Contracts",
    "difficulty": "Medium",
    "question": "When designing a data interface for a service contract, which methods should it contain according to Magento best practices?",
    "options": [
      {
        "id": "A",
        "text": "Only getter methods for immutable data transfer"
      },
      {
        "id": "B",
        "text": "Getters and setters for each data property"
      },
      {
        "id": "C",
        "text": "Business logic methods along with data access"
      },
      {
        "id": "D",
        "text": "Static factory methods for object creation"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Data interfaces in Magento 2 service contracts should contain getters and setters for data transfer.\n\nWhy B is correct:\n- Data interfaces represent data structures (DTOs)\n- Must have getter and setter for each property\n- Allows hydration from various sources (API, database)\n- Should extend ExtensibleDataInterface for extension attributes\n- Annotated with @api for stability guarantee\n\nWhy others are incorrect:\n- A: Setters are required for populating data from API/forms\n- C: Business logic belongs in service interfaces, not data interfaces\n- D: Factory methods should be in separate Factory classes",
    "codeExample": "// Correct Data Interface Design\nnamespace Vendor\\Module\\Api\\Data;\n\n/**\n * @api\n */\ninterface ProductDataInterface extends ExtensibleDataInterface\n{\n    const SKU = 'sku';\n    const NAME = 'name';\n    const PRICE = 'price';\n\n    /** @return string */\n    public function getSku();\n    /** @param string $sku @return $this */\n    public function setSku($sku);\n\n    /** @return string */\n    public function getName();\n    /** @param string $name @return $this */\n    public function setName($name);\n\n    /** @return float */\n    public function getPrice();\n    /** @param float $price @return $this */\n    public function setPrice($price);\n\n    // Extension attributes support\n    public function getExtensionAttributes();\n    public function setExtensionAttributes(ProductDataExtensionInterface $ext);\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "service-contracts",
      "api-design",
      "backward-compatibility"
    ]
  },
  {
    "id": 62,
    "category": "Service Contracts",
    "difficulty": "Hard",
    "question": "When using SearchCriteria with multiple FilterGroups, how are the conditions combined?",
    "options": [
      {
        "id": "A",
        "text": "All filters in all groups are combined with AND"
      },
      {
        "id": "B",
        "text": "All filters in all groups are combined with OR"
      },
      {
        "id": "C",
        "text": "Filters within a group are AND, between groups are OR"
      },
      {
        "id": "D",
        "text": "Filters within a group are OR, between groups are AND"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "explanation": "SearchCriteria uses a specific logic: OR within FilterGroup, AND between FilterGroups.\n\nWhy D is correct:\n- FilterGroup = collection of Filter objects combined with OR\n- Multiple FilterGroups are combined with AND\n- This allows complex queries like: (status=1 OR status=2) AND (type='simple' OR type='virtual')\n- Each FilterGroup represents a set of alternative conditions\n\nWhy others are incorrect:\n- A: Not all AND - would be too restrictive\n- B: Not all OR - would be too permissive\n- C: Reversed - within group is OR, between groups is AND",
    "codeExample": "// Building SearchCriteria: (status=1 OR status=2) AND (qty > 0)\n\n$searchCriteriaBuilder = $this->searchCriteriaBuilderFactory->create();\n\n// FilterGroup 1: status conditions (OR within group)\n$filter1 = $this->filterBuilder->setField('status')\n    ->setValue(1)->setConditionType('eq')->create();\n$filter2 = $this->filterBuilder->setField('status')\n    ->setValue(2)->setConditionType('eq')->create();\n$filterGroup1 = $this->filterGroupBuilder\n    ->setFilters([$filter1, $filter2])->create();\n\n// FilterGroup 2: qty condition\n$filter3 = $this->filterBuilder->setField('qty')\n    ->setValue(0)->setConditionType('gt')->create();\n$filterGroup2 = $this->filterGroupBuilder\n    ->setFilters([$filter3])->create();\n\n// Combine: Group1 AND Group2\n$searchCriteria = $searchCriteriaBuilder\n    ->setFilterGroups([$filterGroup1, $filterGroup2])\n    ->create();\n\n// Result: (status=1 OR status=2) AND qty>0",
    "examDomain": "Design",
    "objectiveTags": [
      "service-contracts",
      "api-design",
      "backward-compatibility"
    ]
  },
  {
    "id": 63,
    "category": "Service Contracts",
    "difficulty": "Medium",
    "question": "What is the difference between extension attributes and custom attributes in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Extension attributes are for EAV entities, custom attributes for flat tables"
      },
      {
        "id": "B",
        "text": "Extension attributes are defined in code, custom attributes are created in admin"
      },
      {
        "id": "C",
        "text": "Extension attributes require module installation, custom attributes don't"
      },
      {
        "id": "D",
        "text": "Extension attributes are deprecated, custom attributes are recommended"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Extension attributes and custom attributes serve different purposes in Magento 2.\n\nWhy B is correct:\n- Extension Attributes: Defined in extension_attributes.xml, added via code\n  - Allow modules to add data to existing API interfaces\n  - Type-safe, strongly typed\n  - Require code deployment\n\n- Custom Attributes: Created via admin panel or programmatically\n  - EAV attributes for entities like products, customers, categories\n  - Dynamic, can be added at runtime\n  - No code deployment needed for basic attributes\n\nWhy others are incorrect:\n- A: Both can work with EAV and flat tables\n- C: Both can require module installation depending on implementation\n- D: Both are actively used and supported",
    "codeExample": "<!-- Extension Attribute (code-defined) -->\n<!-- extension_attributes.xml -->\n<extension_attributes for=\"Magento\\Catalog\\Api\\Data\\ProductInterface\">\n    <attribute code=\"warranty_info\" type=\"Vendor\\Module\\Api\\Data\\WarrantyInterface\"/>\n</extension_attributes>\n\n// Usage\n$product->getExtensionAttributes()->getWarrantyInfo();\n\n<!-- Custom Attribute (admin-defined EAV) -->\n// Created via: Stores > Attributes > Product > Add New\n// Or programmatically:\n$eavSetup->addAttribute(\n    Product::ENTITY,\n    'custom_field',\n    ['type' => 'varchar', 'label' => 'Custom Field']\n);\n\n// Usage\n$product->getCustomAttribute('custom_field')->getValue();\n// OR\n$product->getData('custom_field');",
    "examDomain": "Design",
    "objectiveTags": [
      "service-contracts",
      "api-design",
      "backward-compatibility"
    ]
  },
  {
    "id": 64,
    "category": "Service Contracts",
    "difficulty": "Medium",
    "question": "What is the purpose of the @api annotation in Magento 2 service contracts?",
    "options": [
      {
        "id": "A",
        "text": "It exposes the interface as a REST endpoint automatically"
      },
      {
        "id": "B",
        "text": "It marks the interface as stable and subject to semantic versioning"
      },
      {
        "id": "C",
        "text": "It enables caching for all methods in the interface"
      },
      {
        "id": "D",
        "text": "It allows the interface to be used in GraphQL queries"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "The @api annotation marks code as part of Magento's public API with stability guarantees.\n\nWhy B is correct:\n- @api indicates the interface is part of public API\n- Subject to Semantic Versioning (SemVer) rules\n- Breaking changes only in major versions (2.x -> 3.x)\n- Third-party modules can safely depend on @api code\n- Magento commits to backward compatibility\n\nWhy others are incorrect:\n- A: REST exposure requires webapi.xml configuration\n- C: Caching requires separate configuration (cacheable=\"true\")\n- D: GraphQL requires schema.graphqls and resolvers",
    "codeExample": "/**\n * Product Repository Interface\n *\n * @api  <-- This annotation is key!\n * @since 100.0.0  <-- Version when API was introduced\n */\ninterface ProductRepositoryInterface\n{\n    /**\n     * @param int $id\n     * @return ProductInterface\n     * @throws NoSuchEntityException\n     */\n    public function getById($id);\n\n    /**\n     * @param ProductInterface $product\n     * @return ProductInterface\n     */\n    public function save(ProductInterface $product);\n}\n\n// With @api:\n// - Guaranteed stable in minor/patch releases\n// - Safe to use in third-party modules\n// - Breaking changes = major version bump\n\n// Without @api:\n// - Internal implementation, may change anytime\n// - Use at your own risk in extensions",
    "examDomain": "Design",
    "objectiveTags": [
      "service-contracts",
      "api-design",
      "backward-compatibility"
    ]
  },
  {
    "id": 65,
    "category": "Web API",
    "difficulty": "Medium",
    "question": "How should a custom REST API endpoint handle errors to return appropriate HTTP status codes?",
    "options": [
      {
        "id": "A",
        "text": "Return an array with 'error' key and HTTP 200 status"
      },
      {
        "id": "B",
        "text": "Throw specific Webapi exceptions that map to HTTP status codes"
      },
      {
        "id": "C",
        "text": "Use header() function to set HTTP status before returning"
      },
      {
        "id": "D",
        "text": "Return null and let Magento handle the error response"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento's Web API framework maps specific exception types to HTTP status codes.\n\nWhy B is correct:\n- NoSuchEntityException  404 Not Found\n- AuthorizationException  401/403 Unauthorized/Forbidden\n- InputException  400 Bad Request\n- CouldNotSaveException  500 Internal Server Error\n- LocalizedException  500 (generic error)\n- Framework handles response formatting automatically\n\nWhy others are incorrect:\n- A: Would always return 200, hiding real error status\n- C: Direct header manipulation breaks API framework\n- D: Null doesn't trigger proper error handling",
    "codeExample": "// Correct error handling in API service\nnamespace Vendor\\Module\\Model;\n\nuse Magento\\Framework\\Exception\\NoSuchEntityException;\nuse Magento\\Framework\\Exception\\InputException;\nuse Magento\\Framework\\Exception\\CouldNotSaveException;\n\nclass OrderService implements OrderServiceInterface\n{\n    public function getOrder($orderId)\n    {\n        if (!$orderId) {\n            // Returns HTTP 400 Bad Request\n            throw new InputException(__('Order ID is required'));\n        }\n\n        $order = $this->orderRepository->get($orderId);\n        if (!$order->getId()) {\n            // Returns HTTP 404 Not Found\n            throw new NoSuchEntityException(\n                __('Order with ID \"%1\" not found', $orderId)\n            );\n        }\n\n        return $order;\n    }\n\n    public function saveOrder($order)\n    {\n        try {\n            return $this->orderRepository->save($order);\n        } catch (\\Exception $e) {\n            // Returns HTTP 500 Internal Server Error\n            throw new CouldNotSaveException(__('Could not save order'));\n        }\n    }\n}",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "webapi",
      "integration-security",
      "async-bulk"
    ]
  },
  {
    "id": 66,
    "category": "Web API",
    "difficulty": "Hard",
    "question": "How does Magento implement bulk/async API operations for processing large datasets?",
    "options": [
      {
        "id": "A",
        "text": "By using database transactions to batch multiple operations"
      },
      {
        "id": "B",
        "text": "By using message queues to process operations asynchronously"
      },
      {
        "id": "C",
        "text": "By splitting requests into chunks and processing sequentially"
      },
      {
        "id": "D",
        "text": "By using Redis cache to store operations and process later"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento's Bulk API uses message queues for asynchronous processing of large operations.\n\nWhy B is correct:\n- Bulk endpoints publish operations to message queue\n- Operations processed by consumers in background\n- Immediate response with operation UUID for tracking\n- Supports RabbitMQ and MySQL queue\n- Status tracked in magento_operation and magento_bulk tables\n\nWhy others are incorrect:\n- A: DB transactions are for atomicity, not async processing\n- C: Sequential processing doesn't scale\n- D: Redis is not used for bulk operation storage",
    "codeExample": "// Bulk API Request: POST /V1/products/bySku (async)\n// Request body with multiple products\n[\n    {\"product\": {\"sku\": \"SKU1\", \"name\": \"Product 1\"}},\n    {\"product\": {\"sku\": \"SKU2\", \"name\": \"Product 2\"}},\n    {\"product\": {\"sku\": \"SKU3\", \"name\": \"Product 3\"}}\n]\n\n// Immediate Response (HTTP 202 Accepted)\n{\n    \"bulk_uuid\": \"c43ed402-3cd7-4b9e-9066-5c5c2b060bc2\",\n    \"request_items\": [\n        {\"id\": 0, \"status\": \"accepted\"},\n        {\"id\": 1, \"status\": \"accepted\"},\n        {\"id\": 2, \"status\": \"accepted\"}\n    ]\n}\n\n// Check status: GET /V1/bulk/{bulk_uuid}/status\n// Operations processed by: bin/magento queue:consumers:start async.operations.all\n\n// Consumer configuration in queue_consumer.xml\n<consumer name=\"async.operations.all\"\n          queue=\"async.operations.all\"\n          handler=\"Magento\\AsynchronousOperations\\Model\\MassConsumer\"/>",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "webapi",
      "integration-security",
      "async-bulk"
    ]
  },
  {
    "id": 67,
    "category": "Web API",
    "difficulty": "Medium",
    "question": "How does Magento handle API versioning for REST and SOAP endpoints?",
    "options": [
      {
        "id": "A",
        "text": "Through Accept header versioning (application/json;version=1)"
      },
      {
        "id": "B",
        "text": "Through URL path versioning (/V1/, /V2/)"
      },
      {
        "id": "C",
        "text": "Through query parameter (?api-version=1)"
      },
      {
        "id": "D",
        "text": "Magento does not support API versioning"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento uses URL path versioning for API endpoints.\n\nWhy B is correct:\n- API version included in URL: /rest/V1/products, /rest/V2/products\n- Each module can define routes for different versions\n- Version specified in webapi.xml route attribute\n- Allows breaking changes in new versions while maintaining old\n- Clear, explicit versioning visible in every request\n\nWhy others are incorrect:\n- A: Magento doesn't use Accept header versioning\n- C: Query parameter versioning not implemented\n- D: Versioning is explicitly supported",
    "codeExample": "<!-- webapi.xml - API Versioning -->\n\n<!-- Version 1 endpoint -->\n<route url=\"/V1/products/:sku\" method=\"GET\">\n    <service class=\"Magento\\Catalog\\Api\\ProductRepositoryInterface\" method=\"get\"/>\n    <resources>\n        <resource ref=\"Magento_Catalog::products\"/>\n    </resources>\n</route>\n\n<!-- Version 2 endpoint (enhanced) -->\n<route url=\"/V2/products/:sku\" method=\"GET\">\n    <service class=\"Vendor\\Module\\Api\\ProductRepositoryV2Interface\" method=\"get\"/>\n    <resources>\n        <resource ref=\"Magento_Catalog::products\"/>\n    </resources>\n</route>\n\n// Request examples:\n// GET /rest/V1/products/SKU123   Returns basic product data\n// GET /rest/V2/products/SKU123   Returns enhanced product data\n\n// SOAP also uses versioning:\n// /soap/default?wsdl&services=catalogProductRepositoryV1",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "webapi",
      "integration-security",
      "async-bulk"
    ]
  },
  {
    "id": 68,
    "category": "Web API",
    "difficulty": "Medium",
    "question": "What configuration file is used to define custom REST API endpoints in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "routes.xml with API route type"
      },
      {
        "id": "B",
        "text": "webapi.xml with route definitions"
      },
      {
        "id": "C",
        "text": "api.xml with endpoint configurations"
      },
      {
        "id": "D",
        "text": "config.xml with API section"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Custom REST and SOAP API endpoints are defined in webapi.xml.\n\nWhy B is correct:\n- webapi.xml located in module's etc/ directory\n- Defines URL route, HTTP method, service class/method\n- Specifies ACL resource for authorization\n- Works for both REST and SOAP endpoints\n- Can define multiple routes for same service\n\nWhy others are incorrect:\n- A: routes.xml is for frontend/adminhtml controllers, not API\n- C: api.xml doesn't exist for this purpose\n- D: config.xml is for general module configuration",
    "codeExample": "<!-- etc/webapi.xml -->\n<routes xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:module:Magento_Webapi:etc/webapi.xsd\">\n\n    <!-- GET endpoint -->\n    <route url=\"/V1/custom/orders/:orderId\" method=\"GET\">\n        <service class=\"Vendor\\Module\\Api\\OrderServiceInterface\"\n                 method=\"getOrder\"/>\n        <resources>\n            <resource ref=\"Vendor_Module::order_view\"/>\n        </resources>\n    </route>\n\n    <!-- POST endpoint with request body -->\n    <route url=\"/V1/custom/orders\" method=\"POST\">\n        <service class=\"Vendor\\Module\\Api\\OrderServiceInterface\"\n                 method=\"createOrder\"/>\n        <resources>\n            <resource ref=\"Vendor_Module::order_create\"/>\n        </resources>\n        <data>\n            <parameter name=\"orderData\" force=\"true\">%order_data%</parameter>\n        </data>\n    </route>\n\n    <!-- Anonymous access (no auth required) -->\n    <route url=\"/V1/custom/public-info\" method=\"GET\">\n        <service class=\"Vendor\\Module\\Api\\InfoServiceInterface\" method=\"getInfo\"/>\n        <resources>\n            <resource ref=\"anonymous\"/>\n        </resources>\n    </route>\n</routes>",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "webapi",
      "integration-security",
      "async-bulk"
    ]
  },
  {
    "id": 69,
    "category": "Web API",
    "difficulty": "Medium",
    "question": "How is access control implemented for custom API endpoints in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "By checking user roles in the service class constructor"
      },
      {
        "id": "B",
        "text": "By defining resource in webapi.xml that maps to acl.xml permissions"
      },
      {
        "id": "C",
        "text": "By implementing AuthorizationInterface in the service class"
      },
      {
        "id": "D",
        "text": "By using middleware to intercept requests"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "API authorization uses ACL resources defined in acl.xml and referenced in webapi.xml.\n\nWhy B is correct:\n- webapi.xml <resource ref=\"...\"/> links to ACL resource\n- ACL resources defined in acl.xml hierarchy\n- Admin users/integrations assigned resources via roles\n- Framework checks authorization before calling service\n- Built-in resources: anonymous, self (customer), Magento_*::*\n\nWhy others are incorrect:\n- A: Authorization happens before service method is called\n- C: No such interface for API authorization\n- D: Not middleware-based, uses declarative configuration",
    "codeExample": "<!-- etc/acl.xml - Define ACL resources -->\n<acl>\n    <resources>\n        <resource id=\"Magento_Backend::admin\">\n            <resource id=\"Vendor_Module::custom_api\" title=\"Custom API Access\">\n                <resource id=\"Vendor_Module::order_view\" title=\"View Orders\"/>\n                <resource id=\"Vendor_Module::order_create\" title=\"Create Orders\"/>\n                <resource id=\"Vendor_Module::order_delete\" title=\"Delete Orders\"/>\n            </resource>\n        </resource>\n    </resources>\n</acl>\n\n<!-- etc/webapi.xml - Reference ACL in routes -->\n<route url=\"/V1/custom/orders/:id\" method=\"GET\">\n    <service class=\"Vendor\\Module\\Api\\OrderServiceInterface\" method=\"get\"/>\n    <resources>\n        <resource ref=\"Vendor_Module::order_view\"/>\n    </resources>\n</route>\n\n<route url=\"/V1/custom/orders/:id\" method=\"DELETE\">\n    <service class=\"Vendor\\Module\\Api\\OrderServiceInterface\" method=\"delete\"/>\n    <resources>\n        <resource ref=\"Vendor_Module::order_delete\"/>\n    </resources>\n</route>\n\n<!-- Special resources -->\n<!-- ref=\"anonymous\" - No authentication required -->\n<!-- ref=\"self\" - Customer can access own data -->",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "webapi",
      "integration-security",
      "async-bulk"
    ]
  },
  {
    "id": 70,
    "category": "Web API",
    "difficulty": "Medium",
    "question": "When should an architect choose SOAP over REST for a Magento 2 integration?",
    "options": [
      {
        "id": "A",
        "text": "When the integration requires JSON response format"
      },
      {
        "id": "B",
        "text": "When a strict contract with WSDL validation is required"
      },
      {
        "id": "C",
        "text": "When better performance is needed"
      },
      {
        "id": "D",
        "text": "When the client is a mobile application"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "SOAP is preferred when strict contracts and formal validation are required.\n\nWhy B is correct:\n- WSDL provides formal contract definition\n- Strong typing and validation built-in\n- Enterprise systems often require WSDL contracts\n- Automatic client generation from WSDL\n- Better error handling with SOAP faults\n\nWhy others are incorrect:\n- A: SOAP uses XML, not JSON (REST uses JSON)\n- C: REST generally has better performance (less overhead)\n- D: Mobile apps typically prefer REST (lightweight, JSON)",
    "codeExample": "// SOAP Endpoint Access\n// WSDL URL: https://magento.test/soap/default?wsdl&services=catalogProductRepositoryV1\n\n// PHP SOAP Client Example\n$wsdlUrl = 'https://magento.test/soap/default?wsdl&services=catalogProductRepositoryV1';\n\n$opts = [\n    'http' => ['header' => \"Authorization: Bearer {$token}\"]\n];\n$context = stream_context_create($opts);\n\n$client = new SoapClient($wsdlUrl, [\n    'stream_context' => $context,\n    'soap_version' => SOAP_1_2\n]);\n\n// Strongly typed call\n$result = $client->catalogProductRepositoryV1Get(['sku' => 'SKU123']);\n\n// REST Alternative (simpler, JSON)\n$response = $httpClient->get('/rest/V1/products/SKU123', [\n    'headers' => ['Authorization' => 'Bearer ' . $token]\n]);\n$product = json_decode($response->getBody());\n\n// Use SOAP when:\n// - Enterprise integration requiring WSDL contracts\n// - Legacy systems that only support SOAP\n// - Formal API validation requirements",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "webapi",
      "integration-security",
      "async-bulk"
    ]
  },
  {
    "id": 71,
    "category": "Web API",
    "difficulty": "Hard",
    "question": "What authentication methods are available for Magento 2 REST API, and when should each be used?",
    "options": [
      {
        "id": "A",
        "text": "Only OAuth 1.0 is supported for all API access"
      },
      {
        "id": "B",
        "text": "Token-based for integrations, OAuth for third-party apps, Session for admin Ajax"
      },
      {
        "id": "C",
        "text": "Basic HTTP authentication for all scenarios"
      },
      {
        "id": "D",
        "text": "API keys stored in database for all access types"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento 2 supports multiple authentication methods for different use cases.\n\nWhy B is correct:\n- Token-based (Bearer): Simple integrations, server-to-server\n  - Admin token: POST /V1/integration/admin/token\n  - Customer token: POST /V1/integration/customer/token\n\n- OAuth 1.0a: Third-party applications\n  - Full OAuth flow with consumer key/secret\n  - Used for integrations in System > Integrations\n\n- Session-based: Admin panel Ajax requests\n  - Uses existing admin session\n  - For admin UI components calling API\n\nWhy others are incorrect:\n- A: Multiple methods supported, not just OAuth\n- C: Basic auth not supported by default\n- D: API keys are not the authentication mechanism",
    "codeExample": "// 1. Token-based Authentication (Simple integrations)\n// Get admin token\nPOST /rest/V1/integration/admin/token\n{\"username\": \"admin\", \"password\": \"admin123\"}\n// Response: \"abc123token...\"\n\n// Use token in requests\nGET /rest/V1/products/SKU123\nAuthorization: Bearer abc123token...\n\n// 2. OAuth 1.0a (Third-party apps)\n// Configured in Admin: System > Integrations\n// Full OAuth handshake with consumer credentials\n$oauth = new OAuth($consumerKey, $consumerSecret);\n$oauth->setToken($accessToken, $accessSecret);\n$oauth->fetch($apiUrl);\n\n// 3. Session-based (Admin Ajax)\n// Already authenticated via admin session\n// Used by admin UI components\n$.ajax({\n    url: '/rest/V1/products/SKU123',\n    beforeSend: function(xhr) {\n        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    }\n    // Session cookie sent automatically\n});",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "webapi",
      "integration-security",
      "async-bulk"
    ]
  },
  {
    "id": 72,
    "category": "Web API",
    "difficulty": "Medium",
    "question": "How can a developer customize the response format or add additional processing to API responses?",
    "options": [
      {
        "id": "A",
        "text": "Override the REST controller class"
      },
      {
        "id": "B",
        "text": "Use a plugin on the service method or implement custom processors"
      },
      {
        "id": "C",
        "text": "Modify the webapi.xml response format attribute"
      },
      {
        "id": "D",
        "text": "Create a custom response renderer class"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "API responses can be customized using plugins on service methods or custom processors.\n\nWhy B is correct:\n- Plugins on service interface methods (before/after/around)\n- Modify input parameters or output data\n- Processors in webapi.xml for special handling\n- Extension attributes for adding data to responses\n- Maintains separation of concerns\n\nWhy others are incorrect:\n- A: REST controllers are part of framework, not meant to be overridden\n- C: No response format attribute in webapi.xml\n- D: Response rendering is handled by framework serializers",
    "codeExample": "// Method 1: Plugin on Service Method\nclass ProductRepositoryPlugin\n{\n    public function afterGet(\n        ProductRepositoryInterface $subject,\n        ProductInterface $result\n    ) {\n        // Add custom data to response\n        $extensionAttributes = $result->getExtensionAttributes();\n        $extensionAttributes->setCustomData($this->getCustomData($result));\n        $result->setExtensionAttributes($extensionAttributes);\n\n        return $result;\n    }\n}\n\n// di.xml\n<type name=\"Magento\\Catalog\\Api\\ProductRepositoryInterface\">\n    <plugin name=\"add_custom_data\" type=\"Vendor\\Module\\Plugin\\ProductRepositoryPlugin\"/>\n</type>\n\n// Method 2: Data Processor for complex transformations\n// webapi.xml\n<route url=\"/V1/custom/products/:sku\" method=\"GET\">\n    <service class=\"Vendor\\Module\\Api\\ProductServiceInterface\" method=\"get\"/>\n    <resources><resource ref=\"anonymous\"/></resources>\n    <data>\n        <parameter name=\"sku\" force=\"true\">%sku%</parameter>\n    </data>\n</route>\n\n// Custom service returns exactly what you want\npublic function get($sku): array {\n    return ['sku' => $sku, 'formatted_price' => '$99.99'];\n}",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "webapi",
      "integration-security",
      "async-bulk"
    ]
  },
  {
    "id": 73,
    "category": "GraphQL",
    "difficulty": "Medium",
    "question": "How do you extend an existing GraphQL type in Magento 2 to add custom fields?",
    "options": [
      {
        "id": "A",
        "text": "Override the original schema.graphqls file"
      },
      {
        "id": "B",
        "text": "Use the 'extend type' keyword in your module's schema.graphqls"
      },
      {
        "id": "C",
        "text": "Create a plugin on the GraphQL resolver"
      },
      {
        "id": "D",
        "text": "Modify the core GraphQL module configuration"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "The 'extend type' keyword allows adding fields to existing GraphQL types without modifying core files.\n\nWhy B is correct:\n- 'extend type TypeName' adds fields to existing type\n- Defined in module's etc/schema.graphqls\n- Magento merges all schema files automatically\n- Requires corresponding resolver for new fields\n- Non-destructive extension pattern\n\nWhy others are incorrect:\n- A: Overriding core files is bad practice\n- C: Plugins work on resolvers, not schema definition\n- D: Core module modification breaks upgrades",
    "codeExample": "# etc/schema.graphqls\n\n# Extend existing Product type with custom field\nextend type ProductInterface {\n    warranty_period: Int @doc(description: \"Warranty period in months\")\n    custom_label: String @resolver(class: \"Vendor\\Module\\Model\\Resolver\\CustomLabel\")\n}\n\n# Extend Query type to add custom query\nextend type Query {\n    customProducts(\n        filter: ProductFilterInput\n        pageSize: Int = 20\n        currentPage: Int = 1\n    ): Products @resolver(class: \"Vendor\\Module\\Model\\Resolver\\CustomProducts\")\n}\n\n# Extend Mutation type\nextend type Mutation {\n    addWarranty(input: WarrantyInput!): WarrantyOutput\n        @resolver(class: \"Vendor\\Module\\Model\\Resolver\\AddWarranty\")\n}\n\n# Define custom input/output types\ninput WarrantyInput {\n    product_id: Int!\n    period: Int!\n}\n\ntype WarrantyOutput {\n    success: Boolean!\n    message: String\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 74,
    "category": "GraphQL",
    "difficulty": "Medium",
    "question": "What interface must a GraphQL resolver class implement in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Magento\\Framework\\GraphQl\\Query\\ResolverInterface"
      },
      {
        "id": "B",
        "text": "Magento\\Framework\\GraphQl\\ResolverInterface"
      },
      {
        "id": "C",
        "text": "Magento\\GraphQl\\Model\\ResolverInterface"
      },
      {
        "id": "D",
        "text": "Magento\\Framework\\GraphQl\\Query\\Resolver\\ResolverInterface"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "GraphQL resolvers must implement ResolverInterface from the GraphQl Query namespace.\n\nWhy A is correct:\n- Full path: Magento\\Framework\\GraphQl\\Query\\ResolverInterface\n- Requires resolve() method implementation\n- Receives Field, Context, ResolveInfo, and arguments\n- Returns array or object matching GraphQL type\n- Context contains store, customer, and extension info\n\nWhy others are incorrect:\n- B, C, D: These are not the correct namespace/interface paths",
    "codeExample": "namespace Vendor\\Module\\Model\\Resolver;\n\nuse Magento\\Framework\\GraphQl\\Query\\ResolverInterface;\nuse Magento\\Framework\\GraphQl\\Config\\Element\\Field;\nuse Magento\\Framework\\GraphQl\\Schema\\Type\\ResolveInfo;\n\nclass CustomProducts implements ResolverInterface\n{\n    public function resolve(\n        Field $field,\n        $context,\n        ResolveInfo $info,\n        array $value = null,\n        array $args = null\n    ) {\n        // Access store context\n        $storeId = (int)$context->getExtensionAttributes()->getStore()->getId();\n\n        // Access arguments from GraphQL query\n        $pageSize = $args['pageSize'] ?? 20;\n        $currentPage = $args['currentPage'] ?? 1;\n\n        // Return data matching ProductsOutput type\n        return [\n            'items' => $this->getProducts($args),\n            'total_count' => $this->getTotalCount($args),\n            'page_info' => [\n                'page_size' => $pageSize,\n                'current_page' => $currentPage\n            ]\n        ];\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 75,
    "category": "GraphQL",
    "difficulty": "Hard",
    "question": "How does Magento implement caching for GraphQL queries, and what interface must be implemented for custom cache identities?",
    "options": [
      {
        "id": "A",
        "text": "GraphQL responses are not cached in Magento"
      },
      {
        "id": "B",
        "text": "Implement CacheIdFactorProviderInterface to add custom cache factors"
      },
      {
        "id": "C",
        "text": "Use standard block caching with cache tags"
      },
      {
        "id": "D",
        "text": "Implement CacheableInterface on the resolver class"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "GraphQL uses CacheIdFactorProviderInterface to determine cache identity factors.\n\nWhy B is correct:\n- GraphQL GET requests are cached by Varnish/Fastly\n- Cache ID composed of multiple factors (store, currency, customer group)\n- Custom factors via CacheIdFactorProviderInterface\n- Resolvers can provide cache identity via IdentityInterface\n- X-Magento-Cache-Id header used for cache key\n\nWhy others are incorrect:\n- A: GraphQL GET queries ARE cached\n- C: Block caching is for HTML, not GraphQL\n- D: No such interface for resolvers",
    "codeExample": "// Custom Cache Factor Provider\nnamespace Vendor\\Module\\Model\\CacheId;\n\nuse Magento\\GraphQlCache\\Model\\CacheId\\CacheIdFactorProviderInterface;\n\nclass CustomCacheFactor implements CacheIdFactorProviderInterface\n{\n    public function getFactorName(): string\n    {\n        return 'CUSTOM_FACTOR';\n    }\n\n    public function getFactorValue(ContextInterface $context): string\n    {\n        // Return value that affects cache identity\n        return $this->getCustomValue($context);\n    }\n}\n\n// di.xml registration\n<type name=\"Magento\\GraphQlCache\\Model\\CacheId\\CacheIdCalculator\">\n    <arguments>\n        <argument name=\"idFactorProviders\" xsi:type=\"array\">\n            <item name=\"custom_factor\" xsi:type=\"object\">\n                Vendor\\Module\\Model\\CacheId\\CustomCacheFactor\n            </item>\n        </argument>\n    </arguments>\n</type>\n\n// Resolver with Cache Identity\nclass ProductResolver implements ResolverInterface, IdentityInterface\n{\n    public function getIdentities(array $resolvedData): array\n    {\n        // Return cache tags for invalidation\n        return ['cat_p_' . $resolvedData['entity_id']];\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 76,
    "category": "GraphQL",
    "difficulty": "Medium",
    "question": "What is the correct way to define a GraphQL mutation that accepts complex input in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Define parameters directly in the mutation signature"
      },
      {
        "id": "B",
        "text": "Use an input type and reference it in the mutation with ! for required"
      },
      {
        "id": "C",
        "text": "Pass JSON string as the only parameter"
      },
      {
        "id": "D",
        "text": "Use query variables without type definitions"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "GraphQL mutations should use input types for complex data structures.\n\nWhy B is correct:\n- Input types group related parameters\n- ! suffix marks fields as required (non-nullable)\n- Clear contract for API consumers\n- Enables validation and documentation\n- Follows GraphQL best practices\n\nWhy others are incorrect:\n- A: Direct parameters don't scale for complex inputs\n- C: JSON strings bypass GraphQL type system\n- D: Variables must have type definitions",
    "codeExample": "# schema.graphqls\n\n# Define input type for mutation\ninput CreateOrderInput {\n    cart_id: String!\n    shipping_address: AddressInput!\n    billing_address: AddressInput\n    payment_method: PaymentMethodInput!\n    shipping_method: String!\n}\n\ninput AddressInput {\n    firstname: String!\n    lastname: String!\n    street: [String!]!\n    city: String!\n    region: String\n    postcode: String!\n    country_code: String!\n    telephone: String!\n}\n\ninput PaymentMethodInput {\n    code: String!\n    additional_data: [KeyValueInput]\n}\n\n# Define mutation with input type\ntype Mutation {\n    createOrder(input: CreateOrderInput!): CreateOrderOutput\n        @resolver(class: \"Vendor\\Module\\Model\\Resolver\\CreateOrder\")\n}\n\ntype CreateOrderOutput {\n    order_id: String\n    order_number: String\n    success: Boolean!\n    message: String\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 77,
    "category": "GraphQL",
    "difficulty": "Hard",
    "question": "How can you optimize GraphQL resolver performance to avoid N+1 query problems?",
    "options": [
      {
        "id": "A",
        "text": "Use synchronous database queries in each resolver"
      },
      {
        "id": "B",
        "text": "Implement BatchResolverInterface or use DataLoader pattern"
      },
      {
        "id": "C",
        "text": "Cache all resolver results in session"
      },
      {
        "id": "D",
        "text": "Limit the number of fields in the query"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "BatchResolverInterface allows batching multiple resolver calls into a single database query.\n\nWhy B is correct:\n- BatchResolverInterface for resolving multiple items at once\n- Collects all IDs first, then single batch query\n- DataLoader pattern defers execution and batches\n- Reduces N+1 to 1+1 query pattern\n- Critical for nested relationships\n\nWhy others are incorrect:\n- A: Synchronous queries cause N+1 problem\n- C: Session caching doesn't solve N+1\n- D: Limiting fields doesn't address query batching",
    "codeExample": "// BatchResolverInterface Implementation\nnamespace Vendor\\Module\\Model\\Resolver;\n\nuse Magento\\Framework\\GraphQl\\Query\\Resolver\\BatchResolverInterface;\nuse Magento\\Framework\\GraphQl\\Query\\Resolver\\BatchResponse;\n\nclass ProductImages implements BatchResolverInterface\n{\n    public function resolve(\n        ContextInterface $context,\n        Field $field,\n        array $requests\n    ): BatchResponse {\n        // Collect all product IDs from batch requests\n        $productIds = [];\n        foreach ($requests as $request) {\n            $productIds[] = $request->getValue()['entity_id'];\n        }\n\n        // Single batch query for all products\n        $imagesData = $this->imageRepository->getByProductIds($productIds);\n\n        // Build response for each request\n        $response = new BatchResponse();\n        foreach ($requests as $request) {\n            $productId = $request->getValue()['entity_id'];\n            $response->addResponse(\n                $request,\n                $imagesData[$productId] ?? []\n            );\n        }\n\n        return $response;\n    }\n}\n\n// Without batching: N queries (one per product)\n// With batching: 1 query (all products at once)",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 78,
    "category": "GraphQL",
    "difficulty": "Medium",
    "question": "What are the main components of PWA Studio architecture for Adobe Commerce?",
    "options": [
      {
        "id": "A",
        "text": "Venia (UI components) and Peregrine (business logic hooks)"
      },
      {
        "id": "B",
        "text": "React Router and Redux for state management"
      },
      {
        "id": "C",
        "text": "Vue.js components and Vuex store"
      },
      {
        "id": "D",
        "text": "Angular modules and services"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "PWA Studio uses Venia for UI and Peregrine for business logic.\n\nWhy A is correct:\n- Venia: Reference storefront UI components\n  - React components for common ecommerce patterns\n  - Customizable and extensible\n  - Uses CSS Modules for styling\n\n- Peregrine: Business logic library\n  - Custom React hooks (useTalons)\n  - GraphQL queries/mutations\n  - Cart, checkout, customer logic\n  - Reusable across different UIs\n\nWhy others are incorrect:\n- B: While React is used, Redux is not the main state solution\n- C: PWA Studio is React-based, not Vue\n- D: Not Angular-based",
    "codeExample": "// Peregrine Talon (Business Logic)\nimport { useProduct } from '@magento/peregrine/lib/talons/Product/useProduct';\n\n// Venia Component (UI)\nimport { ProductFullDetail } from '@magento/venia-ui/lib/components/ProductFullDetail';\n\n// Custom component using Peregrine talon\nconst MyProductPage = () => {\n    // Peregrine hook handles GraphQL, state, logic\n    const talonProps = useProduct({\n        queries: {\n            getProductQuery: GET_PRODUCT_QUERY\n        }\n    });\n\n    const { product, loading, error } = talonProps;\n\n    if (loading) return <LoadingIndicator />;\n    if (error) return <ErrorView />;\n\n    // Venia component for UI\n    return <ProductFullDetail product={product} />;\n};\n\n// PWA Studio Architecture:\n// Peregrine (talons)  Business logic, GraphQL, state\n// Venia (components)  UI presentation\n// Buildpack  Build tools, webpack configuration\n// UPWARD  Server-side rendering, routing",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 79,
    "category": "GraphQL",
    "difficulty": "Hard",
    "question": "What is the correct sequence of GraphQL mutations for a headless checkout flow?",
    "options": [
      {
        "id": "A",
        "text": "placeOrder  setPayment  setShipping  createCart"
      },
      {
        "id": "B",
        "text": "createEmptyCart  addToCart  setShippingAddress  setShippingMethod  setPaymentMethod  placeOrder"
      },
      {
        "id": "C",
        "text": "addToCart  checkout  pay  complete"
      },
      {
        "id": "D",
        "text": "initCheckout  processPayment  finalizeOrder"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Headless checkout requires a specific sequence of GraphQL mutations.\n\nWhy B is correct:\n- createEmptyCart: Initialize cart, get cart ID\n- addProductsToCart: Add items to cart\n- setShippingAddresses: Set delivery address\n- setShippingMethods: Choose shipping option\n- setPaymentMethod: Select payment method\n- setBillingAddress: Set billing if different\n- placeOrder: Complete the order\n\nWhy others are incorrect:\n- A: Reversed order, can't place order first\n- C: Not Magento's mutation names\n- D: Not Magento's mutation names",
    "codeExample": "// 1. Create empty cart\nmutation {\n    createEmptyCart\n}\n// Returns: \"abc123cartId\"\n\n// 2. Add products to cart\nmutation {\n    addProductsToCart(cartId: \"abc123\", cartItems: [\n        {sku: \"SKU1\", quantity: 2}\n    ]) {\n        cart { items { id quantity } }\n    }\n}\n\n// 3. Set shipping address\nmutation {\n    setShippingAddressesOnCart(input: {\n        cart_id: \"abc123\"\n        shipping_addresses: [{\n            address: {\n                firstname: \"John\", lastname: \"Doe\"\n                street: [\"123 Main St\"], city: \"Austin\"\n                region: \"TX\", postcode: \"78701\"\n                country_code: \"US\", telephone: \"555-1234\"\n            }\n        }]\n    }) { cart { shipping_addresses { available_shipping_methods { carrier_code method_code } } } }\n}\n\n// 4. Set shipping method\nmutation {\n    setShippingMethodsOnCart(input: {\n        cart_id: \"abc123\"\n        shipping_methods: [{ carrier_code: \"flatrate\", method_code: \"flatrate\" }]\n    }) { cart { shipping_addresses { selected_shipping_method { carrier_code } } } }\n}\n\n// 5. Set payment method\nmutation {\n    setPaymentMethodOnCart(input: {\n        cart_id: \"abc123\"\n        payment_method: { code: \"checkmo\" }\n    }) { cart { selected_payment_method { code } } }\n}\n\n// 6. Place order\nmutation {\n    placeOrder(input: { cart_id: \"abc123\" }) {\n        order { order_number }\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 80,
    "category": "GraphQL",
    "difficulty": "Medium",
    "question": "How is customer authentication handled in GraphQL queries and mutations?",
    "options": [
      {
        "id": "A",
        "text": "Session cookies are automatically sent with each request"
      },
      {
        "id": "B",
        "text": "Customer token in Authorization header as Bearer token"
      },
      {
        "id": "C",
        "text": "API key passed as query parameter"
      },
      {
        "id": "D",
        "text": "Username and password in each request body"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "GraphQL uses Bearer token authentication for customer operations.\n\nWhy B is correct:\n- Generate token via generateCustomerToken mutation\n- Pass token in Authorization: Bearer header\n- Token required for customer-specific operations\n- Token validates customer identity for each request\n- Can revoke token via revokeCustomerToken\n\nWhy others are incorrect:\n- A: GraphQL is stateless, no sessions\n- C: No API key mechanism in GraphQL\n- D: Credentials only used for token generation",
    "codeExample": "// 1. Generate customer token\nmutation {\n    generateCustomerToken(\n        email: \"customer@example.com\"\n        password: \"password123\"\n    ) {\n        token\n    }\n}\n// Returns: { \"token\": \"abc123customertoken...\" }\n\n// 2. Use token in subsequent requests\n// HTTP Header: Authorization: Bearer abc123customertoken...\n\nquery {\n    customer {\n        firstname\n        lastname\n        email\n        orders {\n            items {\n                order_number\n                total { grand_total { value currency } }\n            }\n        }\n    }\n}\n\n// 3. For mutations requiring auth\nmutation {\n    updateCustomer(input: {\n        firstname: \"Jane\"\n    }) {\n        customer {\n            firstname\n        }\n    }\n}\n\n// 4. Revoke token on logout\nmutation {\n    revokeCustomerToken {\n        result\n    }\n}\n\n// GraphQL Context provides customer info\n// $context->getUserId() returns customer ID if authenticated",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 81,
    "category": "GraphQL",
    "difficulty": "Medium",
    "question": "What files are required to create a custom GraphQL endpoint in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Only schema.graphqls file"
      },
      {
        "id": "B",
        "text": "schema.graphqls, resolver class, and di.xml registration"
      },
      {
        "id": "C",
        "text": "webapi.xml with GraphQL route type"
      },
      {
        "id": "D",
        "text": "graphql.xml configuration file"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "A custom GraphQL endpoint requires schema definition, resolver, and DI configuration.\n\nWhy B is correct:\n- schema.graphqls: Define types, queries, mutations\n- Resolver class: Implement business logic\n- di.xml: Register resolver class (if using interfaces)\n- @resolver directive connects schema to PHP class\n- Optional: DataProvider for data preparation\n\nWhy others are incorrect:\n- A: Schema alone doesn't provide implementation\n- C: webapi.xml is for REST/SOAP, not GraphQL\n- D: No such file in Magento GraphQL",
    "codeExample": "# 1. etc/schema.graphqls\ntype Query {\n    customEndpoint(id: Int!): CustomData\n        @resolver(class: \"Vendor\\Module\\Model\\Resolver\\CustomData\")\n        @doc(description: \"Get custom data by ID\")\n        @cache(cacheIdentity: \"Vendor\\Module\\Model\\Resolver\\CustomData\\Identity\")\n}\n\ntype CustomData {\n    id: Int\n    name: String\n    value: Float\n}\n\n# 2. Model/Resolver/CustomData.php\nnamespace Vendor\\Module\\Model\\Resolver;\n\nuse Magento\\Framework\\GraphQl\\Query\\ResolverInterface;\n\nclass CustomData implements ResolverInterface\n{\n    public function resolve($field, $context, $info, $value = null, $args = null)\n    {\n        $id = $args['id'];\n        return [\n            'id' => $id,\n            'name' => 'Custom Item',\n            'value' => 99.99\n        ];\n    }\n}\n\n# 3. etc/di.xml (if needed for dependencies)\n<type name=\"Vendor\\Module\\Model\\Resolver\\CustomData\">\n    <arguments>\n        <argument name=\"repository\" xsi:type=\"object\">\n            Vendor\\Module\\Api\\CustomRepositoryInterface\n        </argument>\n    </arguments>\n</type>",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 82,
    "category": "GraphQL",
    "difficulty": "Medium",
    "question": "How should errors be handled in GraphQL resolvers to return proper error responses?",
    "options": [
      {
        "id": "A",
        "text": "Return null and let the framework handle it"
      },
      {
        "id": "B",
        "text": "Throw GraphQlInputException or GraphQlAuthorizationException"
      },
      {
        "id": "C",
        "text": "Return an array with 'error' key"
      },
      {
        "id": "D",
        "text": "Use try-catch and return empty result"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "GraphQL has specific exception types for different error scenarios.\n\nWhy B is correct:\n- GraphQlInputException: Invalid input data (400-level)\n- GraphQlAuthorizationException: Auth failures (401/403)\n- GraphQlNoSuchEntityException: Resource not found (404)\n- GraphQlAlreadyExistsException: Duplicate resource\n- Exceptions formatted in GraphQL errors array\n\nWhy others are incorrect:\n- A: Null doesn't explain the error\n- C: Not standard GraphQL error format\n- D: Silent failures hide problems",
    "codeExample": "namespace Vendor\\Module\\Model\\Resolver;\n\nuse Magento\\Framework\\GraphQl\\Exception\\GraphQlInputException;\nuse Magento\\Framework\\GraphQl\\Exception\\GraphQlAuthorizationException;\nuse Magento\\Framework\\GraphQl\\Exception\\GraphQlNoSuchEntityException;\n\nclass CustomResolver implements ResolverInterface\n{\n    public function resolve($field, $context, $info, $value = null, $args = null)\n    {\n        // Validation error\n        if (empty($args['id'])) {\n            throw new GraphQlInputException(\n                __('ID is required')\n            );\n        }\n\n        // Authorization check\n        if (!$context->getUserId()) {\n            throw new GraphQlAuthorizationException(\n                __('Customer must be logged in')\n            );\n        }\n\n        // Not found\n        $item = $this->repository->getById($args['id']);\n        if (!$item->getId()) {\n            throw new GraphQlNoSuchEntityException(\n                __('Item with ID %1 not found', $args['id'])\n            );\n        }\n\n        return $item->getData();\n    }\n}\n\n// Response format for errors:\n{\n    \"errors\": [{\n        \"message\": \"ID is required\",\n        \"extensions\": {\n            \"category\": \"graphql-input\"\n        },\n        \"path\": [\"customEndpoint\"]\n    }],\n    \"data\": { \"customEndpoint\": null }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "graphql",
      "headless",
      "resolver-patterns"
    ]
  },
  {
    "id": 83,
    "category": "Message Queue",
    "difficulty": "Hard",
    "question": "What configuration files are required to set up a custom message queue topology in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "queue.xml only"
      },
      {
        "id": "B",
        "text": "communication.xml for topics, queue_topology.xml for exchanges/queues, queue_consumer.xml for consumers"
      },
      {
        "id": "C",
        "text": "amqp.xml for RabbitMQ configuration"
      },
      {
        "id": "D",
        "text": "events.xml with queue attribute"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Message queue topology requires three configuration files working together.\n\nWhy B is correct:\n- communication.xml: Define topics (message types) and handlers\n- queue_topology.xml: Define exchanges, queues, and bindings\n- queue_consumer.xml: Define consumers that process messages\n- queue_publisher.xml: Optional, for custom publishers\n- All in module's etc/ directory\n\nWhy others are incorrect:\n- A: queue.xml is deprecated, replaced by three files\n- C: No such file, AMQP config is in env.php\n- D: events.xml is for observers, not queues",
    "codeExample": "<!-- etc/communication.xml - Define topics -->\n<config>\n    <topic name=\"custom.topic.name\" request=\"Vendor\\Module\\Api\\Data\\MessageInterface\">\n        <handler name=\"customHandler\" type=\"Vendor\\Module\\Model\\Consumer\" method=\"process\"/>\n    </topic>\n</config>\n\n<!-- etc/queue_topology.xml - Define queues -->\n<config>\n    <exchange name=\"magento\" type=\"topic\" connection=\"amqp\">\n        <binding id=\"customBinding\" topic=\"custom.topic.name\"\n                 destinationType=\"queue\" destination=\"custom.queue\"/>\n    </exchange>\n</config>\n\n<!-- etc/queue_consumer.xml - Define consumers -->\n<config>\n    <consumer name=\"customConsumer\"\n              queue=\"custom.queue\"\n              handler=\"Vendor\\Module\\Model\\Consumer::process\"\n              consumerInstance=\"Magento\\Framework\\MessageQueue\\Consumer\"\n              connection=\"amqp\"/>\n</config>\n\n// Run consumer: bin/magento queue:consumers:start customConsumer",
    "examDomain": "Design",
    "objectiveTags": [
      "message-queue",
      "asynchronous-operations",
      "rabbitmq"
    ]
  },
  {
    "id": 84,
    "category": "Message Queue",
    "difficulty": "Medium",
    "question": "When should an architect choose asynchronous message queue processing over synchronous processing?",
    "options": [
      {
        "id": "A",
        "text": "When immediate response is required for the user"
      },
      {
        "id": "B",
        "text": "When the operation is time-consuming and doesn't need immediate completion"
      },
      {
        "id": "C",
        "text": "When processing simple database queries"
      },
      {
        "id": "D",
        "text": "When the operation must be atomic with the triggering action"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Async processing is ideal for time-consuming operations that can be deferred.\n\nWhy B is correct:\n- Long-running operations (email sending, export generation)\n- Operations that can fail and retry\n- High-volume operations (bulk imports)\n- External API calls that may be slow\n- Tasks that don't block user experience\n\nWhy others are incorrect:\n- A: Immediate response needs sync processing\n- C: Simple queries don't need async overhead\n- D: Atomic operations require sync processing",
    "codeExample": "// Async: Publish to queue (returns immediately)\nclass ProductExportService\n{\n    public function __construct(\n        private PublisherInterface $publisher\n    ) {}\n\n    public function exportProducts(array $productIds): void\n    {\n        // Returns immediately - processing happens later\n        foreach ($productIds as $productId) {\n            $this->publisher->publish(\n                'product.export',\n                json_encode(['product_id' => $productId])\n            );\n        }\n    }\n}\n\n// Sync: Process immediately (blocks until done)\nclass ProductService\n{\n    public function updateStock(int $productId, int $qty): void\n    {\n        // Must complete before returning\n        $this->stockRepository->updateQty($productId, $qty);\n        $this->indexer->reindexRow($productId);\n        // User waits for all this to complete\n    }\n}\n\n// Use async when:\n// - Sending emails, notifications\n// - Generating reports, exports\n// - Processing bulk operations\n// - Calling external APIs",
    "examDomain": "Design",
    "objectiveTags": [
      "message-queue",
      "asynchronous-operations",
      "rabbitmq"
    ]
  },
  {
    "id": 85,
    "category": "Message Queue",
    "difficulty": "Medium",
    "question": "How is RabbitMQ configured as the message queue backend in Adobe Commerce?",
    "options": [
      {
        "id": "A",
        "text": "In app/etc/config.php under queue section"
      },
      {
        "id": "B",
        "text": "In app/etc/env.php under queue configuration"
      },
      {
        "id": "C",
        "text": "In Admin panel under System > Configuration"
      },
      {
        "id": "D",
        "text": "In composer.json as a dependency"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "RabbitMQ connection settings are configured in env.php.\n\nWhy B is correct:\n- env.php contains environment-specific configuration\n- Queue section defines connection parameters\n- Supports AMQP (RabbitMQ) and MySQL backends\n- Configuration includes host, port, user, password, virtualhost\n- Can have multiple connections for different purposes\n\nWhy others are incorrect:\n- A: config.php is for module states, not queue config\n- C: Admin panel doesn't have queue connection settings\n- D: composer.json is for dependencies, not runtime config",
    "codeExample": "// app/etc/env.php\n'queue' => [\n    'amqp' => [\n        'host' => 'rabbitmq.local',\n        'port' => '5672',\n        'user' => 'magento',\n        'password' => 'magento',\n        'virtualhost' => '/',\n        'ssl' => false,\n        'ssl_options' => []\n    ],\n    // Optional: Configure consumers\n    'consumers_wait_for_messages' => 0,\n    'only_spawn_when_message_available' => 1\n],\n\n// For MySQL-based queue (simpler, less performant)\n'queue' => [\n    'default' => 'db'  // Uses MySQL instead of AMQP\n],\n\n// Check queue status\n// bin/magento queue:consumers:list\n// bin/magento queue:consumers:start <consumer_name>\n\n// Cloud: Configured in .magento.env.yaml\n// stage:\n//   deploy:\n//     QUEUE_CONFIGURATION:\n//       amqp:\n//         host: rabbitmq.internal",
    "examDomain": "Design",
    "objectiveTags": [
      "message-queue",
      "asynchronous-operations",
      "rabbitmq"
    ]
  },
  {
    "id": 86,
    "category": "Message Queue",
    "difficulty": "Hard",
    "question": "How does Magento's Bulk API use message queues for asynchronous processing?",
    "options": [
      {
        "id": "A",
        "text": "Each bulk request creates a database transaction"
      },
      {
        "id": "B",
        "text": "Operations are published to queue, tracked in bulk tables, processed by consumers"
      },
      {
        "id": "C",
        "text": "Bulk requests are processed synchronously in batches"
      },
      {
        "id": "D",
        "text": "External scheduler triggers bulk processing"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Bulk API leverages message queues with tracking tables for async operations.\n\nWhy B is correct:\n- magento_bulk: Tracks bulk operation metadata\n- magento_operation: Individual operation status\n- Messages published to async.operations.* queues\n- Consumers process messages asynchronously\n- Status queryable via API during processing\n\nWhy others are incorrect:\n- A: Transactions are per-operation, not per-bulk\n- C: Processing is async via queue, not sync batches\n- D: No external scheduler, uses queue consumers",
    "codeExample": "// Bulk API Flow\n// 1. Client sends bulk request\nPOST /rest/V1/products (with multiple items)\n\n// 2. BulkManagement creates tracking records\n$bulkUuid = $this->bulkManagement->scheduleBulk(\n    $bulkUuid,\n    $operations,  // Array of OperationInterface\n    'Bulk Product Import',\n    $userId\n);\n\n// 3. Operations published to queue\n// Topic: async.operations.all\n// Each operation serialized and queued\n\n// 4. Consumer processes operations\n// bin/magento queue:consumers:start async.operations.all\n\n// 5. Client checks status\nGET /rest/V1/bulk/{bulkUuid}/status\n\n// Response:\n{\n    \"operations_list\": [\n        {\"id\": 1, \"status\": 1, \"result_message\": \"Success\"},\n        {\"id\": 2, \"status\": 2, \"result_message\": \"Processing\"},\n        {\"id\": 3, \"status\": 4, \"error_code\": 500}\n    ],\n    \"user_type\": 2,\n    \"bulk_id\": \"uuid-here\"\n}\n\n// Status codes: 1=Complete, 2=Processing, 3=NotStarted, 4=Failed",
    "examDomain": "Design",
    "objectiveTags": [
      "message-queue",
      "asynchronous-operations",
      "rabbitmq"
    ]
  },
  {
    "id": 87,
    "category": "Message Queue",
    "difficulty": "Medium",
    "question": "What are deferred operations in Magento and when are they used?",
    "options": [
      {
        "id": "A",
        "text": "Operations that run only at night during low traffic"
      },
      {
        "id": "B",
        "text": "Operations postponed until necessary, like stock reservation or total calculation"
      },
      {
        "id": "C",
        "text": "Deprecated operations scheduled for removal"
      },
      {
        "id": "D",
        "text": "Operations that require manual admin approval"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Deferred operations postpone processing until the result is actually needed.\n\nWhy B is correct:\n- Stock reservations: Deferred until checkout\n- Quote totals: Recalculated when needed\n- Index updates: Batched for efficiency\n- Reduces unnecessary processing\n- Improves performance for abandoned carts\n\nWhy others are incorrect:\n- A: Not time-based scheduling\n- C: Not about deprecation\n- D: Not about approval workflow",
    "codeExample": "// Deferred Stock Reservation (MSI)\n// Reservation not immediately deducted from inventory\n\nclass PlaceReservationsForSalesEvent\n{\n    public function execute(array $items, int $stockId): void\n    {\n        // Reservations are \"pending\" until order ships\n        $reservations = [];\n        foreach ($items as $item) {\n            $reservations[] = $this->reservationBuilder\n                ->setSku($item->getSku())\n                ->setQuantity(-$item->getQty()) // Negative = reserved\n                ->setStockId($stockId)\n                ->setMetadata($metadata)\n                ->build();\n        }\n        // Saved to inventory_reservation table\n        $this->appendReservations->execute($reservations);\n    }\n}\n\n// Deferred Total Calculation\nclass Quote\n{\n    private $totalsCollectedFlag = false;\n\n    public function getGrandTotal()\n    {\n        if (!$this->totalsCollectedFlag) {\n            // Only calculate when actually requested\n            $this->collectTotals();\n        }\n        return $this->getData('grand_total');\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "message-queue",
      "asynchronous-operations",
      "rabbitmq"
    ]
  },
  {
    "id": 88,
    "category": "Message Queue",
    "difficulty": "Hard",
    "question": "How does Magento handle failed message queue operations and poison messages?",
    "options": [
      {
        "id": "A",
        "text": "Failed messages are immediately deleted"
      },
      {
        "id": "B",
        "text": "Messages are retried based on configuration, then moved to error queue after max retries"
      },
      {
        "id": "C",
        "text": "All failures are logged but messages continue processing"
      },
      {
        "id": "D",
        "text": "Failed messages block the entire queue"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento implements retry logic and poison message handling for failed operations.\n\nWhy B is correct:\n- maxRetries configuration in queue_consumer.xml\n- Failed messages requeued for retry\n- After max retries, moved to *.failed queue\n- Poison messages don't block other messages\n- Errors logged for investigation\n\nWhy others are incorrect:\n- A: Messages aren't immediately deleted, they retry\n- C: Failures do affect message disposition\n- D: Parallel processing continues",
    "codeExample": "<!-- etc/queue_consumer.xml -->\n<consumer name=\"product.import\"\n          queue=\"product.import.queue\"\n          handler=\"Vendor\\Module\\Model\\Consumer::process\"\n          maxRetries=\"3\"  <!-- Retry 3 times before failing -->\n          connection=\"amqp\"/>\n\n// Consumer with error handling\nclass Consumer\n{\n    public function process(string $message): void\n    {\n        try {\n            $data = json_decode($message, true);\n            $this->importProduct($data);\n        } catch (\\Exception $e) {\n            // Log error - message will be requeued\n            $this->logger->error('Import failed: ' . $e->getMessage());\n            // Throw exception to trigger retry\n            throw $e;\n        }\n    }\n}\n\n// After maxRetries, message goes to:\n// product.import.queue.failed (poison queue)\n\n// Monitor failed messages:\n// RabbitMQ Management UI shows failed queue\n// Or query: SELECT * FROM queue_message WHERE status = 'failed'\n\n// Reprocess failed messages manually:\n// Move from .failed queue back to main queue",
    "examDomain": "Design",
    "objectiveTags": [
      "message-queue",
      "asynchronous-operations",
      "rabbitmq"
    ]
  },
  {
    "id": 89,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Medium",
    "question": "What is the purpose of .magento.app.yaml in Adobe Commerce Cloud?",
    "options": [
      {
        "id": "A",
        "text": "Define database schema migrations"
      },
      {
        "id": "B",
        "text": "Configure application type, relationships, hooks, and runtime settings"
      },
      {
        "id": "C",
        "text": "Set environment variables for production"
      },
      {
        "id": "D",
        "text": "Define GraphQL schema extensions"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": ".magento.app.yaml is the main application configuration file for Cloud.\n\nWhy B is correct:\n- Defines application type (php:8.1)\n- Configures relationships to services (database, redis, elasticsearch)\n- Sets up build/deploy hooks\n- Configures disk mounts and web locations\n- Defines cron jobs and workers\n\nWhy others are incorrect:\n- A: Schema is in db_schema.xml\n- C: Environment vars are in .magento.env.yaml\n- D: GraphQL schema is in schema.graphqls",
    "codeExample": "# .magento.app.yaml\nname: mymagento\ntype: php:8.2\nbuild:\n    flavor: none\n\nrelationships:\n    database: \"mysql:mysql\"\n    redis: \"redis:redis\"\n    opensearch: \"opensearch:opensearch\"\n\nweb:\n    locations:\n        \"/\":\n            root: \"pub\"\n            passthru: \"/index.php\"\n            index: [\"index.php\"]\n            scripts: true\n        \"/media\":\n            root: \"pub/media\"\n            scripts: false\n            allow: true\n\ndisk: 5120\n\nmounts:\n    \"var\": \"shared:files/var\"\n    \"pub/media\": \"shared:files/media\"\n    \"pub/static\": \"shared:files/static\"\n\nhooks:\n    build: |\n        set -e\n        php ./vendor/bin/ece-tools run scenario/build/generate.xml\n        php ./vendor/bin/ece-tools run scenario/build/transfer.xml\n    deploy: |\n        php ./vendor/bin/ece-tools run scenario/deploy.xml\n    post_deploy: |\n        php ./vendor/bin/ece-tools run scenario/post-deploy.xml\n\ncrons:\n    cronrun:\n        spec: \"*/1 * * * *\"\n        cmd: \"php bin/magento cron:run\"",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 90,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Medium",
    "question": "How are environment-specific variables configured in Adobe Commerce Cloud?",
    "options": [
      {
        "id": "A",
        "text": "In app/etc/config.php for all environments"
      },
      {
        "id": "B",
        "text": "In .magento.env.yaml with stage-specific sections"
      },
      {
        "id": "C",
        "text": "Through Admin panel configuration only"
      },
      {
        "id": "D",
        "text": "In composer.json extra section"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": ".magento.env.yaml allows stage-specific environment configuration.\n\nWhy B is correct:\n- Define variables per stage: global, build, deploy, post-deploy\n- Override default ece-tools behavior\n- Set SCD, database, caching options\n- Environment hierarchy: .magento.env.yaml < Project < Environment\n- Cloud Console can override file settings\n\nWhy others are incorrect:\n- A: config.php is for module states, not Cloud config\n- C: Admin config is stored in database\n- D: composer.json is for dependencies",
    "codeExample": "# .magento.env.yaml\nstage:\n    global:\n        SCD_ON_DEMAND: true\n        SKIP_HTML_MINIFICATION: true\n\n    build:\n        SCD_STRATEGY: \"compact\"\n        SCD_THREADS: 4\n        SKIP_SCD: false\n\n    deploy:\n        DATABASE_CONFIGURATION:\n            _merge: true\n            slave_connection:\n                host: mysql-slave.internal\n        REDIS_BACKEND: \"\\Magento\\Framework\\Cache\\Backend\\Redis\"\n        CACHE_CONFIGURATION:\n            frontend:\n                default:\n                    backend: cache\n                page_cache:\n                    backend: cache\n        QUEUE_CONFIGURATION:\n            amqp:\n                host: rabbitmq.internal\n\n    post-deploy:\n        WARM_UP_PAGES:\n            - \"index.php\"\n            - \"index.php/customer/account/create\"\n\n# Environment variable override (Cloud Console or CLI):\n# magento-cloud variable:set VARIABLE_NAME value --level environment",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 91,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Medium",
    "question": "How are custom domains and routes configured in Adobe Commerce Cloud?",
    "options": [
      {
        "id": "A",
        "text": "In Magento Admin under Stores > Configuration > Web"
      },
      {
        "id": "B",
        "text": "In routes.yaml with upstream and redirect definitions"
      },
      {
        "id": "C",
        "text": "Through DNS settings only"
      },
      {
        "id": "D",
        "text": "In .htaccess file"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "routes.yaml defines how incoming requests are routed in Cloud.\n\nWhy B is correct:\n- Maps domains to application upstream\n- Configures redirects (www to non-www, HTTP to HTTPS)\n- Supports multiple domains per environment\n- SSI (Server Side Includes) configuration\n- Cache configuration per route\n\nWhy others are incorrect:\n- A: Admin settings stored in DB, not routing\n- C: DNS points to Cloud, routes.yaml handles routing\n- D: No .htaccess in Cloud (nginx-based)",
    "codeExample": "# routes.yaml\n\n# Primary domain with HTTPS redirect\n\"https://{default}/\":\n    type: upstream\n    upstream: \"mymagento:http\"\n    cache:\n        enabled: true\n        default_ttl: 300\n\n# Redirect www to non-www\n\"https://www.{default}/\":\n    type: redirect\n    to: \"https://{default}/\"\n\n# Multi-store routing\n\"https://store-b.{default}/\":\n    type: upstream\n    upstream: \"mymagento:http\"\n    id: \"store-b\"\n    cache:\n        enabled: true\n\n# Admin with separate caching rules\n\"https://{default}/admin\":\n    type: upstream\n    upstream: \"mymagento:http\"\n    cache:\n        enabled: false  # Don't cache admin\n\n# {default} resolves to:\n# - master branch: your-project.ent.magento.cloud\n# - staging: staging-xxx.ent.magento.cloud\n# - Production: your-domain.com",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 92,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Medium",
    "question": "How are services like MySQL, Redis, and Elasticsearch defined in Adobe Commerce Cloud?",
    "options": [
      {
        "id": "A",
        "text": "Installed manually on the server"
      },
      {
        "id": "B",
        "text": "In services.yaml with service type and version"
      },
      {
        "id": "C",
        "text": "In docker-compose.yml"
      },
      {
        "id": "D",
        "text": "In Magento's app/etc/env.php"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "services.yaml declares external services for your Cloud environment.\n\nWhy B is correct:\n- Declares service type and version\n- Cloud platform provisions services automatically\n- Relationships in .magento.app.yaml connect app to services\n- Supports MySQL, Redis, Elasticsearch/OpenSearch, RabbitMQ\n- Service configuration persisted across deployments\n\nWhy others are incorrect:\n- A: Cloud manages services, no manual installation\n- C: docker-compose is for local development only\n- D: env.php is auto-generated from relationships",
    "codeExample": "# services.yaml\n\nmysql:\n    type: mysql:10.6\n    disk: 5120\n    configuration:\n        schemas:\n            - main\n        endpoints:\n            mysql:\n                default_schema: main\n                privileges:\n                    main: admin\n\nredis:\n    type: redis:7.0\n\nopensearch:\n    type: opensearch:2\n    disk: 1024\n    configuration:\n        plugins:\n            - analysis-icu\n            - analysis-phonetic\n\nrabbitmq:\n    type: rabbitmq:3.9\n    disk: 512\n\n# .magento.app.yaml relationships\nrelationships:\n    database: \"mysql:mysql\"\n    redis: \"redis:redis\"\n    opensearch: \"opensearch:opensearch\"\n    rabbitmq: \"rabbitmq:rabbitmq\"\n\n# Relationships auto-generate env.php config",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 93,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Hard",
    "question": "What is the key difference between Build and Deploy phases in Adobe Commerce Cloud?",
    "options": [
      {
        "id": "A",
        "text": "Build runs on production, Deploy runs on staging"
      },
      {
        "id": "B",
        "text": "Build phase has no service access, Deploy phase has full service access"
      },
      {
        "id": "C",
        "text": "Build is manual, Deploy is automatic"
      },
      {
        "id": "D",
        "text": "Build runs composer, Deploy runs database migrations"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Build and Deploy phases have fundamentally different service access.\n\nWhy B is correct:\n- BUILD Phase:\n  - No database, Redis, or other service access\n  - Runs composer install, compiles code\n  - Generates DI, static content (if configured)\n  - Read-only application mount\n\n- DEPLOY Phase:\n  - Full access to all services\n  - Runs database migrations\n  - Imports configuration\n  - Warm-up caches\n  - Site is in maintenance mode\n\nWhy others are incorrect:\n- A: Both phases run in same environment\n- C: Both are automated on git push\n- D: Both can run various commands",
    "codeExample": "# .magento.app.yaml hooks\n\nhooks:\n    # BUILD PHASE - No services available!\n    build: |\n        set -e\n        # composer install runs here (no DB needed)\n        php ./vendor/bin/ece-tools run scenario/build/generate.xml\n        php ./vendor/bin/ece-tools run scenario/build/transfer.xml\n        # Static content deployment if configured\n        # Cannot access: database, redis, elasticsearch\n\n    # DEPLOY PHASE - Services available\n    deploy: |\n        php ./vendor/bin/ece-tools run scenario/deploy.xml\n        # Database migrations run here\n        # Configuration import from config.php\n        # Cache flush and warm-up\n\n    # POST-DEPLOY - Site is live\n    post_deploy: |\n        php ./vendor/bin/ece-tools run scenario/post-deploy.xml\n        # Cache warming\n        # Log cleanup\n\n# Key insight:\n# If SCD needs database (admin locales), must run in deploy\n# If SCD can run without DB, better in build (faster deploys)",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 94,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Medium",
    "question": "What do the different SCD_STRATEGY options control in Adobe Commerce Cloud?",
    "options": [
      {
        "id": "A",
        "text": "Database connection pooling strategy"
      },
      {
        "id": "B",
        "text": "How static content is deployed across themes and locales"
      },
      {
        "id": "C",
        "text": "Cache invalidation approach"
      },
      {
        "id": "D",
        "text": "JavaScript bundling method"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "SCD_STRATEGY controls static content deployment parallelization and scope.\n\nWhy B is correct:\n- standard: Deploy all themes/locales in parallel (most resources)\n- quick: Deploy themes in parallel, locales sequentially (balanced)\n- compact: Deploy locales per theme, share common files (least disk)\n- Affects deployment time and disk usage\n- Choose based on store complexity\n\nWhy others are incorrect:\n- A: Database connections configured separately\n- C: Cache has its own configuration\n- D: JS bundling is separate (RequireJS bundling)",
    "codeExample": "# .magento.env.yaml\n\nstage:\n    build:\n        SCD_STRATEGY: \"compact\"  # Options: standard, quick, compact\n        SCD_THREADS: 4\n        SCD_MATRIX:\n            \"Magento/backend\":\n                language:\n                    - en_US\n            \"Magento/luma\":\n                language:\n                    - en_US\n                    - de_DE\n                    - fr_FR\n\n# Strategy comparison:\n# standard:\n#   - All combinations in parallel\n#   - Fastest but uses most memory\n#   - Best for few themes/locales\n\n# quick:\n#   - Themes parallel, locales sequential\n#   - Good balance\n#   - Default strategy\n\n# compact:\n#   - Shares static files across locales\n#   - Smallest disk footprint\n#   - Best for many locales\n#   - May be slower\n\n# Monitor SCD time in deploy log:\n# Static content deployment time: 45.23s",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 95,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Hard",
    "question": "What are the requirements for achieving zero-downtime deployment in Adobe Commerce Cloud?",
    "options": [
      {
        "id": "A",
        "text": "Using only synchronous operations"
      },
      {
        "id": "B",
        "text": "Separate static content, configuration via config.php, proper SCD strategy"
      },
      {
        "id": "C",
        "text": "Disabling all caching during deployment"
      },
      {
        "id": "D",
        "text": "Running deployment only during off-peak hours"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Zero-downtime deployment requires specific configuration patterns.\n\nWhy B is correct:\n- SCD during build phase (no service dependency)\n- Configuration stored in config.php (not database)\n- No database schema changes that lock tables\n- Proper cache warmup in post-deploy\n- Ideally: Run SCD in build, not deploy phase\n\nWhy others are incorrect:\n- A: Sync/async irrelevant to deployment downtime\n- C: Caching should remain enabled\n- D: Timing doesn't affect downtime duration",
    "codeExample": "# Zero-downtime requirements\n\n# 1. SCD in build phase (no DB dependency)\nstage:\n    global:\n        SCD_ON_DEMAND: false  # Generate during build\n    build:\n        SCD_STRATEGY: \"quick\"\n        SKIP_SCD: false  # Don't skip!\n\n# 2. Configuration via config.php (not admin)\n# bin/magento app:config:dump\n# Commits scopes, themes, i18n to config.php\n\n# 3. Static content deployment strategy\n# Build phase: bin/magento setup:static-content:deploy\n# Mounts shared between build and deploy\n\n# 4. No blocking database operations\n# Avoid: Large ALTER TABLE during deploy\n# Use: Declarative schema with async indexing\n\n# 5. Post-deploy warmup\nstage:\n    post-deploy:\n        WARM_UP_PAGES:\n            - \"/\"\n            - \"/customer/account/login\"\n\n# Verify zero-downtime:\n# During deploy, previous container serves traffic\n# New container starts only after deploy completes\n# Symlink switch is atomic",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 96,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Medium",
    "question": "What is the hierarchy of environment variable precedence in Adobe Commerce Cloud?",
    "options": [
      {
        "id": "A",
        "text": "Environment > Project > .magento.env.yaml"
      },
      {
        "id": "B",
        "text": ".magento.env.yaml > Project > Environment"
      },
      {
        "id": "C",
        "text": "Project > Environment > .magento.env.yaml"
      },
      {
        "id": "D",
        "text": "All sources have equal priority"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "Environment variables follow a specific override hierarchy.\n\nWhy A is correct:\n- Environment-level (highest priority)\n- Project-level (applies to all branches)\n- .magento.env.yaml (in repository)\n- Allows per-environment customization\n- Cloud Console or CLI sets env/project vars\n\nWhy others are incorrect:\n- B, C: Incorrect order\n- D: Clear hierarchy exists",
    "codeExample": "# Variable precedence (highest to lowest):\n\n# 1. Environment-level (Cloud Console or CLI)\n# Overrides everything for specific environment\nmagento-cloud variable:set VAR_NAME \"value\" --level environment\n\n# 2. Project-level (applies to all environments)\n# Default for all branches unless overridden\nmagento-cloud variable:set VAR_NAME \"value\" --level project\n\n# 3. .magento.env.yaml (in repository)\nstage:\n    global:\n        SCD_ON_DEMAND: true\n    deploy:\n        REDIS_BACKEND: \"Cm_Cache_Backend_Redis\"\n\n# Practical example:\n# .magento.env.yaml: SCD_THREADS: 4 (default)\n# Project variable: SCD_THREADS: 2 (staging/dev)\n# Environment variable: SCD_THREADS: 8 (production only)\n\n# Result: Production uses 8, others use 2\n\n# View effective values:\n# magento-cloud ssh -e production\n# env | grep MAGENTO",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 97,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Hard",
    "question": "How are custom Fastly VCL snippets deployed in Adobe Commerce Cloud?",
    "options": [
      {
        "id": "A",
        "text": "Uploaded directly to Fastly dashboard"
      },
      {
        "id": "B",
        "text": "Through Magento Admin Fastly module configuration with version activation"
      },
      {
        "id": "C",
        "text": "In .magento.app.yaml vcl section"
      },
      {
        "id": "D",
        "text": "Via composer package installation"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Custom VCL snippets are managed through the Magento Fastly module.\n\nWhy B is correct:\n- Admin > Stores > Configuration > Advanced > System > Fastly\n- Upload custom VCL snippets with priority\n- Create new service version with changes\n- Activate version to apply changes\n- Supports edge dictionaries, ACLs, custom conditions\n\nWhy others are incorrect:\n- A: Magento manages Fastly config, not direct dashboard access\n- C: VCL not in .magento.app.yaml\n- D: Composer is for PHP packages, not VCL",
    "codeExample": "# VCL Snippet Management\n\n# 1. Access Fastly Configuration\n# Admin > Stores > Configuration > Advanced > System > Fastly Configuration\n\n# 2. Create Custom VCL Snippet\n# - Click \"Custom VCL Snippets\"\n# - Add snippet with name, type (recv/deliver/fetch), priority, content\n\n# Example: Block specific IPs\nsub vcl_recv {\n    if (req.http.Fastly-Client-IP ~ blocklist) {\n        error 403 \"Forbidden\";\n    }\n}\n\n# Example: Custom cache TTL for specific paths\nsub vcl_fetch {\n    if (bereq.url ~ \"^/api/\") {\n        set beresp.ttl = 60s;  # Cache API for 60 seconds\n    }\n}\n\n# 3. Deployment process:\n# - Create new version (clones active)\n# - Add/modify snippets\n# - Validate VCL syntax\n# - Activate new version (instant, no downtime)\n\n# Priority determines execution order:\n# 50 = Normal (default Magento VCL)\n# 100 = Custom additions (after defaults)\n# 10 = Early execution (before defaults)\n\n# Edge Dictionaries for dynamic data:\n# Store IP blocks, redirects, A/B test rules",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 98,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Medium",
    "question": "How is New Relic APM configured for Adobe Commerce Cloud?",
    "options": [
      {
        "id": "A",
        "text": "Install New Relic module via composer only"
      },
      {
        "id": "B",
        "text": "Configure in .magento.app.yaml runtime extensions and environment variables"
      },
      {
        "id": "C",
        "text": "New Relic is not supported on Cloud"
      },
      {
        "id": "D",
        "text": "Through Magento Admin panel integration"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "New Relic APM is configured through Cloud configuration files.\n\nWhy B is correct:\n- New Relic PHP extension enabled in .magento.app.yaml\n- License key set as environment variable\n- App name configured per environment\n- Pro plan includes New Relic by default\n- Starter requires license from New Relic\n\nWhy others are incorrect:\n- A: Extension also needs configuration\n- C: New Relic is fully supported\n- D: Configuration is in files, not Admin",
    "codeExample": "# .magento.app.yaml\nruntime:\n    extensions:\n        - newrelic\n\n# Set environment variables (Cloud Console or CLI)\n# NEW_RELIC_LICENSE_KEY: your-license-key\n# NEW_RELIC_APP_NAME: MyStore-Production\n\n# Or in .magento.env.yaml\nstage:\n    global:\n        NEW_RELIC_URL: \"https://api.newrelic.com/\"\n\n# For detailed transaction naming\n# app/etc/env.php (auto-configured)\n'newrelic' => [\n    'appname' => 'MyStore-Production',\n    'license' => 'xxx',\n    'enabled' => true\n],\n\n# Key New Relic features for Magento:\n# - Transaction tracing (slow pages)\n# - Error tracking\n# - Deployment markers\n# - Database query analysis\n# - External service monitoring\n\n# Add deployment marker via CLI:\n# newrelic-admin record-deploy \"Description\" --revision=xyz",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 99,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Medium",
    "question": "What is the 'relationships' configuration in .magento.app.yaml and how does it work?",
    "options": [
      {
        "id": "A",
        "text": "Defines API connections to external services"
      },
      {
        "id": "B",
        "text": "Maps service endpoints to environment variables accessible by the application"
      },
      {
        "id": "C",
        "text": "Configures database table relationships"
      },
      {
        "id": "D",
        "text": "Sets up microservice communication"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Relationships connect your application to services defined in services.yaml.\n\nWhy B is correct:\n- Maps service names to application endpoints\n- Generates MAGENTO_CLOUD_RELATIONSHIPS environment variable\n- Contains connection info: host, port, user, password\n- Used by ece-tools to configure env.php automatically\n- Format: relationship_name: \"service_name:endpoint\"\n\nWhy others are incorrect:\n- A: For internal Cloud services, not external APIs\n- C: DB table relationships in schema files\n- D: Not for microservices specifically",
    "codeExample": "# .magento.app.yaml\nrelationships:\n    database: \"mysql:mysql\"\n    redis: \"redis:redis\"\n    opensearch: \"opensearch:opensearch\"\n    rabbitmq: \"rabbitmq:rabbitmq\"\n\n# These generate MAGENTO_CLOUD_RELATIONSHIPS:\n{\n    \"database\": [{\n        \"host\": \"mysql.internal\",\n        \"port\": 3306,\n        \"username\": \"user\",\n        \"password\": \"pass\",\n        \"path\": \"main\"  // database name\n    }],\n    \"redis\": [{\n        \"host\": \"redis.internal\",\n        \"port\": 6379\n    }]\n}\n\n# ece-tools uses this to configure env.php:\n'db' => [\n    'connection' => [\n        'default' => [\n            'host' => 'mysql.internal',\n            'dbname' => 'main',\n            'username' => 'user',\n            'password' => 'pass'\n        ]\n    ]\n],\n\n# Access in PHP:\n$relationships = json_decode(\n    base64_decode($_ENV['MAGENTO_CLOUD_RELATIONSHIPS']),\n    true\n);\n$dbHost = $relationships['database'][0]['host'];",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 100,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Medium",
    "question": "What happens in the post-deploy phase and why is it important?",
    "options": [
      {
        "id": "A",
        "text": "Database migrations run here"
      },
      {
        "id": "B",
        "text": "Cache warming and cleanup tasks run while site is live"
      },
      {
        "id": "C",
        "text": "Static content is generated"
      },
      {
        "id": "D",
        "text": "Composer dependencies are installed"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Post-deploy phase runs after the site is live, handling non-critical tasks.\n\nWhy B is correct:\n- Site is already serving traffic\n- Cache warming for critical pages\n- Log rotation and cleanup\n- Health checks\n- Notification webhooks\n- Non-blocking operations only\n\nWhy others are incorrect:\n- A: DB migrations in deploy phase (maintenance mode)\n- C: SCD in build or deploy phase\n- D: Composer in build phase",
    "codeExample": "# .magento.app.yaml\nhooks:\n    post_deploy: |\n        php ./vendor/bin/ece-tools run scenario/post-deploy.xml\n\n# .magento.env.yaml - Post-deploy configuration\nstage:\n    post-deploy:\n        WARM_UP_PAGES:\n            - \"index.php\"\n            - \"index.php/customer/account/create\"\n            - \"index.php/customer/account/login\"\n            - \"index.php/catalogsearch/result?q=test\"\n\n        WARM_UP_CONCURRENCY: 4  # Parallel requests\n        CLEAN_STATIC_FILES: true\n\n        # Notify external services\n        WEBHOOKS:\n            newrelic: true\n            slack:\n                hook_url: \"https://hooks.slack.com/...\"\n                message: \"Deployment complete\"\n\n# What ece-tools does in post-deploy:\n# 1. Warm configured pages (populates FPC)\n# 2. Clean old static files (optional)\n# 3. Record deployment in New Relic\n# 4. Run health checks\n# 5. Send notifications\n\n# Custom post-deploy tasks:\nhooks:\n    post_deploy: |\n        php ./vendor/bin/ece-tools run scenario/post-deploy.xml\n        # Custom: Notify monitoring system\n        curl -X POST $MONITORING_URL -d \"status=deployed\"",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-architecture",
      "deployment-pipeline",
      "environment-configuration"
    ]
  },
  {
    "id": 101,
    "category": "Caching",
    "difficulty": "Hard",
    "question": "How can Varnish VCL be customized to implement custom caching rules for specific URLs?",
    "options": [
      {
        "id": "A",
        "text": "Edit the core varnish.vcl file directly"
      },
      {
        "id": "B",
        "text": "Use vcl_recv and vcl_backend_response functions in custom VCL includes"
      },
      {
        "id": "C",
        "text": "Configure caching in Magento Admin only"
      },
      {
        "id": "D",
        "text": "Modify cache tags in PHP code"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Custom VCL uses specific functions to control cache behavior at different stages.\n\nWhy B is correct:\n- vcl_recv: Process incoming requests (normalize, decide cacheability)\n- vcl_backend_response (formerly vcl_fetch): Modify backend response before caching\n- vcl_deliver: Modify response before sending to client\n- Include custom VCL via Magento's Varnish module\n- Maintains upgradeability\n\nWhy others are incorrect:\n- A: Direct editing breaks upgrades\n- C: Admin config limited, VCL more powerful\n- D: Cache tags for invalidation, not routing rules",
    "codeExample": "# Custom VCL snippet for Magento\n\n# vcl_recv - Incoming request handling\nsub vcl_recv {\n    # Custom TTL for specific paths\n    if (req.url ~ \"^/api/v1/products\") {\n        set req.http.X-Custom-TTL = \"120\";  # 2 minutes\n    }\n\n    # Force cache bypass for certain cookies\n    if (req.http.Cookie ~ \"custom_nocache=1\") {\n        return (pass);\n    }\n\n    # Normalize query parameters for better cache hit rate\n    set req.url = std.querysort(req.url);\n}\n\n# vcl_backend_response - Modify response before caching\nsub vcl_backend_response {\n    # Apply custom TTL from request\n    if (bereq.http.X-Custom-TTL) {\n        set beresp.ttl = std.duration(bereq.http.X-Custom-TTL + \"s\", 60s);\n    }\n\n    # Cache specific content types longer\n    if (beresp.http.Content-Type ~ \"image/\") {\n        set beresp.ttl = 1d;  # Cache images for 1 day\n    }\n\n    # Grace period for stale content during revalidation\n    set beresp.grace = 1h;\n}\n\n# vcl_deliver - Modify final response\nsub vcl_deliver {\n    # Debug headers (remove in production)\n    if (resp.http.X-Debug) {\n        set resp.http.X-Cache-Hits = obj.hits;\n    }\n}",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "caching-strategy",
      "fpc-varnish",
      "cache-invalidation"
    ]
  },
  {
    "id": 102,
    "category": "Caching",
    "difficulty": "Medium",
    "question": "How should Redis be configured for different caching purposes in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Use a single Redis instance for all cache types"
      },
      {
        "id": "B",
        "text": "Separate databases or instances for cache, session, and FPC"
      },
      {
        "id": "C",
        "text": "Redis is only suitable for sessions"
      },
      {
        "id": "D",
        "text": "Use file-based caching instead of Redis"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Separating Redis usage improves performance and manageability.\n\nWhy B is correct:\n- Different eviction policies per use case\n- Sessions: noeviction or volatile-lru\n- Cache: allkeys-lru (can evict any key)\n- FPC: allkeys-lru (large values)\n- Easier monitoring and scaling\n- Prevents cache pollution affecting sessions\n\nWhy others are incorrect:\n- A: Single instance creates contention\n- C: Redis excellent for all cache types\n- D: File caching much slower",
    "codeExample": "// app/etc/env.php\n\n// Default cache backend (Redis DB 0)\n'cache' => [\n    'frontend' => [\n        'default' => [\n            'backend' => 'Magento\\Framework\\Cache\\Backend\\Redis',\n            'backend_options' => [\n                'server' => 'redis-cache',\n                'port' => '6379',\n                'database' => '0',\n                'compress_data' => '1',\n                'compression_lib' => 'gzip'\n            ]\n        ],\n        // Full Page Cache (Redis DB 1)\n        'page_cache' => [\n            'backend' => 'Magento\\Framework\\Cache\\Backend\\Redis',\n            'backend_options' => [\n                'server' => 'redis-fpc',\n                'port' => '6379',\n                'database' => '1',\n                'compress_data' => '1'\n            ]\n        ]\n    ]\n],\n\n// Session storage (Redis DB 2)\n'session' => [\n    'save' => 'redis',\n    'redis' => [\n        'host' => 'redis-session',\n        'port' => '6379',\n        'database' => '2',\n        'disable_locking' => '1',\n        'max_concurrency' => '6',\n        'bot_lifetime' => '7200'\n    ]\n],\n\n// Redis config recommendations:\n// cache/fpc: maxmemory-policy allkeys-lru\n// session: maxmemory-policy volatile-lru or noeviction",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "caching-strategy",
      "fpc-varnish",
      "cache-invalidation"
    ]
  },
  {
    "id": 103,
    "category": "Caching",
    "difficulty": "Hard",
    "question": "How does Magento implement hole punching for dynamic content in full page cache?",
    "options": [
      {
        "id": "A",
        "text": "Ajax calls after page load for all dynamic content"
      },
      {
        "id": "B",
        "text": "Edge Side Includes (ESI) via Varnish and private-content-version cookie"
      },
      {
        "id": "C",
        "text": "Disabling FPC for pages with dynamic content"
      },
      {
        "id": "D",
        "text": "Server-side caching only, no client involvement"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento uses ESI for public content and private content version for customer-specific data.\n\nWhy B is correct:\n- ESI: Varnish fetches dynamic fragments separately\n- private-content-version: Cookie triggers JS fetch\n- Customer sections loaded via customer/section/load\n- Combines cached page with fresh dynamic parts\n- Optimal balance of caching and personalization\n\nWhy others are incorrect:\n- A: Not all content via Ajax, ESI for some\n- C: FPC remains enabled, just with holes\n- D: Client-side (cookies/JS) integral to solution",
    "codeExample": "// Hole Punching Mechanisms\n\n// 1. ESI (Edge Side Includes) - Server-side\n// Layout XML with ttl for ESI-cacheable block\n<block class=\"Vendor\\Module\\Block\\Dynamic\" name=\"dynamic.block\">\n    <arguments>\n        <argument name=\"ttl\" xsi:type=\"number\">3600</argument>\n    </arguments>\n</block>\n\n// Generated ESI tag in HTML:\n// <esi:include src=\"/page_cache/block/esi/blocks/[encoded]\" />\n\n// 2. Private Content - Client-side JavaScript\n// sections.xml - defines customer-specific sections\n<config>\n    <action name=\"checkout/cart/add\">\n        <section name=\"cart\"/>\n        <section name=\"messages\"/>\n    </action>\n</config>\n\n// private-content-version cookie changes on action\n// customer-data.js fetches: /customer/section/load?sections=cart,messages\n\n// 3. Block prevents caching entire page\n<!-- Layout: page NOT cached at all -->\n<block cacheable=\"false\" .../>\n\n// Best practices:\n// - Use sections for customer data (cart, wishlist)\n// - ESI for shared dynamic content (stock status)\n// - Avoid cacheable=\"false\" when possible",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "caching-strategy",
      "fpc-varnish",
      "cache-invalidation"
    ]
  },
  {
    "id": 104,
    "category": "Caching",
    "difficulty": "Medium",
    "question": "What interface must a block implement to support cache tags for proper invalidation?",
    "options": [
      {
        "id": "A",
        "text": "Magento\\Framework\\Cache\\CacheInterface"
      },
      {
        "id": "B",
        "text": "Magento\\Framework\\DataObject\\IdentityInterface"
      },
      {
        "id": "C",
        "text": "Magento\\Framework\\View\\Element\\BlockInterface"
      },
      {
        "id": "D",
        "text": "Magento\\Framework\\Cache\\TagInterface"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "IdentityInterface provides cache tags for automatic invalidation.\n\nWhy B is correct:\n- getIdentities() returns array of cache tags\n- Tags format: entity_type_id (e.g., 'cat_p_123')\n- When entity changes, tags invalidate related cache\n- Framework collects tags from all blocks on page\n- Varnish/FPC uses tags for targeted invalidation\n\nWhy others are incorrect:\n- A: CacheInterface is for cache backends\n- C: BlockInterface defines block rendering\n- D: No such interface",
    "codeExample": "// Block implementing IdentityInterface\nnamespace Vendor\\Module\\Block;\n\nuse Magento\\Framework\\DataObject\\IdentityInterface;\nuse Magento\\Framework\\View\\Element\\Template;\n\nclass ProductList extends Template implements IdentityInterface\n{\n    public function getIdentities()\n    {\n        $identities = [];\n\n        foreach ($this->getProducts() as $product) {\n            // Add product-specific cache tags\n            $identities[] = \\Magento\\Catalog\\Model\\Product::CACHE_TAG . '_' . $product->getId();\n            // e.g., 'cat_p_123'\n        }\n\n        // Add category tag\n        $identities[] = \\Magento\\Catalog\\Model\\Category::CACHE_TAG . '_' . $this->getCategoryId();\n        // e.g., 'cat_c_456'\n\n        return $identities;\n    }\n}\n\n// Model also implements IdentityInterface\nclass Product implements IdentityInterface\n{\n    const CACHE_TAG = 'cat_p';\n\n    public function getIdentities()\n    {\n        return [self::CACHE_TAG . '_' . $this->getId()];\n    }\n}\n\n// When product 123 is saved:\n// Cache entries with tag 'cat_p_123' are invalidated\n// Varnish receives: PURGE with X-Magento-Tags-Pattern: cat_p_123",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "caching-strategy",
      "fpc-varnish",
      "cache-invalidation"
    ]
  },
  {
    "id": 105,
    "category": "Caching",
    "difficulty": "Medium",
    "question": "What happens when a block has cacheable='false' attribute in layout XML?",
    "options": [
      {
        "id": "A",
        "text": "Only that block is not cached"
      },
      {
        "id": "B",
        "text": "The entire page becomes non-cacheable by full page cache"
      },
      {
        "id": "C",
        "text": "Block uses a separate cache storage"
      },
      {
        "id": "D",
        "text": "Block content is loaded via Ajax"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "cacheable='false' disables FPC for the entire page containing the block.\n\nWhy B is correct:\n- ANY cacheable='false' block prevents page FPC\n- Entire page served dynamically each request\n- Common performance mistake\n- Should use private content or ESI instead\n- Check layout with: bin/magento dev:template-hints:enable\n\nWhy others are incorrect:\n- A: Affects entire page, not just block\n- C: No separate cache storage mechanism\n- D: Doesn't trigger Ajax loading",
    "codeExample": "<!-- BAD: Disables FPC for entire page -->\n<block class=\"Vendor\\Module\\Block\\CustomerInfo\"\n       name=\"customer.info\"\n       template=\"customer-info.phtml\"\n       cacheable=\"false\"/>\n\n<!-- Result: Page never cached, always dynamic -->\n<!-- Response headers: X-Magento-Cache-Debug: MISS (always) -->\n\n<!-- BETTER: Use private content sections -->\n<!-- 1. Register section in sections.xml -->\n<config>\n    <action name=\"customer/account/loginPost\">\n        <section name=\"customer\"/>\n    </action>\n</config>\n\n<!-- 2. Create section data source -->\n<!-- Customer section loaded via JS from /customer/section/load -->\n\n<!-- 3. In template, use Knockout.js -->\n<span data-bind=\"text: customer().fullname\">Guest</span>\n\n<!-- BETTER for shared dynamic: Use ESI -->\n<block class=\"Vendor\\Module\\Block\\StockStatus\"\n       name=\"stock.status\"\n       template=\"stock.phtml\">\n    <arguments>\n        <!-- TTL enables ESI in Varnish -->\n        <argument name=\"ttl\" xsi:type=\"number\">60</argument>\n    </arguments>\n</block>\n\n<!-- Check for problematic blocks: -->\n<!-- grep -r \"cacheable=\"false\"\" app/design/ vendor/ -->",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "caching-strategy",
      "fpc-varnish",
      "cache-invalidation"
    ]
  },
  {
    "id": 106,
    "category": "Performance",
    "difficulty": "Hard",
    "question": "How can you identify and fix N+1 query problems in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "N+1 problems don't occur in Magento due to its ORM"
      },
      {
        "id": "B",
        "text": "Use profiler to identify repeated queries, then use eager loading with collections"
      },
      {
        "id": "C",
        "text": "Disable database logging to improve performance"
      },
      {
        "id": "D",
        "text": "Increase database connection pool size"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "N+1 problems are common and identifiable through profiling.\n\nWhy B is correct:\n- Enable SQL profiler: dev/debug/profiler (DB profiler)\n- Look for repeated queries with different IDs\n- Solution: Load related data in collections\n- Use addAttributeToSelect() for EAV\n- Use joins for related data\n\nWhy others are incorrect:\n- A: N+1 very common in Magento, especially EAV\n- C: Logging doesn't cause N+1\n- D: Connection pool doesn't fix query patterns",
    "codeExample": "// N+1 Problem Example\nforeach ($products as $product) {\n    // Each iteration = new query!\n    $category = $product->getCategoryCollection()->getFirstItem();\n    // Also bad:\n    $stockItem = $this->stockRegistry->getStockItem($product->getId());\n}\n// 100 products = 200+ queries!\n\n// Solution 1: Eager load with collection\n$collection = $this->productCollectionFactory->create();\n$collection\n    ->addAttributeToSelect(['name', 'price', 'status'])\n    ->addCategoryIds()  // Loads category IDs in one query\n    ->joinField(\n        'qty',\n        'cataloginventory_stock_item',\n        'qty',\n        'product_id=entity_id',\n        null,\n        'left'\n    );\n\n// Solution 2: Batch load related data\n$productIds = $collection->getAllIds();\n$stockItems = $this->stockRegistry->getStockItemsBySku(\n    $collection->getColumnValues('sku')\n);\n\n// Solution 3: Use ResourceConnection for complex queries\n$connection = $this->resourceConnection->getConnection();\n$select = $connection->select()\n    ->from(['e' => 'catalog_product_entity'])\n    ->joinLeft(['s' => 'cataloginventory_stock_item'], 'e.entity_id = s.product_id')\n    ->where('e.entity_id IN (?)', $productIds);\n\n// Profiling: bin/magento dev:profiler:enable\n// Or: MAGE_PROFILER=1 in env.php",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "performance-optimization",
      "scalability"
    ]
  },
  {
    "id": 107,
    "category": "Performance",
    "difficulty": "Medium",
    "question": "What is the purpose of indexer dimensions and how do they improve performance?",
    "options": [
      {
        "id": "A",
        "text": "Dimensions limit index size by removing old data"
      },
      {
        "id": "B",
        "text": "Dimensions enable partial indexing by scope (store, customer group)"
      },
      {
        "id": "C",
        "text": "Dimensions create backup copies of indexes"
      },
      {
        "id": "D",
        "text": "Dimensions control index storage location"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Indexer dimensions allow scoped, partial reindexing for better performance.\n\nWhy B is correct:\n- Dimensions: Store, Customer Group, Website\n- Partial reindex: Only affected scope rebuilt\n- Example: Price change in Store 1 only reindexes Store 1\n- Reduces reindex time significantly\n- Configured in indexer.xml\n\nWhy others are incorrect:\n- A: Dimensions about scope, not data retention\n- C: Not backup mechanism\n- D: Storage separate from dimensions",
    "codeExample": "<!-- indexer.xml - Dimensional indexer -->\n<indexer id=\"catalog_product_price\"\n         class=\"Magento\\Catalog\\Model\\Indexer\\Product\\Price\">\n    <dimensions>\n        <dimension name=\"website_id\" iterator=\"\\Magento\\Store\\Model\\Indexer\\WebsiteIterator\"/>\n        <dimension name=\"customer_group_id\" iterator=\"\\Magento\\Customer\\Model\\Indexer\\CustomerGroupIterator\"/>\n    </dimensions>\n</indexer>\n\n// How dimensions work:\n// 1. Full reindex creates index per dimension combination\n//    website_1_customer_group_0, website_1_customer_group_1, etc.\n\n// 2. Partial reindex (e.g., price rule change for website 2)\n$indexer->executeByDimensions(\n    ['website_id' => 2],  // Only reindex website 2\n    $productIds\n);\n\n// 3. Query uses appropriate dimension\n$select->where('website_id = ?', $websiteId)\n       ->where('customer_group_id = ?', $customerGroupId);\n\n// Configuration\nbin/magento indexer:set-dimensions-mode catalog_product_price website\n// Options: none, website, customer_group, website_and_customer_group\n\n// Check current mode\nbin/magento indexer:show-dimensions-mode",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "performance-optimization",
      "scalability"
    ]
  },
  {
    "id": 108,
    "category": "Performance",
    "difficulty": "Medium",
    "question": "What static content optimization strategies are available in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Minification, bundling, and merging through configuration"
      },
      {
        "id": "B",
        "text": "Only server-side compression is available"
      },
      {
        "id": "C",
        "text": "CDN is the only optimization option"
      },
      {
        "id": "D",
        "text": "Static content cannot be optimized"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "Magento offers multiple static content optimization options.\n\nWhy A is correct:\n- CSS/JS minification: Removes whitespace, comments\n- JS bundling: Combines files (requires configuration)\n- CSS/JS merging: Single file per type\n- Deferred JS loading: async/defer attributes\n- Configured in Admin or config.php\n\nWhy others are incorrect:\n- B: Multiple optimization methods available\n- C: CDN complementary, not only option\n- D: Extensive optimization capabilities",
    "codeExample": "// Admin: Stores > Configuration > Advanced > Developer\n\n// CSS Settings\n'css' => [\n    'minify_files' => '1',       // Remove whitespace\n    'merge_css_files' => '1',    // Combine into one file\n    'use_css_critical_path' => '1' // Critical CSS inline\n],\n\n// JavaScript Settings\n'js' => [\n    'minify_files' => '1',\n    'enable_js_bundling' => '1',  // Combine JS modules\n    'merge_files' => '1',\n    'move_script_to_bottom' => '1' // Defer JS loading\n],\n\n// Template Settings\n'template' => [\n    'minify_html' => '1'\n],\n\n// Production mode automatically enables:\nbin/magento deploy:mode:set production\n\n// Advanced JS bundling (requirejs-config.js)\nvar config = {\n    bundles: {\n        'bundles/common': [\n            'jquery',\n            'jquery/ui',\n            'mage/translate'\n        ],\n        'bundles/cart': [\n            'Magento_Checkout/js/model/cart/cache'\n        ]\n    }\n};\n\n// Critical CSS: Load above-fold CSS inline\n// Configure paths in: dev/css/use_css_critical_path",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "performance-optimization",
      "scalability"
    ]
  },
  {
    "id": 109,
    "category": "Performance",
    "difficulty": "Medium",
    "question": "How should images be optimized for performance in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Store original images only, Magento cannot resize"
      },
      {
        "id": "B",
        "text": "Use image resize on upload, WebP format, and lazy loading"
      },
      {
        "id": "C",
        "text": "Disable all product images"
      },
      {
        "id": "D",
        "text": "Use only external image URLs"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento provides comprehensive image optimization capabilities.\n\nWhy B is correct:\n- Automatic resize during import/upload\n- WebP format support (better compression)\n- Lazy loading via JavaScript\n- Image cache for resized variants\n- Quality settings configurable\n\nWhy others are incorrect:\n- A: Magento has extensive image processing\n- C: Images critical for ecommerce\n- D: Internal processing preferred for optimization",
    "codeExample": "// Image optimization configuration\n\n// 1. View.xml - Define image sizes per context\n<media>\n    <images module=\"Magento_Catalog\">\n        <image id=\"category_page_list\" type=\"small_image\">\n            <width>240</width>\n            <height>300</height>\n        </image>\n        <image id=\"product_page_image_large\" type=\"image\">\n            <width>700</width>\n            <height>700</height>\n        </image>\n    </images>\n</media>\n\n// 2. WebP conversion (Magento 2.4+)\n// Stores > Configuration > Advanced > Developer > Image Processing\n// 'webp' => 1\n\n// 3. Lazy loading in templates\n<img src=\"placeholder.jpg\"\n     data-src=\"<?= $image->getUrl() ?>\"\n     class=\"lazyload\" />\n\n// 4. Resize during import\n// bin/magento catalog:images:resize\n\n// 5. Image quality settings (env.php)\n'image' => [\n    'default_quality' => 80,\n    'webp_quality' => 75\n],\n\n// 6. CDN for images (Stores > Configuration > Web > Base URLs)\n// Media Base URL: https://cdn.example.com/media/\n\n// Clear image cache:\n// bin/magento catalog:images:resize -f\n// rm -rf pub/media/catalog/product/cache/",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "performance-optimization",
      "scalability"
    ]
  },
  {
    "id": 110,
    "category": "Performance",
    "difficulty": "Medium",
    "question": "What is the Proxy pattern used for in Magento 2 and when should it be applied?",
    "options": [
      {
        "id": "A",
        "text": "For caching database queries"
      },
      {
        "id": "B",
        "text": "For lazy loading expensive dependencies that aren't always used"
      },
      {
        "id": "C",
        "text": "For routing requests to different servers"
      },
      {
        "id": "D",
        "text": "For encrypting sensitive data"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Proxy provides lazy instantiation for performance optimization.\n\nWhy B is correct:\n- Defers object creation until first use\n- Auto-generated by Magento (ClassName\\Proxy)\n- Reduces constructor overhead\n- Ideal for conditionally-used heavy dependencies\n- Implements same interface as wrapped class\n\nWhy others are incorrect:\n- A: Query caching is separate mechanism\n- C: Routing handled by webserver/framework\n- D: Encryption is separate concern",
    "codeExample": "// Without Proxy - Heavy dependency always instantiated\nclass OrderService\n{\n    public function __construct(\n        private HeavyReportGenerator $reportGenerator // ALWAYS created\n    ) {}\n\n    public function processOrder($order) {\n        // reportGenerator created even if never used\n        return $this->orderRepository->save($order);\n    }\n\n    public function generateReport($order) {\n        // Only here is reportGenerator actually needed\n        return $this->reportGenerator->generate($order);\n    }\n}\n\n// With Proxy - Lazy instantiation\n<!-- di.xml -->\n<type name=\"Vendor\\Module\\Service\\OrderService\">\n    <arguments>\n        <argument name=\"reportGenerator\" xsi:type=\"object\">\n            Vendor\\Module\\Service\\HeavyReportGenerator\\Proxy\n        </argument>\n    </arguments>\n</type>\n\n// Generated Proxy class (simplified)\nclass HeavyReportGenerator\\Proxy extends HeavyReportGenerator\n{\n    private $subject;\n    private $objectManager;\n\n    public function generate($order) {\n        // First call: creates real instance\n        return $this->getSubject()->generate($order);\n    }\n\n    private function getSubject() {\n        if (!$this->subject) {\n            $this->subject = $this->objectManager->get(HeavyReportGenerator::class);\n        }\n        return $this->subject;\n    }\n}\n\n// Best for:\n// - Heavy services used conditionally\n// - Circular dependency resolution\n// - CLI commands with expensive deps",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "performance-optimization",
      "scalability"
    ]
  },
  {
    "id": 111,
    "category": "Security",
    "difficulty": "Hard",
    "question": "How is Content Security Policy (CSP) implemented in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Through .htaccess configuration only"
      },
      {
        "id": "B",
        "text": "Through csp_whitelist.xml to define allowed sources per directive"
      },
      {
        "id": "C",
        "text": "CSP is not supported in Magento"
      },
      {
        "id": "D",
        "text": "Through JavaScript runtime checks"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento implements CSP through a dedicated XML configuration system.\n\nWhy B is correct:\n- csp_whitelist.xml per module defines allowed sources\n- Supports all CSP directives (script-src, style-src, etc.)\n- Report-only mode for testing\n- Nonce generation for inline scripts\n- Admin and storefront separate policies\n\nWhy others are incorrect:\n- A: Managed by Magento, not webserver\n- C: Full CSP support since 2.3.5\n- D: Server-side headers, not JS",
    "codeExample": "<!-- etc/csp_whitelist.xml -->\n<csp_whitelist>\n    <policies>\n        <policy id=\"script-src\">\n            <values>\n                <value id=\"google-analytics\" type=\"host\">\n                    www.google-analytics.com\n                </value>\n                <value id=\"google-tag\" type=\"host\">\n                    www.googletagmanager.com\n                </value>\n            </values>\n        </policy>\n\n        <policy id=\"style-src\">\n            <values>\n                <value id=\"google-fonts\" type=\"host\">\n                    fonts.googleapis.com\n                </value>\n            </values>\n        </policy>\n\n        <policy id=\"font-src\">\n            <values>\n                <value id=\"google-fonts-static\" type=\"host\">\n                    fonts.gstatic.com\n                </value>\n            </values>\n        </policy>\n\n        <policy id=\"img-src\">\n            <values>\n                <value id=\"cdn\" type=\"host\">\n                    cdn.example.com\n                </value>\n            </values>\n        </policy>\n    </policies>\n</csp_whitelist>\n\n<!-- Admin config: Stores > Configuration > Security > CSP -->\n<!-- Mode: report-only (testing) or restrict (enforcing) -->\n\n<!-- Inline scripts with nonce -->\n<?php $cspNonceProvider = $block->getCspNonceProvider(); ?>\n<script nonce=\"<?= $cspNonceProvider->generateNonce() ?>\">\n    // Inline script with valid nonce\n</script>",
    "examDomain": "Review",
    "objectiveTags": [
      "security-hardening",
      "secure-coding",
      "compliance"
    ]
  },
  {
    "id": 112,
    "category": "Security",
    "difficulty": "Medium",
    "question": "How is two-factor authentication (2FA) implemented in Magento 2 admin?",
    "options": [
      {
        "id": "A",
        "text": "Through third-party extension only"
      },
      {
        "id": "B",
        "text": "Built-in module supporting Google Authenticator, Duo, Authy, and U2F"
      },
      {
        "id": "C",
        "text": "SMS-based verification only"
      },
      {
        "id": "D",
        "text": "2FA is not available for Magento admin"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento includes comprehensive 2FA support out of the box.\n\nWhy B is correct:\n- Magento_TwoFactorAuth module (core)\n- Providers: Google Authenticator, Duo Security, Authy, U2F\n- Required for all admin users\n- Emergency reset via CLI\n- Can be disabled (not recommended) or customized\n\nWhy others are incorrect:\n- A: Built into core since 2.4.0\n- C: Multiple methods, not just SMS\n- D: Full 2FA support included",
    "codeExample": "// 2FA is required by default in Magento 2.4+\n\n// Disable 2FA (development only!)\nbin/magento module:disable Magento_TwoFactorAuth\n\n// Reset 2FA for specific user\nbin/magento security:tfa:reset admin_username google\n\n// Configure providers in Admin\n// Stores > Configuration > Security > 2FA\n\n// Force specific provider\n// Stores > Configuration > Security > 2FA\n// General > Force Providers = google\n\n// Programmatic 2FA check\nclass AdminController\n{\n    public function execute()\n    {\n        if (!$this->tfaSession->isGranted()) {\n            return $this->resultRedirectFactory->create()\n                ->setPath('tfa/tfa/index');\n        }\n        // Proceed with admin action\n    }\n}\n\n// Custom 2FA provider implementation\nclass CustomProvider implements ProviderInterface\n{\n    public function getCode(): string { return 'custom'; }\n    public function getName(): string { return 'Custom 2FA'; }\n    public function isEnabled(): bool { return true; }\n    public function verify(UserInterface $user, DataObject $request): bool\n    {\n        // Verification logic\n    }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "security-hardening",
      "secure-coding",
      "compliance"
    ]
  },
  {
    "id": 113,
    "category": "Security",
    "difficulty": "Medium",
    "question": "What is the correct way to prevent SQL injection in custom Magento code?",
    "options": [
      {
        "id": "A",
        "text": "Escape user input with htmlspecialchars()"
      },
      {
        "id": "B",
        "text": "Use prepared statements and parameter binding through Magento's DB abstraction"
      },
      {
        "id": "C",
        "text": "Validate input length only"
      },
      {
        "id": "D",
        "text": "Use base64 encoding for all inputs"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Prepared statements with parameter binding prevent SQL injection.\n\nWhy B is correct:\n- ResourceConnection provides safe query building\n- Parameters automatically escaped/quoted\n- Use bind parameters, not string concatenation\n- Zend_Db_Select handles quoting\n- Collections use safe methods by default\n\nWhy others are incorrect:\n- A: htmlspecialchars is for XSS, not SQL injection\n- C: Length validation doesn't prevent injection\n- D: Encoding doesn't sanitize SQL",
    "codeExample": "// WRONG - SQL Injection vulnerable\n$userId = $request->getParam('user_id');\n$sql = \"SELECT * FROM users WHERE id = \" . $userId;  // DANGER!\n\n// CORRECT - Using parameter binding\n$connection = $this->resourceConnection->getConnection();\n\n// Method 1: Named parameters\n$select = $connection->select()\n    ->from('users')\n    ->where('id = :user_id');\n$result = $connection->fetchRow($select, ['user_id' => $userId]);\n\n// Method 2: Positional parameters\n$select = $connection->select()\n    ->from('users')\n    ->where('id = ?', $userId);\n\n// Method 3: quoteInto for complex cases\n$sql = $connection->quoteInto(\n    'SELECT * FROM users WHERE status = ? AND created > ?',\n    ['active', '2024-01-01']\n);\n\n// Method 4: Using collections (safest)\n$collection = $this->userCollectionFactory->create();\n$collection->addFieldToFilter('id', ['eq' => $userId]);\n\n// For IN clauses\n$ids = [1, 2, 3];  // Even if from user input\n$select->where('id IN (?)', $ids);  // Properly escaped\n\n// NEVER do this:\n$ids = implode(',', $userInput);  // Could contain SQL injection!\n$select->where('id IN (' . $ids . ')');  // VULNERABLE!",
    "examDomain": "Review",
    "objectiveTags": [
      "security-hardening",
      "secure-coding",
      "compliance"
    ]
  },
  {
    "id": 114,
    "category": "Security",
    "difficulty": "Medium",
    "question": "How should output be escaped to prevent XSS (Cross-Site Scripting) in Magento templates?",
    "options": [
      {
        "id": "A",
        "text": "Use strip_tags() on all output"
      },
      {
        "id": "B",
        "text": "Use $escaper methods appropriate to the context (HTML, URL, JS, CSS)"
      },
      {
        "id": "C",
        "text": "Only escape user input, not database content"
      },
      {
        "id": "D",
        "text": "Use base64 encoding for display"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento's Escaper class provides context-specific escaping methods.\n\nWhy B is correct:\n- $escaper available in all templates\n- escapeHtml(): HTML content\n- escapeHtmlAttr(): HTML attributes\n- escapeUrl(): URL parameters\n- escapeJs(): JavaScript strings\n- escapeCss(): CSS values\n- Context matters for proper escaping\n\nWhy others are incorrect:\n- A: strip_tags removes content, doesn't escape\n- C: ALL output should be escaped\n- D: Encoding not for display purposes",
    "codeExample": "<?php\n// In Magento 2 templates, $escaper is available\n// Block also has $block->escapeHtml() methods\n\n// HTML content escaping\n<p><?= $escaper->escapeHtml($product->getName()) ?></p>\n\n// HTML attribute escaping (more restrictive)\n<div title=\"<?= $escaper->escapeHtmlAttr($product->getDescription()) ?>\">\n\n// URL escaping\n<a href=\"<?= $escaper->escapeUrl($block->getUrl('catalog/product/view', ['id' => $id])) ?>\">\n\n// JavaScript escaping\n<script>\n    var productName = \"<?= $escaper->escapeJs($product->getName()) ?>\";\n    var config = <?= /* @noEscape */ $block->getJsonConfig() ?>; // JSON already safe\n</script>\n\n// CSS escaping\n<div style=\"background-color: <?= $escaper->escapeCss($color) ?>\">\n\n// Allow specific HTML tags\n<?= $escaper->escapeHtml($content, ['p', 'br', 'strong', 'em']) ?>\n\n// WRONG - XSS vulnerable\n<p><?= $product->getName() ?></p>  // No escaping!\n<a href=\"<?= $untrustedUrl ?>\">    // Could be javascript:\n\n// @noEscape annotation for already-safe content (use sparingly)\n<?= /* @noEscape */ $block->getChildHtml('content') ?>\n?>",
    "examDomain": "Review",
    "objectiveTags": [
      "security-hardening",
      "secure-coding",
      "compliance"
    ]
  },
  {
    "id": 115,
    "category": "Security",
    "difficulty": "Medium",
    "question": "How does Magento protect against CSRF (Cross-Site Request Forgery) attacks?",
    "options": [
      {
        "id": "A",
        "text": "Through IP address validation only"
      },
      {
        "id": "B",
        "text": "Using form_key token validation for state-changing requests"
      },
      {
        "id": "C",
        "text": "HTTPS encryption alone prevents CSRF"
      },
      {
        "id": "D",
        "text": "CSRF protection is not implemented"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Magento uses form_key tokens to validate legitimate requests.\n\nWhy B is correct:\n- form_key: Unique token per session\n- Required for POST/PUT/DELETE requests\n- Validated automatically by framework\n- Stored in session, sent with forms\n- AJAX requests include form_key header\n\nWhy others are incorrect:\n- A: IP can be spoofed, not reliable\n- C: HTTPS encrypts, doesn't verify intent\n- D: Full CSRF protection implemented",
    "codeExample": "<!-- Form with CSRF protection (automatic in Magento forms) -->\n<form action=\"<?= $block->getUrl('module/action/save') ?>\" method=\"post\">\n    <!-- Form key automatically added by Magento form blocks -->\n    <?= $block->getBlockHtml('formkey') ?>\n    <!-- Or manually: -->\n    <input type=\"hidden\" name=\"form_key\" value=\"<?= $block->getFormKey() ?>\"/>\n\n    <input type=\"text\" name=\"data\"/>\n    <button type=\"submit\">Save</button>\n</form>\n\n// Controller validation (automatic with parent classes)\nclass SaveController extends Action\n{\n    // CsrfAwareActionInterface for custom validation\n    public function execute()\n    {\n        // Form key validated automatically before reaching here\n        // If invalid: 403 error returned\n    }\n}\n\n// AJAX with form_key\nrequire(['jquery', 'mage/url'], function($, urlBuilder) {\n    $.ajax({\n        url: urlBuilder.build('module/action/save'),\n        type: 'POST',\n        data: {\n            form_key: $.mage.cookies.get('form_key'),\n            custom_data: 'value'\n        }\n    });\n});\n\n// Skip CSRF for specific actions (webhooks, APIs)\nclass WebhookController extends Action implements CsrfAwareActionInterface\n{\n    public function createCsrfValidationException(RequestInterface $request): ?InvalidRequestException\n    {\n        return null;  // Skip CSRF\n    }\n\n    public function validateForCsrf(RequestInterface $request): ?bool\n    {\n        return true;  // Always valid\n    }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "security-hardening",
      "secure-coding",
      "compliance"
    ]
  },
  {
    "id": 116,
    "category": "Security",
    "difficulty": "Medium",
    "question": "What security measures should be implemented for the Magento admin panel?",
    "options": [
      {
        "id": "A",
        "text": "No special measures needed beyond default configuration"
      },
      {
        "id": "B",
        "text": "Custom admin URL, IP restrictions, session lifetime, 2FA, and login attempt limits"
      },
      {
        "id": "C",
        "text": "Only password complexity requirements"
      },
      {
        "id": "D",
        "text": "Public access is safe with strong passwords"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Multiple layers of security should protect the admin panel.\n\nWhy B is correct:\n- Custom admin URL: Obscures admin location\n- IP whitelist: Restrict access to known IPs\n- Session lifetime: Limit session duration\n- 2FA: Second authentication factor\n- Lockout: Prevent brute force attacks\n- CAPTCHA: Additional bot protection\n\nWhy others are incorrect:\n- A: Default config insufficient\n- C: Passwords alone not enough\n- D: Public access risky",
    "codeExample": "// 1. Custom Admin URL (env.php or during install)\n'backend' => [\n    'frontName' => 'secret-admin-path'  // Not 'admin'!\n],\n\n// 2. IP Restriction (in Admin or .htaccess)\n// Stores > Configuration > Advanced > Admin > Security\n// Admin Session Lifetime: 900 (15 minutes)\n\n// nginx.conf example\nlocation /secret-admin-path {\n    allow 192.168.1.0/24;\n    allow 10.0.0.1;\n    deny all;\n\n    try_files $uri $uri/ /index.php?$args;\n}\n\n// 3. Session Security (env.php)\n'session' => [\n    'save' => 'redis',\n    'redis' => [\n        'disable_locking' => 1,\n        'max_concurrency' => 6,\n        // Session timeout\n    ]\n],\n\n// 4. Login security (Admin configuration)\n// Stores > Configuration > Advanced > Admin > Security\n// - Add Secret Key to URLs: Yes\n// - Login is Case Sensitive: Yes\n// - Admin Session Lifetime: 900\n// - Max Login Failures: 6\n// - Lockout Time: 30\n\n// 5. Force HTTPS for admin\n// Stores > Configuration > General > Web > Base URLs (Secure)\n// Use Secure URLs in Admin: Yes\n\n// 6. Captcha (Admin configuration)\n// Stores > Configuration > Customers > CAPTCHA\n// Enable CAPTCHA in Admin: Yes\n// Forms: Login, Forgot Password",
    "examDomain": "Review",
    "objectiveTags": [
      "security-hardening",
      "secure-coding",
      "compliance"
    ]
  },
  {
    "id": 117,
    "category": "Testing",
    "difficulty": "Medium",
    "question": "What is the difference between integration tests and unit tests in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Integration tests are faster than unit tests"
      },
      {
        "id": "B",
        "text": "Unit tests mock dependencies; integration tests use real Magento framework and database"
      },
      {
        "id": "C",
        "text": "Unit tests require database; integration tests don't"
      },
      {
        "id": "D",
        "text": "There is no difference in Magento"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Unit and integration tests have fundamentally different approaches.\n\nWhy B is correct:\n- Unit tests: Isolated, mock all dependencies\n- Integration tests: Real framework, database, DI\n- Unit: Fast, focused on single class\n- Integration: Slower, tests component interaction\n- Both important for comprehensive coverage\n\nWhy others are incorrect:\n- A: Unit tests are faster (no framework)\n- C: Reversed - integration needs DB\n- D: Significant architectural differences",
    "codeExample": "// Unit Test - Isolated, mocked dependencies\nnamespace Vendor\\Module\\Test\\Unit\\Model;\n\nclass ProductServiceTest extends \\PHPUnit\\Framework\\TestCase\n{\n    private $productRepository;\n    private $productService;\n\n    protected function setUp(): void\n    {\n        // Mock dependencies\n        $this->productRepository = $this->createMock(ProductRepositoryInterface::class);\n        $this->productService = new ProductService($this->productRepository);\n    }\n\n    public function testGetProduct(): void\n    {\n        $mockProduct = $this->createMock(ProductInterface::class);\n        $mockProduct->method('getSku')->willReturn('SKU123');\n\n        $this->productRepository->method('get')->willReturn($mockProduct);\n\n        $result = $this->productService->getProduct('SKU123');\n        $this->assertEquals('SKU123', $result->getSku());\n    }\n}\n// Run: vendor/bin/phpunit -c dev/tests/unit/phpunit.xml.dist\n\n// Integration Test - Real framework\nnamespace Vendor\\Module\\Test\\Integration\\Model;\n\nclass ProductServiceTest extends \\Magento\\TestFramework\\TestCase\\AbstractController\n{\n    /**\n     * @magentoDataFixture Magento/Catalog/_files/product_simple.php\n     */\n    public function testGetProduct(): void\n    {\n        // Uses real DI, real database\n        $productRepository = Bootstrap::getObjectManager()\n            ->get(ProductRepositoryInterface::class);\n\n        $product = $productRepository->get('simple');\n\n        $this->assertEquals('simple', $product->getSku());\n    }\n}\n// Run: vendor/bin/phpunit -c dev/tests/integration/phpunit.xml.dist",
    "examDomain": "Review",
    "objectiveTags": [
      "testing-strategy",
      "integration-tests",
      "mftf"
    ]
  },
  {
    "id": 118,
    "category": "Testing",
    "difficulty": "Hard",
    "question": "What are the main components of MFTF (Magento Functional Testing Framework) tests?",
    "options": [
      {
        "id": "A",
        "text": "PHPUnit classes and annotations"
      },
      {
        "id": "B",
        "text": "Test, ActionGroup, Section, and Data entities in XML format"
      },
      {
        "id": "C",
        "text": "JavaScript test files with Jasmine"
      },
      {
        "id": "D",
        "text": "Docker containers for test isolation"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "MFTF uses XML-based entities for browser automation testing.\n\nWhy B is correct:\n- Test: Defines test flow, calls action groups\n- ActionGroup: Reusable action sequences\n- Section: Page element selectors\n- Data: Test data entities\n- All defined in XML files\n- Generates PHP/Codeception tests\n\nWhy others are incorrect:\n- A: MFTF uses XML, not PHPUnit directly\n- C: Not JavaScript-based\n- D: Docker optional, not core component",
    "codeExample": "<!-- Test/Mftf/Test/CreateSimpleProductTest.xml -->\n<tests>\n    <test name=\"CreateSimpleProductTest\">\n        <annotations>\n            <title value=\"Create Simple Product\"/>\n            <severity value=\"CRITICAL\"/>\n        </annotations>\n\n        <!-- Steps reference ActionGroups -->\n        <actionGroup ref=\"AdminLoginActionGroup\"/>\n        <actionGroup ref=\"AdminNavigateToProductGridActionGroup\"/>\n        <actionGroup ref=\"CreateSimpleProductActionGroup\">\n            <argument name=\"product\" value=\"SimpleProduct\"/>\n        </actionGroup>\n\n        <see selector=\"{{AdminProductMessagesSection.successMessage}}\"\n             userInput=\"You saved the product.\"/>\n    </test>\n</tests>\n\n<!-- ActionGroup/AdminLoginActionGroup.xml -->\n<actionGroups>\n    <actionGroup name=\"AdminLoginActionGroup\">\n        <amOnPage url=\"{{AdminLoginPage.url}}\" stepKey=\"goToAdmin\"/>\n        <fillField selector=\"{{AdminLoginFormSection.username}}\"\n                   userInput=\"{{_ENV.MAGENTO_ADMIN_USERNAME}}\" stepKey=\"enterUsername\"/>\n        <fillField selector=\"{{AdminLoginFormSection.password}}\"\n                   userInput=\"{{_ENV.MAGENTO_ADMIN_PASSWORD}}\" stepKey=\"enterPassword\"/>\n        <click selector=\"{{AdminLoginFormSection.signIn}}\" stepKey=\"clickLogin\"/>\n        <waitForPageLoad stepKey=\"waitForDashboard\"/>\n    </actionGroup>\n</actionGroups>\n\n<!-- Section/AdminLoginFormSection.xml -->\n<sections>\n    <section name=\"AdminLoginFormSection\">\n        <element name=\"username\" type=\"input\" selector=\"#username\"/>\n        <element name=\"password\" type=\"input\" selector=\"#login\"/>\n        <element name=\"signIn\" type=\"button\" selector=\".action-login\"/>\n    </section>\n</sections>\n\n<!-- Data/SimpleProductData.xml -->\n<entities>\n    <entity name=\"SimpleProduct\" type=\"product\">\n        <data key=\"sku\">simple-product-{{unique}}</data>\n        <data key=\"name\">Simple Product {{unique}}</data>\n        <data key=\"price\">100.00</data>\n    </entity>\n</entities>\n\n<!-- Run: vendor/bin/mftf run:test CreateSimpleProductTest -->",
    "examDomain": "Review",
    "objectiveTags": [
      "testing-strategy",
      "integration-tests",
      "mftf"
    ]
  },
  {
    "id": 119,
    "category": "Testing",
    "difficulty": "Medium",
    "question": "How is PHPStan configured for static analysis in Magento 2 projects?",
    "options": [
      {
        "id": "A",
        "text": "PHPStan cannot be used with Magento"
      },
      {
        "id": "B",
        "text": "Through phpstan.neon configuration with Magento-specific rules and level settings"
      },
      {
        "id": "C",
        "text": "Only via composer.json scripts"
      },
      {
        "id": "D",
        "text": "Through Magento Admin panel configuration"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "PHPStan uses neon configuration files for Magento analysis.\n\nWhy B is correct:\n- phpstan.neon: Main configuration file\n- Levels 0-9: Increasing strictness\n- Magento extension: Understands Magento patterns\n- Baseline: Ignore existing issues\n- CI/CD integration common\n\nWhy others are incorrect:\n- A: PHPStan fully supported\n- C: Configuration in neon file, not just composer\n- D: CLI tool, not admin panel",
    "codeExample": "# phpstan.neon\nincludes:\n    - vendor/bitexpert/phpstan-magento/extension.neon\n\nparameters:\n    level: 6  # Strictness level (0-8, 9=max)\n\n    paths:\n        - app/code/Vendor\n\n    excludePaths:\n        - */Test/*\n        - */Setup/*\n\n    # Magento-specific settings\n    magentoRootPath: %rootDir%/../../../\n\n    # Ignore specific errors\n    ignoreErrors:\n        - '#Call to an undefined method#'\n\n    # Use baseline for existing code\n    baseline: phpstan-baseline.neon\n\n# Magento extension handles:\n# - Generated classes (Factories, Proxies)\n# - Plugin method signatures\n# - ObjectManager patterns\n# - EAV magic methods\n\n# Run analysis\nvendor/bin/phpstan analyse --memory-limit=4G\n\n# Generate baseline (ignore existing issues)\nvendor/bin/phpstan analyse --generate-baseline\n\n# Common levels:\n# Level 0: Basic checks\n# Level 5: Method return types, parameter types\n# Level 6: Strict mixed type checks (recommended)\n# Level 8: No mixed allowed\n\n# composer.json integration\n\"scripts\": {\n    \"phpstan\": \"phpstan analyse -c phpstan.neon\"\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "testing-strategy",
      "integration-tests",
      "mftf"
    ]
  },
  {
    "id": 120,
    "category": "Testing",
    "difficulty": "Medium",
    "question": "How are test fixtures used in Magento 2 integration tests?",
    "options": [
      {
        "id": "A",
        "text": "Fixtures are deprecated in Magento 2"
      },
      {
        "id": "B",
        "text": "@magentoDataFixture annotation runs PHP files that set up/tear down test data"
      },
      {
        "id": "C",
        "text": "Fixtures are JSON files loaded automatically"
      },
      {
        "id": "D",
        "text": "Only database dumps are used as fixtures"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Data fixtures are PHP files that prepare the database state for tests.\n\nWhy B is correct:\n- @magentoDataFixture: Loads fixture before test\n- Fixtures are PHP files in Test/_files/\n- Rollback files (*_rollback.php) clean up\n- Can create products, customers, orders, etc.\n- Isolation: Each test starts with known state\n\nWhy others are incorrect:\n- A: Fixtures are core testing feature\n- C: PHP files, not JSON\n- D: PHP fixtures, not DB dumps",
    "codeExample": "// Test class with fixtures\nnamespace Vendor\\Module\\Test\\Integration;\n\nclass OrderServiceTest extends \\Magento\\TestFramework\\TestCase\\AbstractController\n{\n    /**\n     * @magentoDataFixture Magento/Sales/_files/order.php\n     * @magentoDataFixture Vendor_Module::Test/_files/custom_data.php\n     */\n    public function testOrderProcessing(): void\n    {\n        // Fixtures loaded before this runs\n        $order = $this->orderRepository->get('100000001');\n        $this->assertEquals('pending', $order->getStatus());\n    }\n}\n\n// Fixture file: Test/_files/custom_data.php\n<?php\ndeclare(strict_types=1);\n\nuse Magento\\TestFramework\\Helper\\Bootstrap;\n\n$objectManager = Bootstrap::getObjectManager();\n\n// Create test data\n$product = $objectManager->create(\\Magento\\Catalog\\Model\\Product::class);\n$product->setSku('test-product')\n    ->setName('Test Product')\n    ->setPrice(99.99)\n    ->setTypeId('simple')\n    ->setAttributeSetId(4)\n    ->setStatus(1)\n    ->setVisibility(4)\n    ->save();\n\n// Rollback file: Test/_files/custom_data_rollback.php\n<?php\nuse Magento\\TestFramework\\Helper\\Bootstrap;\nuse Magento\\Framework\\Registry;\n\n$objectManager = Bootstrap::getObjectManager();\n$registry = $objectManager->get(Registry::class);\n$registry->register('isSecureArea', true);\n\n// Clean up test data\n$product = $objectManager->create(\\Magento\\Catalog\\Model\\Product::class);\n$product->load('test-product', 'sku');\nif ($product->getId()) {\n    $product->delete();\n}\n\n$registry->unregister('isSecureArea');",
    "examDomain": "Review",
    "objectiveTags": [
      "testing-strategy",
      "integration-tests",
      "mftf"
    ]
  },
  {
    "id": 121,
    "category": "Testing",
    "difficulty": "Hard",
    "question": "How are Web API functional tests structured in Magento 2?",
    "options": [
      {
        "id": "A",
        "text": "Using JavaScript and browser automation"
      },
      {
        "id": "B",
        "text": "Extending WebapiAbstract with _webApiCall() and fixtures in _files directory"
      },
      {
        "id": "C",
        "text": "Only manual API testing is supported"
      },
      {
        "id": "D",
        "text": "Through GraphQL playground exclusively"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Web API tests extend special base classes for REST/SOAP testing.\n\nWhy B is correct:\n- WebapiAbstract: Base class for API tests\n- _webApiCall(): Makes authenticated API requests\n- Supports REST and SOAP\n- Fixtures for test data setup\n- Runs against real Magento instance\n\nWhy others are incorrect:\n- A: PHP-based, not JavaScript\n- C: Automated testing supported\n- D: REST/SOAP, not just GraphQL",
    "codeExample": "// Web API Functional Test\nnamespace Vendor\\Module\\Test\\Api;\n\nuse Magento\\TestFramework\\TestCase\\WebapiAbstract;\n\nclass ProductApiTest extends WebapiAbstract\n{\n    const RESOURCE_PATH = '/V1/products';\n\n    /**\n     * @magentoApiDataFixture Magento/Catalog/_files/product_simple.php\n     */\n    public function testGetProduct(): void\n    {\n        $sku = 'simple';\n\n        $serviceInfo = [\n            'rest' => [\n                'resourcePath' => self::RESOURCE_PATH . '/' . $sku,\n                'httpMethod' => \\Magento\\Framework\\Webapi\\Rest\\Request::HTTP_METHOD_GET,\n            ],\n            'soap' => [\n                'service' => 'catalogProductRepositoryV1',\n                'operation' => 'catalogProductRepositoryV1Get',\n            ],\n        ];\n\n        $response = $this->_webApiCall($serviceInfo);\n\n        $this->assertEquals($sku, $response['sku']);\n        $this->assertEquals('Simple Product', $response['name']);\n    }\n\n    public function testCreateProduct(): void\n    {\n        $productData = [\n            'product' => [\n                'sku' => 'test-api-product',\n                'name' => 'Test API Product',\n                'price' => 99.99,\n                'status' => 1,\n                'type_id' => 'simple',\n                'attribute_set_id' => 4,\n            ]\n        ];\n\n        $serviceInfo = [\n            'rest' => [\n                'resourcePath' => self::RESOURCE_PATH,\n                'httpMethod' => \\Magento\\Framework\\Webapi\\Rest\\Request::HTTP_METHOD_POST,\n            ],\n        ];\n\n        $response = $this->_webApiCall($serviceInfo, $productData);\n\n        $this->assertArrayHasKey('id', $response);\n    }\n}\n\n// Run: vendor/bin/phpunit -c dev/tests/api-functional/phpunit.xml.dist\n// Requires: TESTS_BASE_URL, TESTS_WEBSERVICE_USER, TESTS_WEBSERVICE_APIKEY",
    "examDomain": "Review",
    "objectiveTags": [
      "testing-strategy",
      "integration-tests",
      "mftf"
    ]
  },
  {
    "id": 122,
    "category": "Code Review & Refactoring",
    "difficulty": "Medium",
    "question": "During a code audit, you find a custom module that directly instantiates objects using `new` keyword inside a controller action instead of using dependency injection. Which refactoring approach is most appropriate?",
    "options": [
      {
        "id": "A",
        "text": "Replace all `new` instantiations with ObjectManager::getInstance()->create()"
      },
      {
        "id": "B",
        "text": "Inject dependencies through the constructor and declare them in di.xml if custom preferences are needed"
      },
      {
        "id": "C",
        "text": "Create a Factory class manually for each object and use those factories in the controller"
      },
      {
        "id": "D",
        "text": "Move the instantiation logic to a Helper class and inject only the Helper"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct: Constructor injection is the standard Magento 2 DI pattern. The framework's compiled DI container handles object creation, lifecycle, and substitution. Declaring constructor dependencies makes the class testable and allows overriding via di.xml.\n\nA is wrong: Using ObjectManager directly is explicitly discouraged by Magento coding standards. It hides dependencies, makes the class untestable, and bypasses the compiled DI container's optimizations.\n\nC is wrong: While factories are valid for objects that need multiple instances at runtime, you should not manually create factory classes. Magento auto-generates factories. For most service-layer dependencies, direct injection is preferred over factories.\n\nD is wrong: Moving instantiation into a Helper class simply relocates the anti-pattern rather than fixing it. Helpers that act as service locators violate the Single Responsibility Principle and obscure the real dependency graph.",
    "codeExample": "// BEFORE (anti-pattern):\nclass SaveController extends Action\n{\n    public function execute()\n    {\n        $validator = new \\Vendor\\Module\\Model\\Validator();\n        $processor = new \\Vendor\\Module\\Model\\Processor();\n        // ...\n    }\n}\n\n// AFTER (correct DI):\nclass SaveController extends Action\n{\n    public function __construct(\n        Context $context,\n        private readonly Validator $validator,\n        private readonly Processor $processor\n    ) {\n        parent::__construct($context);\n    }\n\n    public function execute()\n    {\n        $this->validator->validate($data);\n        $this->processor->process($data);\n    }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "refactoring",
      "maintainability"
    ]
  },
  {
    "id": 123,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "question": "You are reviewing a module that uses a `preference` in di.xml to completely replace the core `Magento\\Catalog\\Model\\Product` class with a custom implementation that adds three new methods. What is the primary architectural concern, and what is the recommended refactoring strategy?",
    "options": [
      {
        "id": "A",
        "text": "Preferences on models are fine since they are the standard extension mechanism; no refactoring needed"
      },
      {
        "id": "B",
        "text": "Replace the preference with an around plugin on each method that needs modification, keeping the core class intact"
      },
      {
        "id": "C",
        "text": "Replace the preference with an observer on relevant events, and extract the new methods into a separate service class that operates on product data"
      },
      {
        "id": "D",
        "text": "Replace the preference with a composition-based approach: create extension attributes for additional data and a dedicated service class for the new business logic"
      },
      {
        "id": "E",
        "text": "Keep the preference but extend it from the core class to preserve backward compatibility"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "explanation": "D is correct: Composition over inheritance is the preferred approach. Extension attributes provide a framework-supported mechanism to add data to existing entities without modifying their class hierarchy. A dedicated service class for business logic follows the Single Responsibility Principle and avoids conflicts with other modules that may also need to extend the Product model.\n\nA is wrong: Preferences on core entity models like Product are highly problematic because only one preference can win at runtime. If another module also declares a preference for the same class, one will silently override the other, causing unpredictable behavior.\n\nB is wrong: While plugins avoid the single-preference conflict, using around plugins on a model class to add entirely new methods is not possible  plugins can only intercept existing public methods. They cannot add new public API surface to a class.\n\nC is wrong: Observers only fire on dispatched events, so they cannot intercept arbitrary method calls. Extracting to a service class is good advice, but relying solely on observers limits when that logic can execute. Observers also cannot return values or modify method output.\n\nE is wrong: Extending from the core class does not solve the fundamental problem  only one preference wins. If two modules both set preferences that extend the core Product class, one module's functionality is lost entirely.",
    "codeExample": "// BEFORE (anti-pattern): preference replaces Product entirely\n// di.xml: <preference for=\"Magento\\Catalog\\Model\\Product\" type=\"Vendor\\Module\\Model\\CustomProduct\" />\n\n// AFTER (composition approach):\n// 1. extension_attributes.xml:\n// <extension_attributes for=\"Magento\\Catalog\\Api\\Data\\ProductInterface\">\n//     <attribute code=\"custom_warranty\" type=\"Vendor\\Module\\Api\\Data\\WarrantyInterface\" />\n// </extension_attributes>\n\n// 2. Dedicated service class:\nclass ProductWarrantyService\n{\n    public function __construct(\n        private readonly WarrantyRepositoryInterface $warrantyRepository\n    ) {}\n\n    public function getWarrantyForProduct(ProductInterface $product): ?WarrantyInterface\n    {\n        return $this->warrantyRepository->getByProductId((int) $product->getId());\n    }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "refactoring",
      "maintainability"
    ]
  },
  {
    "id": 124,
    "category": "Code Review & Refactoring",
    "difficulty": "Medium",
    "question": "Your team runs PHPStan at level 6 on a Magento 2 project. A developer proposes increasing to level 8. Which statement best describes the architectural impact of this decision?",
    "options": [
      {
        "id": "A",
        "text": "Level 8 adds strict property type checking and enforces return type declarations, which will likely surface hundreds of errors in modules relying on magic getters/setters in AbstractModel subclasses"
      },
      {
        "id": "B",
        "text": "Level 8 only adds stricter null-checking rules and has minimal impact on Magento code because Magento already handles null types properly"
      },
      {
        "id": "C",
        "text": "Level 8 is identical to level 6 but enables parallel execution, so the only impact is faster CI pipeline runs"
      },
      {
        "id": "D",
        "text": "Level 8 requires PHP 8.2+ and cannot be used with Magento 2.4.x which supports PHP 8.1"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "A is correct: PHPStan level 8 enforces strict type rules including method return types and property types. Magento's AbstractModel relies heavily on magic __get/__set methods and getData()/setData() patterns that lack proper type declarations. Moving to level 8 will flag these as errors because PHPStan cannot infer types from magic methods without a custom extension or phpDoc annotations, generating a large volume of new findings.\n\nB is wrong: Level 8 goes well beyond null-checking. It enforces strict rules on method calls, property access, and type juggling. Magento code frequently uses loose typing patterns that level 8 catches. The claim that Magento handles null types properly is also incorrect  many core methods have incomplete type annotations.\n\nC is wrong: PHPStan levels are strictly about analysis strictness, not execution performance. Each level adds new categories of checks. Parallel execution is a separate configuration option available at any level.\n\nD is wrong: PHPStan levels are not tied to PHP versions. PHPStan supports analysis at any level regardless of the PHP runtime version. The tool's configuration is independent of the PHP version the project targets.",
    "codeExample": "// Common PHPStan level 8 errors in Magento code:\n\n// Error: Method getData() returns mixed, used as string\n$name = $product->getData('name');\nstrlower($name); // PHPStan level 8: Parameter #1 expects string, mixed given\n\n// Error: Magic method call not recognized\n$product->getCustomAttribute(); // Method getCustomAttribute() not found\n\n// Fix: Add phpDoc or use typed getters\n/** @var string $name */\n$name = $product->getData('name');\n// Or better: $name = (string) $product->getName();",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "refactoring",
      "maintainability"
    ]
  },
  {
    "id": 125,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "question": "During a code review, you identify a service class with a cyclomatic complexity of 47 in its main method. The method handles order processing with branching logic for different payment methods, shipping carriers, and customer groups. Which refactoring strategy best reduces complexity while maintaining the open/closed principle?",
    "options": [
      {
        "id": "A",
        "text": "Split the method into smaller private methods within the same class, one per logical branch"
      },
      {
        "id": "B",
        "text": "Use the Strategy pattern with a pool of handler classes injected via di.xml, each responsible for one payment/shipping/customer combination"
      },
      {
        "id": "C",
        "text": "Replace conditional logic with a Chain of Responsibility pattern where each handler decides if it can process the order and delegates otherwise"
      },
      {
        "id": "D",
        "text": "Create a single abstract base handler class and extend it for each variation, using a Factory to select the correct subclass"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct: Chain of Responsibility is ideal here because order processing involves multiple independent concerns (payment, shipping, customer group) that should be evaluated in sequence. Each handler encapsulates one decision domain, can be added/removed via di.xml without modifying existing handlers (open/closed principle), and the chain naturally reduces cyclomatic complexity by distributing branching across focused classes. Magento itself uses this pattern in its validation and processing pipelines.\n\nA is wrong: Extracting to private methods reduces the visual complexity of the main method but does not reduce the actual cyclomatic complexity of the class. The class still contains all the branching logic, cannot be extended without modification, and becomes harder to test because private methods cannot be tested in isolation.\n\nB is wrong: A strategy pool works when you need to select exactly one strategy based on a single discriminator. Order processing with payment  shipping  customer group combinations creates a combinatorial explosion of strategy classes. The pool approach forces you to create a handler for every possible combination rather than composing independent concerns.\n\nD is wrong: A class hierarchy with a factory couples the selection logic to a factory class that must be modified whenever a new variation is added, violating the open/closed principle. Deep inheritance hierarchies also make it difficult to compose behaviors across multiple concerns (payment AND shipping AND customer group).",
    "codeExample": "// Chain of Responsibility via di.xml:\n// <type name=\"Vendor\\Module\\Model\\OrderProcessorChain\">\n//     <arguments>\n//         <argument name=\"processors\" xsi:type=\"array\">\n//             <item name=\"payment\" xsi:type=\"object\">Vendor\\Module\\Model\\Processor\\PaymentProcessor</item>\n//             <item name=\"shipping\" xsi:type=\"object\">Vendor\\Module\\Model\\Processor\\ShippingProcessor</item>\n//             <item name=\"customer\" xsi:type=\"object\">Vendor\\Module\\Model\\Processor\\CustomerGroupProcessor</item>\n//         </argument>\n//     </arguments>\n// </type>\n\nclass OrderProcessorChain implements OrderProcessorInterface\n{\n    public function __construct(\n        private readonly array $processors\n    ) {}\n\n    public function process(OrderInterface $order): OrderInterface\n    {\n        foreach ($this->processors as $processor) {\n            $order = $processor->process($order);\n        }\n        return $order;\n    }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "refactoring",
      "maintainability"
    ]
  },
  {
    "id": 126,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "question": "You discover a circular dependency: Module A's service injects Module B's repository, and Module B's plugin injects Module A's service. The application crashes with a circular dependency error during compilation. Which approach correctly resolves this while preserving functionality?",
    "options": [
      {
        "id": "A",
        "text": "Use Proxy classes for one of the dependencies so it is lazy-loaded, breaking the circular instantiation chain"
      },
      {
        "id": "B",
        "text": "Merge both modules into a single module to eliminate the cross-module dependency entirely"
      },
      {
        "id": "C",
        "text": "Extract the shared contract into a third module containing only interfaces, and have both modules depend on that contract module instead of each other"
      },
      {
        "id": "D",
        "text": "Replace constructor injection with ObjectManager::getInstance() calls in one of the modules to bypass the DI container's cycle detection"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct: Extracting shared interfaces into a separate contract module (following Magento's own *Api pattern, e.g., Magento_CatalogApi) applies the Dependency Inversion Principle. Both modules depend on abstractions in the contract module rather than on each other's concrete implementations. This breaks the circular dependency at the architectural level, not just at the instantiation level, and allows either module to be replaced independently.\n\nA is wrong: Proxy classes are a valid tactical fix that breaks the instantiation cycle by deferring object creation. However, they mask the underlying architectural problem  the modules are still tightly coupled. The circular dependency remains in the module dependency graph (module.xml sequence declarations), which causes issues with module ordering, upgrades, and independent deployability. Proxies should be a temporary measure, not a permanent solution.\n\nB is wrong: Merging modules defeats the purpose of modular architecture. It increases the blast radius of changes, makes independent testing harder, and creates a monolithic module that violates the Single Responsibility Principle. This approach moves in the opposite direction of good architecture.\n\nD is wrong: Using ObjectManager directly is the worst option. It hides the dependency entirely from the DI container, making the code untestable, uncompilable by Magento's DI compilation step, and invisible in dependency analysis tools. It also violates Magento's coding standards.",
    "codeExample": "// BEFORE: Circular dependency\n// Module A: ServiceA injects RepositoryB\n// Module B: PluginOnX injects ServiceA\n\n// AFTER: Contract module breaks the cycle\n// Module_Contract (new):\nnamespace Vendor\\Contract\\Api;\n\ninterface ServiceAInterface {\n    public function execute(int $entityId): ResultInterface;\n}\n\ninterface RepositoryBInterface {\n    public function getById(int $id): EntityBInterface;\n}\n\n// Module A depends on Contract (not B):\n// Module A implements ServiceAInterface\n// Module A injects RepositoryBInterface\n\n// Module B depends on Contract (not A):\n// Module B implements RepositoryBInterface\n// Module B's plugin injects ServiceAInterface",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "refactoring",
      "maintainability"
    ]
  },
  {
    "id": 127,
    "category": "Code Review & Refactoring",
    "difficulty": "Medium",
    "question": "Which of the following items should be flagged during an Adobe Commerce code review? (Select TWO)",
    "options": [
      {
        "id": "A",
        "text": "A plugin's before method modifies a parameter passed by reference and returns null"
      },
      {
        "id": "B",
        "text": "An observer class implements \\Magento\\Framework\\Event\\ObserverInterface and has a single execute() method with no constructor dependencies"
      },
      {
        "id": "C",
        "text": "A repository class catches all exceptions and returns an empty collection instead of propagating the error"
      },
      {
        "id": "D",
        "text": "A ViewModel implements \\Magento\\Framework\\View\\Element\\Block\\ArgumentInterface and injects a repository to provide data to a template"
      },
      {
        "id": "E",
        "text": "A custom REST API endpoint returns a response object implementing \\Magento\\Framework\\Api\\ExtensibleDataInterface"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "explanation": "A should be flagged: In a before plugin, the method must return an array of the modified arguments (or null to keep originals unchanged). If the plugin modifies a parameter and returns null, the modification may not propagate correctly depending on the parameter type. This is a subtle bug that passes basic testing but fails unpredictably. The correct pattern is to return the modified arguments as an array.\n\nC should be flagged: Catching all exceptions and returning an empty collection silently swallows errors. This masks bugs like database connection failures, invalid queries, or data corruption. The caller has no way to distinguish between \"no results found\" and \"a fatal error occurred.\" Repository methods should let exceptions propagate or throw specific domain exceptions.\n\nB is not a problem: An observer with no constructor dependencies is perfectly valid for lightweight event handling. Not every class needs injected dependencies  some observers only need the data from the event object passed to execute().\n\nD is not a problem: This is the correct pattern for providing data to templates in Magento 2. ViewModels replaced the older Block-based approach and should inject repositories or services to supply data to .phtml templates.\n\nE is not a problem: Implementing ExtensibleDataInterface for REST API response objects is the standard Magento pattern that enables extension attributes and proper serialization by the web API framework.",
    "codeExample": "// Flag A  buggy before plugin:\npublic function beforeSave(\n    \\Magento\\Catalog\\Api\\ProductRepositoryInterface $subject,\n    \\Magento\\Catalog\\Api\\Data\\ProductInterface $product\n) {\n    $product->setCustomAttribute('processed', true); // modifying param\n    return null; // BUG: should return [$product] to propagate change\n}\n\n// Flag C  silent error swallowing:\npublic function getList(SearchCriteriaInterface $criteria): ProductSearchResultsInterface\n{\n    try {\n        return $this->productRepository->getList($criteria);\n    } catch (\\Exception $e) {\n        return $this->searchResultsFactory->create(); // WRONG: hides errors\n    }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "refactoring",
      "maintainability"
    ]
  },
  {
    "id": 128,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "question": "A core Magento class has the `@api` annotation on its public methods. A third-party module overrides one of these methods via a preference and changes its return type from `string` to `string|null`. According to Magento's backward compatibility policy and semantic versioning, what is the correct assessment?",
    "options": [
      {
        "id": "A",
        "text": "This is a backward-compatible change because it widens the return type, and callers that handle strings can also handle null safely in PHP 8"
      },
      {
        "id": "B",
        "text": "This is a backward-incompatible change because @api methods are part of the public contract; changing the return type requires a major version increment and will break callers that do not perform null checks"
      },
      {
        "id": "C",
        "text": "This change is acceptable for a minor version because the @api annotation only prevents removal of methods, not changes to their signatures"
      },
      {
        "id": "D",
        "text": "The @api annotation is purely informational and has no impact on backward compatibility or semantic versioning decisions"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct: Methods annotated with @api are Magento's guaranteed public contract. Under Magento's semantic versioning policy (which follows semver 2.0), any change to the signature of an @api method  including widening a return type  constitutes a backward-incompatible change. Existing callers rely on the method always returning a string and may call string methods on the result without null checks. Returning null would cause TypeError or fatal errors in those callers. Such changes require a major version bump.\n\nA is wrong: While PHP 8's type system allows union types, widening a return type is a breaking change from the caller's perspective. Code written against the original contract `string` legitimately calls string methods (strlen, substr, etc.) on the return value. Introducing null as a possible return value breaks all callers that do not have null guards. Backward compatibility is about the contract, not what PHP technically allows.\n\nC is wrong: The @api annotation protects the entire method signature, not just its existence. Magento's backward compatibility policy explicitly states that @api methods cannot have their parameters, return types, or behavior changed in minor or patch versions. Only additions (new optional parameters with defaults) are permitted.\n\nD is wrong: The @api annotation has concrete implications in Magento's development process. Magento's automated backward compatibility checker (static test suite) specifically scans for @api annotation changes. Modules that depend on @api interfaces are guaranteed stability across minor versions.",
    "codeExample": "// Core class with @api contract:\nnamespace Magento\\Catalog\\Model;\n\nclass Product\n{\n    /**\n     * @api\n     * @return string\n     */\n    public function getSku(): string\n    {\n        return (string) $this->getData('sku');\n    }\n}\n\n// BREAKING CHANGE  third-party preference:\nclass CustomProduct extends Product\n{\n    public function getSku(): string|null  // BC BREAK!\n    {\n        $sku = $this->getData('sku');\n        return $sku ?: null;\n    }\n}\n\n// Existing caller that will break:\n$sku = $product->getSku();\n$normalized = strtolower($sku); // TypeError if null",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "refactoring",
      "maintainability"
    ]
  },
  {
    "id": 129,
    "category": "Code Review & Refactoring",
    "difficulty": "Medium",
    "question": "You are assessing technical debt in a Magento 2 project. The codebase has: (1) 15 classes using ObjectManager directly, (2) 8 controllers with 400+ line execute() methods, (3) 3 modules missing composer.json dependency declarations, (4) 45 deprecated method calls flagged by PHPStan. Which items should be prioritized first for refactoring?",
    "options": [
      {
        "id": "A",
        "text": "Deprecated method calls first, because they will cause fatal errors on the next Magento upgrade"
      },
      {
        "id": "B",
        "text": "ObjectManager usage first, because it causes immediate runtime failures in production"
      },
      {
        "id": "C",
        "text": "Missing composer.json declarations first, because they prevent reliable deployment and can cause silent failures when modules are installed in different orders"
      },
      {
        "id": "D",
        "text": "Large controllers first, because high complexity is the leading cause of production bugs and makes all other refactoring harder"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct: Missing composer.json dependency declarations are the highest priority because they create deployment-time risks that are difficult to diagnose. If module installation order changes or a dependency is not present, the application may fail to compile or may produce runtime errors that appear unrelated to the actual cause. This affects the reliability of CI/CD pipelines, cloud deployments, and environment provisioning. It is also the fastest fix with the highest risk-reduction ratio.\n\nA is wrong: Deprecated method calls are important but not the highest priority. Deprecated methods continue to function in the current version  they only become breaking changes on major version upgrades. You have time to address these before upgrading. PHPStan can continuously track them so none are missed.\n\nB is wrong: ObjectManager usage does not cause immediate runtime failures. The code works; it is just poorly structured. ObjectManager calls bypass DI compilation optimizations and make testing difficult, but they are a code quality issue, not a stability issue. They should be refactored but are not urgent.\n\nD is wrong: Large controllers are a maintainability concern, not an immediate risk. They make the code harder to understand and modify, but they do not cause failures. Refactoring them is valuable but should come after addressing issues that affect deployment reliability and application stability.",
    "codeExample": "",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "refactoring",
      "maintainability"
    ]
  },
  {
    "id": 130,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "question": "You review a module where a single class implements OrderManagementInterface, handles CSV export, sends email notifications, writes to a custom log, and updates inventory. This class has 12 constructor dependencies. Which SOLID principle violations are present, and what is the correct refactoring approach? (Select TWO)",
    "options": [
      {
        "id": "A",
        "text": "Single Responsibility Principle: Extract CSV export, email notification, logging, and inventory update into separate service classes, coordinated by a lightweight orchestrator"
      },
      {
        "id": "B",
        "text": "Liskov Substitution Principle: The class cannot be substituted for OrderManagementInterface because it has side effects not defined in the interface contract"
      },
      {
        "id": "C",
        "text": "Interface Segregation Principle: The class likely forces callers to depend on methods they don't use; split the interface into focused contracts like ExportServiceInterface, NotificationServiceInterface"
      },
      {
        "id": "D",
        "text": "Open/Closed Principle: The class cannot be extended without modification because all logic is in a single method"
      },
      {
        "id": "E",
        "text": "Dependency Inversion Principle: The 12 constructor dependencies prove the class depends on too many concrete implementations"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "explanation": "A is correct (SRP violation): A class responsible for order management, CSV export, email notifications, logging, and inventory updates has at least five distinct responsibilities. Each should be a separate service class with its own single purpose. An orchestrator (or chain/pipeline) should coordinate them. This reduces each class to 2-3 dependencies and makes each independently testable.\n\nC is correct (ISP violation): When a class handles five different concerns behind a single interface, callers that only need CSV export are forced to depend on the entire class including email, logging, and inventory logic. Splitting into focused interfaces (ExportServiceInterface, NotificationServiceInterface, etc.) allows callers to depend only on what they actually use.\n\nB is wrong: LSP is about behavioral substitutability  a subclass must honor the superclass's contract. The issue described here is not about substitution but about a class doing too much. Side effects like logging and notifications are implementation details, not LSP violations, as long as the method fulfills its documented contract.\n\nD is wrong: While OCP may also be a concern, the primary issue is not extensibility. The problem is not that you cannot extend the class but that the class itself conflates unrelated concerns. OCP becomes relevant after SRP is addressed.\n\nE is wrong: Having many constructor dependencies is a symptom of SRP violation, not a DIP violation. DIP is about depending on abstractions rather than concretions. If the 12 dependencies are all interfaces (which is standard in Magento DI), DIP is actually being followed. The real problem is that no single class should need 12 dependencies.",
    "codeExample": "// BEFORE: God class violating SRP and ISP\nclass OrderProcessor implements OrderManagementInterface\n{\n    public function __construct(\n        private OrderRepository $orderRepo,\n        private CsvWriter $csvWriter,\n        private TransportBuilder $emailTransport,\n        private LoggerInterface $logger,\n        private StockRegistryInterface $stockRegistry,\n        // ... 7 more dependencies\n    ) {}\n\n    public function process(OrderInterface $order): void\n    {\n        // 300 lines handling ALL concerns\n    }\n}\n\n// AFTER: Focused classes coordinated by orchestrator\nclass OrderProcessorOrchestrator\n{\n    public function __construct(\n        private OrderPersistenceService $persistence,\n        private OrderExportService $export,\n        private OrderNotificationService $notification,\n        private InventoryUpdateService $inventory\n    ) {}\n\n    public function process(OrderInterface $order): void\n    {\n        $this->persistence->save($order);\n        $this->inventory->adjust($order);\n        $this->notification->send($order);\n        $this->export->queue($order);\n    }\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "refactoring",
      "maintainability"
    ]
  },
  {
    "id": 131,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "question": "A Magento 2 project enforces Magento Coding Standards (MEQP2) and PSR-12 in its CI pipeline. A developer submits a PR that introduces an around plugin on a public method of a class that is NOT marked with `@api`. The plugin modifies both input parameters and the return value. What are the valid review concerns? (Select TWO)",
    "options": [
      {
        "id": "A",
        "text": "Around plugins on non-@api methods are risky because the method signature may change without notice in minor/patch Magento releases, breaking the plugin silently"
      },
      {
        "id": "B",
        "text": "Around plugins violate PSR-12 because they introduce implicit control flow that is not visible in the class being modified"
      },
      {
        "id": "C",
        "text": "Around plugins that modify both input and output increase debugging complexity significantly; the review should verify that a before + after plugin combination cannot achieve the same result with less risk"
      },
      {
        "id": "D",
        "text": "Around plugins cannot be used on non-@api methods due to Magento's DI compilation rejecting them"
      },
      {
        "id": "E",
        "text": "Around plugins on non-@api methods should use type-safe parameter checking via PHP 8 named arguments to ensure forward compatibility"
      }
    ],
    "correctAnswers": [
      "A",
      "C"
    ],
    "explanation": "A is a valid concern: Non-@api methods have no backward compatibility guarantee. Magento may rename, remove, or change the signature of such methods in any release (minor or patch). An around plugin tightly couples to the method's exact signature  if a parameter is added, removed, or retyped, the plugin breaks silently or throws a TypeError at runtime. This is a maintenance risk that must be documented and tracked.\n\nC is a valid concern: Around plugins that modify both input and output are the most complex form of interception. They wrap the entire method call, making it difficult to debug because the stack trace shows the plugin's callable, not the original method flow. Code reviewers should verify whether a simpler before plugin (to modify input) combined with an after plugin (to modify output) achieves the same result. The before/after combination is easier to debug, composes better with other plugins, and has a clearer execution order.\n\nB is wrong: PSR-12 is a code formatting standard covering brace placement, indentation, line length, and similar style rules. It has no opinion on design patterns, architectural decisions, or plugin usage. Control flow concerns are valid but fall under Magento architecture reviews, not PSR-12 compliance.\n\nD is wrong: Magento's DI compilation does not restrict plugins to @api methods. Plugins can intercept any public method of any non-final class. The @api annotation is a documentation/contract marker, not an enforcement mechanism in the DI compiler.\n\nE is wrong: PHP 8 named arguments do not provide forward compatibility for plugins. If the method signature changes, named arguments break just as positional arguments do. Named arguments also interact poorly with Magento's plugin interception layer, which passes arguments positionally.",
    "codeExample": "// Non-@api method being intercepted (risky):\n// Note: no @api annotation  no BC guarantee\npublic function calculateDiscount(CartInterface $cart, float $baseAmount): float\n\n// Around plugin  high complexity:\npublic function aroundCalculateDiscount(\n    OriginalClass $subject,\n    callable $proceed,\n    CartInterface $cart,\n    float $baseAmount\n): float {\n    $modifiedAmount = $baseAmount * 1.1; // modifying input\n    $result = $proceed($cart, $modifiedAmount);\n    return $result + $this->getAdditionalDiscount($cart); // modifying output\n}\n\n// Preferred: before + after (less risk, easier debugging):\npublic function beforeCalculateDiscount(\n    OriginalClass $subject,\n    CartInterface $cart,\n    float $baseAmount\n): array {\n    return [$cart, $baseAmount * 1.1];\n}\n\npublic function afterCalculateDiscount(\n    OriginalClass $subject,\n    float $result\n): float {\n    return $result + $this->getAdditionalDiscount();\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "refactoring",
      "maintainability"
    ]
  },
  {
    "id": 132,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Medium",
    "question": "A production Magento 2 store intermittently returns 503 errors during peak traffic. The server logs show no PHP fatal errors, and the application log has no exceptions. Nginx error logs show 'upstream timed out (110: Connection timed out) while reading response header from upstream'. What is the most effective first step to identify the root cause?",
    "options": [
      {
        "id": "A",
        "text": "Increase the nginx proxy_read_timeout to 300 seconds to prevent the timeout"
      },
      {
        "id": "B",
        "text": "Enable the Magento profiler and analyze the slow requests to identify which controller actions are consuming excessive time"
      },
      {
        "id": "C",
        "text": "Check php-fpm status page and slow log to identify which PHP processes are blocked and what they are executing"
      },
      {
        "id": "D",
        "text": "Scale the infrastructure by adding more web nodes behind the load balancer"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct because the nginx 'upstream timed out' error means php-fpm workers are not responding within the timeout period. The php-fpm slow log (configured via request_slowlog_timeout) will capture stack traces of long-running PHP processes, revealing exactly what code path is blocking  whether it's a slow database query, external API call, or lock contention. The php-fpm status page shows how many workers are active vs idle, confirming if worker pool exhaustion is occurring. A is wrong because increasing the timeout only masks the symptom  requests are still slow, users still wait, and worker pool exhaustion continues. B is wrong because the Magento profiler adds overhead and is not suitable for production debugging; it also won't capture what's happening in requests that are already stuck. D is wrong because adding nodes without understanding the bottleneck may not help  if requests are blocked on a shared resource like the database or Redis, more nodes will increase contention.",
    "codeExample": "; php-fpm pool configuration for slow log diagnosis\n; /etc/php-fpm.d/www.conf\nrequest_slowlog_timeout = 5s\nslowlog = /var/log/php-fpm/www-slow.log\n\n; Example slow log output showing the blocking call:\n[pool www] pid 12345\nscript_filename = /var/www/magento/pub/index.php\n[0x00007f8a1c0] sleep() /var/www/magento/vendor/magento/module-catalog/Model/ResourceModel/Product/Collection.php:487\n[0x00007f8a1c1] load() /var/www/magento/vendor/magento/framework/Data/Collection/AbstractDb.php:640\n[0x00007f8a1c2] _loadEntities() /var/www/magento/vendor/magento/module-catalog/Model/ResourceModel/Product/Collection.php:512",
    "examDomain": "Review",
    "objectiveTags": [
      "troubleshooting",
      "root-cause-analysis",
      "production-debugging"
    ]
  },
  {
    "id": 133,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Hard",
    "question": "A Magento 2 store's catalog pages have gradually degraded from 800ms to 4+ seconds over several months. Full page cache hit rates remain above 95%. The New Relic APM transaction trace for a cache-miss catalog page shows: Database 45%, PHP 40%, External 10%, Redis 5%. The top database call is a SELECT on catalog_product_entity with 23 JOINs taking 1.8 seconds. Which combination of actions would an architect recommend to systematically resolve this?",
    "options": [
      {
        "id": "A",
        "text": "Enable MySQL query cache and add composite indexes covering the most frequent WHERE clause combinations"
      },
      {
        "id": "B",
        "text": "Analyze the EAV attribute configuration to remove unused attributes from flat tables, review third-party modules adding unnecessary JOINs via plugins on the collection, and verify Elasticsearch is handling filterable attributes instead of MySQL"
      },
      {
        "id": "C",
        "text": "Increase PHP memory_limit and opcache size since the 40% PHP time indicates memory pressure causing garbage collection pauses"
      },
      {
        "id": "D",
        "text": "Switch from MySQL to MariaDB for better query optimizer performance and enable the Aria storage engine for temporary tables"
      },
      {
        "id": "E",
        "text": "Replace the entire catalog with a headless frontend making direct Elasticsearch queries to bypass the ORM overhead"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because the 23-JOIN query is the hallmark of EAV attribute sprawl  every product attribute added to flat tables or collection selects adds another JOIN. The systematic approach is: (1) audit catalog_eav_attribute to find attributes with is_used_in_grid, used_in_product_listing, or is_filterable that don't need to be, reducing JOINs; (2) check for third-party modules that hook into product collection load via plugins on beforeLoad/afterLoad or around plugins on addFieldToFilter, adding unnecessary JOINs  this is the most common cause of gradual degradation as modules are installed over months; (3) verify that layered navigation filters are hitting Elasticsearch rather than falling back to MySQL queries, since misconfigured search engines cause expensive aggregation queries. A is wrong because MySQL query cache was removed in MySQL 8.0 and was deprecated even in 5.7; adding indexes without reducing the number of JOINs provides minimal improvement when the fundamental problem is too many table joins. C is wrong because 40% PHP time is relative to the total transaction  reducing database time would shift the ratio, and PHP memory_limit doesn't cause GC pauses in typical request flows. D is wrong because the query optimizer difference between MySQL and MariaDB won't fix a fundamentally over-joined query design. E is wrong because it's a massive architectural overhaul that doesn't address the root cause  the EAV query would still be slow for any consumer of the data.",
    "codeExample": "-- Diagnostic query: Find attributes adding unnecessary JOINs\nSELECT ea.attribute_code, ea.backend_type, cea.is_filterable,\n       cea.used_in_product_listing, cea.is_used_for_sort_by\nFROM eav_attribute ea\nJOIN catalog_eav_attribute cea ON ea.attribute_id = cea.attribute_id\nWHERE ea.entity_type_id = 4\n  AND (cea.used_in_product_listing = 1 OR cea.is_filterable = 1)\nORDER BY ea.attribute_code;\n\n-- Check for plugin interference on collection loading\n-- grep -r 'catalog_product_collection' vendor/thirdparty/*/etc/di.xml\n-- Look for: <type name=\"Magento\\Catalog\\Model\\ResourceModel\\Product\\Collection\">",
    "examDomain": "Review",
    "objectiveTags": [
      "troubleshooting",
      "root-cause-analysis",
      "production-debugging"
    ]
  },
  {
    "id": 134,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Hard",
    "question": "A Magento 2 application's memory usage climbs steadily during cron execution, eventually reaching the 2GB PHP memory limit and crashing after processing approximately 15,000 of 50,000 products in a custom mass-update script. The script uses a product collection iterator. What is the most likely root cause and correct fix?",
    "options": [
      {
        "id": "A",
        "text": "PHP's garbage collector is not running; add gc_collect_cycles() calls after each batch to force memory reclamation"
      },
      {
        "id": "B",
        "text": "The ObjectManager singleton instances and the EAV model's identity map retain references to every loaded entity; use collection pagination with clear() and implement the iterator pattern via Magento\\Framework\\Model\\ResourceModel\\Iterator"
      },
      {
        "id": "C",
        "text": "Increase the PHP memory_limit to 4GB since 50,000 products require proportionally more memory"
      },
      {
        "id": "D",
        "text": "The MySQL result set is being buffered entirely in PHP memory; switch to unbuffered queries using PDO::MYSQL_ATTR_USE_BUFFERED_QUERY = false"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because Magento 2's ORM maintains an identity map in the EAV resource model and the ObjectManager retains singleton references to repositories and their internal caches. When iterating through a collection with getItems() or foreach, each loaded product entity persists in memory even after the loop moves on, because: (1) the collection's _items array holds references; (2) the entity's resource model identity map retains the entity; (3) repositories with internal caching keep references. The fix is to use Magento\\Framework\\Model\\ResourceModel\\Iterator::walk() which processes rows one at a time without hydrating the full collection, or paginate manually using setPageSize()/setCurPage() with collection->clear() between pages to release accumulated references. A is wrong because gc_collect_cycles() only handles circular references  the memory leak here is from legitimate strong references in the identity map and collection, not circular references that the GC would clean. PHP's refcount-based memory management already frees non-circular references immediately, so gc_collect_cycles won't help. C is wrong because increasing memory_limit is not a solution  it delays the crash but the linear growth means any finite limit will eventually be hit with enough products, and 4GB per cron process is wasteful. D is wrong because while MySQL buffered queries do consume memory, the dominant memory consumer here is the PHP-side entity hydration and identity map  each product with its EAV attributes, stock data, and related entities consumes far more memory than the raw database row.",
    "codeExample": "<?php\n// PROBLEM: Memory leak - entire collection stays in memory\n$collection = $this->productCollectionFactory->create();\n$collection->addAttributeToSelect('*');\nforeach ($collection as $product) {\n    // Each product stays in memory even after iteration\n    $this->updateProduct($product);\n}\n// Memory: ~50KB per product  50,000 = ~2.5GB\n\n// SOLUTION: Use ResourceModel Iterator\n$collection = $this->productCollectionFactory->create();\n$collection->addAttributeToSelect(['sku', 'status']); // Select only needed\n\n/** @var \\Magento\\Framework\\Model\\ResourceModel\\Iterator $iterator */\n$this->iterator->walk(\n    $collection->getSelect(),\n    [[$this, 'processRow']],\n    [],\n    $collection->getConnection()\n);\n\n// Each row is a plain array, no entity hydration, no identity map\npublic function processRow(array $args): void\n{\n    $row = $args['row'];\n    // Process using raw data, ~1KB per row\n}",
    "examDomain": "Review",
    "objectiveTags": [
      "troubleshooting",
      "root-cause-analysis",
      "production-debugging"
    ]
  },
  {
    "id": 135,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Medium",
    "question": "A Magento Commerce Cloud deployment fails during the deploy phase with the error: 'SQLSTATE[HY000]: General error: 1205 Lock wait timeout exceeded; try restarting transaction' during setup:upgrade. The build phase completed successfully. The site was receiving live traffic during deployment. What is the root cause and appropriate resolution?",
    "options": [
      {
        "id": "A",
        "text": "The database server's innodb_lock_wait_timeout is too low; increase it to 300 seconds in the Cloud database configuration"
      },
      {
        "id": "B",
        "text": "Active frontend requests are holding row-level locks on tables that setup:upgrade DDL operations need to modify, and the maintenance mode should be enabled before the deploy phase runs migrations"
      },
      {
        "id": "C",
        "text": "The deploy phase should be moved to the build phase by running setup:upgrade during build instead"
      },
      {
        "id": "D",
        "text": "A database backup should be taken before deployment to allow rollback, then retry the deployment during off-peak hours"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because on Magento Cloud, the deploy phase runs setup:upgrade which executes DDL statements (ALTER TABLE, CREATE TABLE) and DML statements (INSERT/UPDATE to setup_module, flag tables). When live traffic is hitting the site simultaneously, frontend requests hold InnoDB row-level locks on catalog, checkout, and customer tables. When setup:upgrade attempts to ALTER these tables, MySQL must acquire a metadata lock, which conflicts with active transactions. The lock wait timeout expires because long-running frontend transactions don't release their locks in time. The correct approach is to ensure maintenance mode or traffic routing (via .magento.env.yaml SKIP_SCD flag or ideal_state configuration) prevents frontend traffic from reaching the database during migrations. Magento Cloud's deploy hooks support enabling maintenance mode before setup:upgrade. A is wrong because increasing the timeout only delays the failure  the fundamental conflict between DDL and active DML remains, and a 300-second timeout would mean the deployment hangs for 5 minutes per conflicting table before failing. C is wrong because setup:upgrade cannot run during the build phase on Cloud since the build environment doesn't have database access  the build phase is isolated from the database for architectural safety. D is wrong because taking a backup doesn't prevent the lock conflict, and 'off-peak hours' is unreliable  even a few active sessions can cause lock conflicts with DDL operations.",
    "codeExample": "# .magento.app.yaml - Correct deploy hook configuration\nhooks:\n    build: |\n        set -e\n        php ./vendor/bin/ece-tools run scenario/build/generate.xml\n        php ./vendor/bin/ece-tools run scenario/build/transfer.xml\n    deploy: |\n        set -e\n        # Maintenance mode enabled automatically by ece-tools\n        # before setup:upgrade runs\n        php ./vendor/bin/ece-tools run scenario/deploy.xml\n    post_deploy: |\n        set -e\n        php ./vendor/bin/ece-tools run scenario/post-deploy.xml\n\n# .magento.env.yaml - Control deploy behavior\nstage:\n  deploy:\n    ENABLE_GOOGLE_ANALYTICS: false  # Reduce traffic during deploy\n  global:\n    SCD_ON_DEMAND: true  # Defer SCD to reduce deploy time",
    "examDomain": "Review",
    "objectiveTags": [
      "troubleshooting",
      "root-cause-analysis",
      "production-debugging"
    ]
  },
  {
    "id": 136,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Hard",
    "question": "Multiple Magento 2 cron jobs are found stuck in 'running' status for over 24 hours. The cron_schedule table shows overlapping entries for indexer_reindex_all_invalid and catalog_product_alert. The system has 3 web nodes behind a load balancer, all configured to run cron. Investigating further, you find duplicate entries in the cron_schedule table with the same job_code and 'running' status from different server hostnames. What is the correct architectural solution?",
    "options": [
      {
        "id": "A",
        "text": "Add file-based lock checks at the beginning of each cron job to prevent duplicate execution"
      },
      {
        "id": "B",
        "text": "Designate a single node as the cron runner by configuring cron only on one node, ensure the cron group's use_separate_process is set to 1, and configure proper schedule_lifetime_per_group settings to auto-clean stale entries"
      },
      {
        "id": "C",
        "text": "Reduce the cron frequency from every minute to every 5 minutes to give jobs more time to complete before the next trigger"
      },
      {
        "id": "D",
        "text": "Increase MySQL's max_connections and innodb_lock_wait_timeout since the overlapping crons are likely causing connection pool exhaustion"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because the root cause is a multi-node cron race condition: when all 3 web nodes run the cron scheduler, each node checks cron_schedule for pending jobs and attempts to claim them by updating the status to 'running'. Due to timing, multiple nodes can claim the same job before the status update propagates, leading to duplicate execution. The architectural solution is: (1) designate exactly one node as the cron runner  on Cloud this is done via the .magento.app.yaml crons section on a specific instance; (2) enable use_separate_process = 1 in cron group configuration so each job runs in its own PHP process, preventing one stuck job from blocking the entire cron scheduler; (3) configure schedule_lifetime (default 15 minutes) appropriately so that stale 'running' entries from crashed processes are automatically cleaned and rescheduled. A is wrong because file-based locks don't work in a multi-node environment  each node has its own filesystem, so a lock file on node 1 is invisible to nodes 2 and 3. B addresses this with the database-level scheduling that Magento already provides, but only when a single node is responsible. C is wrong because reducing frequency doesn't prevent overlap  if a job takes 10 minutes, even 5-minute intervals will overlap, and it means legitimate short jobs run less frequently than needed. D is wrong because while connection exhaustion may be a secondary symptom, the root cause is duplicate execution, not insufficient database resources.",
    "codeExample": "-- Diagnostic: Find stuck and duplicate cron jobs\nSELECT job_code, status, COUNT(*) as instances,\n       MIN(executed_at) as earliest, MAX(executed_at) as latest\nFROM cron_schedule\nWHERE status = 'running'\nGROUP BY job_code, status\nHAVING COUNT(*) > 1\nORDER BY instances DESC;\n\n-- Clean stale running entries (manual intervention)\nUPDATE cron_schedule\nSET status = 'error', messages = 'Manually cleared: stale running entry'\nWHERE status = 'running'\n  AND executed_at < DATE_SUB(NOW(), INTERVAL 4 HOUR);\n\n-- Verify cron group configuration\n-- app/etc/env.php\n'cron' => [\n    'default' => [\n        'schedule_generate_every' => 1,\n        'schedule_ahead_for' => 20,\n        'schedule_lifetime' => 15,\n        'history_cleanup_every' => 10,\n        'history_success_lifetime' => 60,\n        'history_failure_lifetime' => 600,\n        'use_separate_process' => 1\n    ]\n]",
    "examDomain": "Review",
    "objectiveTags": [
      "troubleshooting",
      "root-cause-analysis",
      "production-debugging"
    ]
  },
  {
    "id": 137,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Medium",
    "question": "A Magento 2 store with Varnish full page cache reports that logged-in customers occasionally see another customer's name and mini-cart data on category pages. The issue is intermittent and affects approximately 2% of page views. Cache hit rates are normal. What is the most likely root cause?",
    "options": [
      {
        "id": "A",
        "text": "Varnish is caching pages with Set-Cookie headers, causing session ID leakage between customers"
      },
      {
        "id": "B",
        "text": "A custom module or theme block is not properly configured as private content  it renders customer-specific data in the server response instead of loading it via the customer-data.js AJAX mechanism"
      },
      {
        "id": "C",
        "text": "The Varnish VCL is missing the X-Magento-Vary header handling, causing all logged-in users to share the same cache entry"
      },
      {
        "id": "D",
        "text": "Redis session storage is experiencing race conditions, causing session data to be swapped between concurrent requests"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because Magento 2's full page cache architecture requires that all customer-specific (private) content be loaded client-side via the sections/customer-data.js mechanism. When a block renders private data (customer name, cart contents, wishlist count) directly in the server-side HTML response, Varnish caches that rendered HTML and serves it to other users. The 2% occurrence rate correlates with cache miss frequency  when a logged-in customer triggers a cache miss, their private data gets embedded in the cached page, which is then served to subsequent visitors until TTL expiration. The fix is to ensure private content uses the section data source pattern: server returns placeholder HTML, JavaScript loads customer-specific data via GET /customer/section/load/. A is wrong because Varnish's default VCL for Magento already strips Set-Cookie on cacheable responses (via vcl_backend_response) and passes requests with cookies directly to the backend  session ID leakage through Set-Cookie would affect 100% of cached pages, not 2%. C is wrong because missing X-Magento-Vary handling would cause a different symptom  customers in different customer groups or currencies would see wrong pricing, not personal data leakage. X-Magento-Vary varies cache by customer segment, not by individual customer. D is wrong because Redis session race conditions would cause session corruption symptoms like random logouts or cart emptying, not one customer seeing another's cached page content.",
    "codeExample": "<?php\n// PROBLEM: Private data rendered server-side (gets cached by Varnish)\n// app/code/Vendor/Module/Block/CustomerGreeting.php\nclass CustomerGreeting extends \\Magento\\Framework\\View\\Element\\Template\n{\n    public function getCustomerName(): string\n    {\n        // This renders into cached HTML!\n        return $this->customerSession->getCustomer()->getName();\n    }\n}\n\n// SOLUTION: Use customer-data.js section for private content\n// Step 1: Create section source\n// app/code/Vendor/Module/CustomerData/Greeting.php\nclass Greeting implements SectionSourceInterface\n{\n    public function getSectionData(): array\n    {\n        return ['name' => $this->customerSession->getCustomer()->getName()];\n    }\n}\n\n// Step 2: Register in sections.xml\n// <action name=\"customer/account/login\">\n//     <section name=\"vendor-greeting\"/>\n// </action>\n\n// Step 3: Block renders placeholder, JS fills it\n// <span data-bind=\"text: customer().name\"><!-- filled client-side --></span>",
    "examDomain": "Review",
    "objectiveTags": [
      "troubleshooting",
      "root-cause-analysis",
      "production-debugging"
    ]
  },
  {
    "id": 138,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Hard",
    "question": "A Magento 2 store experiences periodic checkout failures during flash sales. The exception log shows: 'SQLSTATE[40001]: Serialization failure: 1213 Deadlock found when trying to get lock; try restarting transaction' occurring in the sales_order_grid table. The SHOW ENGINE INNODB STATUS output reveals a deadlock cycle between INSERT into sales_order and INSERT into sales_order_grid triggered by the async grid indexer. What is the correct architectural resolution?",
    "options": [
      {
        "id": "A",
        "text": "Switch sales_order_grid to MyISAM engine since it uses table-level locking which avoids deadlocks"
      },
      {
        "id": "B",
        "text": "Disable the async grid indexer for sales order grid by setting dev/grid/async_indexing to 0 during flash sales, and implement a custom observer that inserts into the grid table within the same transaction as the order save"
      },
      {
        "id": "C",
        "text": "Add a retry mechanism with exponential backoff in the order placement code to handle the deadlock transparently, and ensure the grid async indexer uses a separate database connection with lower isolation level"
      },
      {
        "id": "D",
        "text": "Increase InnoDB's innodb_deadlock_detect timeout and set innodb_lock_wait_timeout to 120 seconds to give transactions more time to resolve naturally"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct because the deadlock is an inherent InnoDB behavior when concurrent transactions acquire locks in different orders. During order placement, Transaction A inserts into sales_order (acquiring a gap lock on the primary key), while the async grid indexer's Transaction B reads from sales_order and inserts into sales_order_grid. With high concurrency during flash sales, the lock acquisition order creates cycles. The correct architectural resolution has two parts: (1) implement retry logic with exponential backoff  InnoDB deadlocks automatically roll back one transaction (the 'victim'), and retrying after a brief delay succeeds because the conflicting transaction has completed. This is the standard pattern for handling deadlocks in high-concurrency systems. (2) Ensure the async grid indexer uses a separate connection with READ COMMITTED isolation (vs the default REPEATABLE READ) to reduce gap lock scope, minimizing deadlock probability. A is wrong because MyISAM doesn't support transactions at all  switching a critical sales table to MyISAM would cause data integrity issues during crashes and eliminate foreign key constraints. Table-level locking also creates worse concurrency problems under high load. B is wrong because disabling async indexing and inserting synchronously within the same transaction actually increases the chance of deadlocks by making the order save transaction longer and touching more tables. It also adds latency to every checkout. D is wrong because innodb_deadlock_detect controls detection, not prevention  longer timeouts just mean transactions wait longer before the deadlock is detected. The deadlock still occurs, and the victim transaction is still rolled back. Extending wait time makes the problem worse by holding locks longer.",
    "codeExample": "<?php\n// Retry mechanism for deadlock-prone operations\nclass OrderPlacementService\n{\n    private const MAX_RETRIES = 3;\n    private const BASE_DELAY_MS = 50;\n\n    public function placeOrder(CartInterface $cart): OrderInterface\n    {\n        $attempt = 0;\n        while (true) {\n            try {\n                $attempt++;\n                return $this->orderManagement->place($cart);\n            } catch (\\Magento\\Framework\\DB\\Adapter\\DeadlockException $e) {\n                if ($attempt >= self::MAX_RETRIES) {\n                    throw $e;\n                }\n                // Exponential backoff: 50ms, 100ms, 200ms\n                usleep(self::BASE_DELAY_MS * (2 ** ($attempt - 1)) * 1000);\n                $this->logger->warning(\n                    'Deadlock on order placement, retry attempt ' . $attempt,\n                    ['cart_id' => $cart->getId()]\n                );\n            }\n        }\n    }\n}\n\n/* INNODB STATUS deadlock output pattern:\n*** (1) TRANSACTION: INSERT INTO sales_order ... \n*** (1) HOLDS THE LOCK(S): gap lock on PRIMARY\n*** (1) WAITING FOR: index record lock on sales_order_grid\n*** (2) TRANSACTION: INSERT INTO sales_order_grid ...\n*** (2) HOLDS THE LOCK(S): index record lock on sales_order_grid\n*** (2) WAITING FOR: gap lock on sales_order PRIMARY\n*/",
    "examDomain": "Review",
    "objectiveTags": [
      "troubleshooting",
      "root-cause-analysis",
      "production-debugging"
    ]
  },
  {
    "id": 139,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Hard",
    "question": "A Magento 2 store's ERP integration via REST API begins failing intermittently after a platform upgrade. The integration pushes 500 product updates per batch. Logs show a mix of HTTP 503, 504, and occasional 200 responses within the same batch. The ERP vendor reports that their retry logic (immediate retry on failure, up to 5 times) makes the situation worse during peak hours. The API response times have increased from 200ms to 2-8 seconds. Which combination of root cause analysis steps and fixes should an architect recommend?",
    "options": [
      {
        "id": "A",
        "text": "Increase API rate limits and web server timeouts to accommodate the higher response times, and ask the ERP vendor to increase their timeout settings"
      },
      {
        "id": "B",
        "text": "Profile the upgraded product save API endpoint to identify new plugin overhead, implement async bulk API processing using Magento's bulk API with message queue, and advise the ERP vendor to implement exponential backoff with jitter instead of immediate retries"
      },
      {
        "id": "C",
        "text": "Roll back the platform upgrade since the API performance regression indicates incompatible customizations"
      },
      {
        "id": "D",
        "text": "Split the 500-product batch into smaller batches of 50 and add a 1-second delay between each batch to reduce server load"
      },
      {
        "id": "E",
        "text": "Move the ERP integration to GraphQL mutations which are more performant than REST for bulk operations"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because it addresses all three dimensions of the problem: (1) The response time increase from 200ms to 2-8s after upgrade indicates new plugin or observer overhead on the product save path  profiling with Xdebug/Blackfire on the PUT /V1/products endpoint will reveal which new interceptors or observers were added by the upgrade, allowing targeted optimization. (2) The synchronous REST API processing 500 sequential product saves is architecturally fragile  Magento's async bulk API (POST /V1/bulk with message queue via RabbitMQ or MySQL) allows the server to accept the batch immediately and process items asynchronously, eliminating timeout issues entirely. (3) The ERP's immediate retry pattern causes a thundering herd effect  when 200 of 500 requests fail, the ERP immediately fires 200 retries while the remaining 300 original requests are still in flight, compounding server overload. Exponential backoff with jitter (randomized delay) spreads retry load over time, allowing the server to recover. A is wrong because increasing timeouts and rate limits treats symptoms while amplifying the root cause  longer timeouts mean more concurrent connections consume php-fpm workers, and higher rate limits allow more load on an already struggling system. C is wrong because rolling back an entire platform upgrade is extreme and doesn't solve the architectural fragility  the synchronous 500-product batch was always a ticking time bomb even before the upgrade. D is wrong because while smaller batches reduce per-request time, the fixed 1-second delay makes the total integration time 10+ seconds  10 batches = 100+ seconds minimum, and it doesn't address the underlying API performance regression or retry thundering herd. E is wrong because GraphQL mutations in Magento 2 ultimately invoke the same service layer and plugins as REST  the performance characteristics would be identical since the bottleneck is in the business logic layer, not the API framework.",
    "codeExample": "<?php\n// Diagnostic: Profile the product save path for new plugin overhead\n// bin/magento dev:profiler:enable\n// Then check: var/log/profiler.csv for method timings\n\n// Identify plugins added by upgrade:\n// bin/magento dev:di:info 'Magento\\Catalog\\Api\\ProductRepositoryInterface'\n// Output reveals all interceptors on the save path\n\n// SOLUTION: Use Magento's Async Bulk API\n// ERP sends single request instead of 500:\n// POST /rest/V1/bulk\n// Content-Type: application/json\n$bulkPayload = [\n    'entity' => [\n        // 500 products in one request\n        ['product' => ['sku' => 'SKU001', 'price' => 29.99]],\n        ['product' => ['sku' => 'SKU002', 'price' => 39.99]],\n        // ...\n    ]\n];\n// Response: 202 Accepted with bulk_uuid for status tracking\n// GET /rest/V1/bulk/{bulkUuid}/status\n\n// ERP Retry Configuration (advise vendor):\n// retry_delay = base_delay * (2 ^ attempt) + random(0, 1000ms)\n// Attempt 1: ~1s, Attempt 2: ~2s, Attempt 3: ~4s\n// Max retries: 3 (not 5 with immediate retry)",
    "examDomain": "Review",
    "objectiveTags": [
      "troubleshooting",
      "root-cause-analysis",
      "production-debugging"
    ]
  },
  {
    "id": 140,
    "category": "Integration Architecture",
    "difficulty": "Hard",
    "question": "An enterprise retailer needs to integrate Adobe Commerce with their on-premise ERP system for order and inventory synchronization. The ERP has limited API throughput (50 requests/minute) and orders must be reflected in the ERP within 15 minutes. During flash sales, the store processes 500+ orders per minute. Which integration architecture best addresses these constraints?",
    "options": [
      {
        "id": "A",
        "text": "Direct synchronous API calls from Commerce order placement observers to the ERP, with retry logic on failure"
      },
      {
        "id": "B",
        "text": "Asynchronous message queue with a middleware layer that batches orders and respects ERP rate limits via a token bucket algorithm"
      },
      {
        "id": "C",
        "text": "Scheduled cron job running every 5 minutes that exports all new orders as a flat file to the ERP's SFTP server"
      },
      {
        "id": "D",
        "text": "Real-time webhook from Commerce to ERP with an in-memory cache to deduplicate retries"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because an asynchronous message queue (RabbitMQ) decouples order placement from ERP processing, preventing checkout slowdowns during flash sales. The middleware layer acts as a buffer that accumulates orders and dispatches them in batches within the ERP's 50 req/min limit, while the token bucket algorithm ensures smooth rate limiting without bursts. This architecture guarantees orders reach the ERP well within the 15-minute SLA even during peak load. A is wrong because synchronous calls would block checkout, and at 500+ orders/minute against a 50 req/min ERP limit, the queue would grow unboundedly, causing timeouts and order failures. C is wrong because a 5-minute cron with flat file export introduces unnecessary latency, lacks real-time error handling, and flat file parsing is fragile compared to structured API calls  plus it doesn't solve the rate limit problem if the batch exceeds 50 orders. D is wrong because webhooks are still synchronous from Commerce's perspective (waiting for acknowledgment), and an in-memory cache provides no durability  if the middleware process restarts, pending orders are lost.",
    "codeExample": "// publisher.xml - Define async topic for ERP order sync\n<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n        xsi:noNamespaceSchemaLocation=\"urn:magento:framework:Communication/etc/communication.xsd\">\n    <topic name=\"erp.order.sync\" request=\"string\">\n        <handler name=\"erpOrderHandler\"\n                 type=\"Vendor\\ErpIntegration\\Model\\Queue\\OrderConsumer\"\n                 method=\"process\"/>\n    </topic>\n</config>\n\n// OrderConsumer.php - Batch-aware consumer with rate limiting\nclass OrderConsumer\n{\n    public function __construct(\n        private ErpClient $erpClient,\n        private RateLimiter $rateLimiter,\n        private LoggerInterface $logger\n    ) {}\n\n    public function process(string $orderJson): void\n    {\n        $this->rateLimiter->waitForToken(); // blocks until rate limit allows\n        $orderData = json_decode($orderJson, true);\n        $this->erpClient->pushOrder($orderData);\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "integration-patterns",
      "middleware",
      "idempotency"
    ]
  },
  {
    "id": 141,
    "category": "Integration Architecture",
    "difficulty": "Medium",
    "question": "A B2B merchant integrates Adobe Commerce with Salesforce CRM for bidirectional customer data synchronization. Sales reps update company credit limits in Salesforce, while customers update their addresses in Commerce. Both systems have experienced data conflicts where stale updates overwrite newer data. Which strategy best prevents data conflicts while maintaining near-real-time sync?",
    "options": [
      {
        "id": "A",
        "text": "Use timestamp-based last-write-wins resolution, where each system includes an updated_at field and the most recent timestamp always takes precedence"
      },
      {
        "id": "B",
        "text": "Designate a system of record per field  Salesforce owns credit-related fields, Commerce owns address fields  and reject inbound updates to fields owned by the other system"
      },
      {
        "id": "C",
        "text": "Implement a full nightly batch sync from Salesforce to Commerce, treating Salesforce as the single source of truth for all customer data"
      },
      {
        "id": "D",
        "text": "Store all customer data exclusively in Commerce and use Salesforce only as a read-only mirror via one-way push"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because field-level ownership eliminates conflicts by design. Since credit limits are a sales/finance concern managed in Salesforce and addresses are customer-facing data managed in Commerce, each system is authoritative for its domain. Inbound sync only updates fields the receiving system does not own, making conflicts impossible. This is the standard pattern for bidirectional integration in enterprise commerce. A is wrong because last-write-wins causes silent data loss  if a sales rep updates a credit limit in Salesforce and then a customer updates their address in Commerce seconds later, the Commerce sync could overwrite the credit limit with stale data if the systems sync different field sets at different intervals. Clock skew between systems further compounds this risk. C is wrong because a nightly batch sync does not meet the near-real-time requirement and making Salesforce the sole source of truth ignores that customers manage their own addresses in Commerce, creating a poor user experience where address changes take 24 hours to reflect. D is wrong because it defeats the purpose of CRM integration  sales reps need to manage customer relationships, credit terms, and segmentation in Salesforce, and making it read-only removes their ability to enrich customer data.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "integration-patterns",
      "middleware",
      "idempotency"
    ]
  },
  {
    "id": 142,
    "category": "Integration Architecture",
    "difficulty": "Hard",
    "question": "A retailer with 200,000 SKUs integrates Adobe Commerce with an external PIM (Product Information Management) system. Full catalog imports take 6+ hours and cause performance degradation. Products change frequently  approximately 2,000 SKUs are updated daily. Which delta sync architecture minimizes import time while ensuring data consistency?",
    "options": [
      {
        "id": "A",
        "text": "Query the PIM API for all products nightly, compare each product hash against Commerce, and import only changed products"
      },
      {
        "id": "B",
        "text": "Have the PIM publish change events to a message queue with product IDs; Commerce consumes events and fetches only changed product data via API"
      },
      {
        "id": "C",
        "text": "Use Commerce's built-in scheduled import with a CSV file containing all 200,000 products, relying on Magento's internal change detection"
      },
      {
        "id": "D",
        "text": "Implement a webhook from PIM that pushes complete product data to Commerce on every save, processing updates synchronously"
      },
      {
        "id": "E",
        "text": "Maintain a changelog table in a shared database between PIM and Commerce, polling it every minute for changed product IDs"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because event-driven delta sync is the optimal pattern for this scenario. The PIM publishes lightweight change events (just product IDs and change type) to a message queue when products are modified. Commerce consumers pick up these events and fetch only the 2,000 changed products daily via targeted API calls, reducing import time from 6+ hours to minutes. The message queue provides durability (no lost changes), ordering, and natural backpressure handling. A is wrong because querying all 200,000 products to compute hashes still requires fetching the entire catalog from the PIM API, which is nearly as expensive as a full import  the comparison saves import time but not API call time, and it still takes hours to iterate the full catalog. C is wrong because importing a CSV with all 200,000 products means Commerce must parse and evaluate every row even if unchanged, which still causes the same 6+ hour performance degradation. Magento's change detection compares at the row level but still reads every row. D is wrong because synchronous webhooks on every product save would overwhelm Commerce during bulk PIM updates (e.g., a category-wide price change affecting thousands of products), and synchronous processing creates tight coupling where PIM save operations fail if Commerce is unavailable. E is wrong because a shared database creates tight infrastructure coupling between PIM and Commerce, violates microservice boundaries, requires both systems to share credentials to the same database, and polling every minute adds unnecessary latency compared to event-driven push.",
    "codeExample": "// queue_consumer.xml\n<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <consumer name=\"pim.product.sync\"\n              queue=\"pim.product.changes\"\n              handler=\"Vendor\\PimSync\\Model\\Consumer\\ProductChangeHandler::process\"\n              maxMessages=\"100\"\n              connection=\"amqp\"/>\n</config>\n\n// ProductChangeHandler.php\nclass ProductChangeHandler\n{\n    public function __construct(\n        private PimApiClient $pimClient,\n        private ProductRepositoryInterface $productRepository,\n        private ProductInterfaceFactory $productFactory\n    ) {}\n\n    public function process(string $message): void\n    {\n        $event = json_decode($message, true);\n        $pimProduct = $this->pimClient->getProduct($event['sku']);\n\n        try {\n            $product = $this->productRepository->get($event['sku']);\n        } catch (NoSuchEntityException) {\n            $product = $this->productFactory->create();\n            $product->setSku($event['sku']);\n        }\n\n        $product->setName($pimProduct['name']);\n        $product->setPrice($pimProduct['price']);\n        // ... map remaining attributes\n        $this->productRepository->save($product);\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "integration-patterns",
      "middleware",
      "idempotency"
    ]
  },
  {
    "id": 143,
    "category": "Integration Architecture",
    "difficulty": "Hard",
    "question": "An Adobe Commerce merchant is implementing a payment gateway integration for a multi-country store. The solution must support PCI DSS SAQ A-EP compliance, handle 3D Secure 2.0 authentication flows, and allow customers to save payment methods for future purchases. Which tokenization and integration architecture satisfies all requirements?",
    "options": [
      {
        "id": "A",
        "text": "Collect card data in Commerce-hosted form fields, encrypt client-side with the gateway's public key, send encrypted payload to Commerce backend which forwards to the gateway for tokenization"
      },
      {
        "id": "B",
        "text": "Use the gateway's hosted payment fields (iframes) embedded in the checkout page; the gateway returns a single-use nonce to Commerce, which exchanges it server-side for a vault token"
      },
      {
        "id": "C",
        "text": "Redirect customers entirely to the payment gateway's hosted payment page; upon completion, the gateway redirects back with a transaction ID"
      },
      {
        "id": "D",
        "text": "Collect card data in Commerce form fields, transmit to Commerce server over TLS, then call the gateway API server-to-server to create a token for vault storage"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because gateway-hosted iframes (hosted fields) keep card data entirely within the gateway's PCI-certified environment  card numbers never touch Commerce's servers or JavaScript, satisfying SAQ A-EP requirements. The single-use nonce returned to Commerce is not sensitive card data, so it can safely pass through Commerce's backend. Server-side nonce-to-vault-token exchange enables saved payment methods without Commerce ever handling raw card data. The iframe approach also supports 3D Secure 2.0 because the gateway can trigger the authentication challenge within its iframe context. A is wrong because even though the data is encrypted client-side, Commerce's JavaScript still handles raw card data before encryption, which expands PCI scope to SAQ D (full assessment) rather than SAQ A-EP. The merchant's frontend code touches cardholder data, making the merchant responsible for securing that code. C is wrong because a full redirect to a hosted payment page satisfies PCI SAQ A (simplest), but it breaks the checkout UX  customers leave the merchant site, which increases cart abandonment by 20-30%. It also makes saving payment methods difficult because the merchant never receives a token in the standard redirect flow. D is wrong because collecting card data in Commerce form fields and transmitting to the Commerce server means cardholder data traverses the merchant's infrastructure, requiring full PCI DSS SAQ D compliance  the most burdensome assessment level. This is the exact scenario tokenization is designed to avoid.",
    "codeExample": "// Gateway hosted fields integration in checkout\n// view/frontend/web/js/view/payment/method-renderer/gateway-method.js\ndefine(['Magento_Checkout/js/view/payment/default'], function (Component) {\n    return Component.extend({\n        defaults: {\n            template: 'Vendor_Gateway/payment/form'\n        },\n\n        initHostedFields: function () {\n            // Gateway SDK renders secure iframes for card fields\n            this.hostedFields = GatewaySDK.create('hosted-fields', {\n                fields: {\n                    number: { selector: '#card-number' },\n                    expirationDate: { selector: '#expiry' },\n                    cvv: { selector: '#cvv' }\n                },\n                threeDSecure: { enabled: true, version: 2 }\n            });\n        },\n\n        placeOrder: function () {\n            // Tokenize returns nonce - no card data touches our JS\n            this.hostedFields.tokenize().then(function (result) {\n                this.paymentNonce = result.nonce;\n                this._super(); // sends nonce to Commerce backend\n            }.bind(this));\n        }\n    });\n});",
    "examDomain": "Design",
    "objectiveTags": [
      "integration-patterns",
      "middleware",
      "idempotency"
    ]
  },
  {
    "id": 144,
    "category": "Integration Architecture",
    "difficulty": "Medium",
    "question": "A merchant ships from 3 warehouses using 4 different carriers (FedEx, UPS, USPS, DHL). They need real-time shipping rates at checkout and automated label generation upon shipment. The carrier APIs have varying response times (200ms to 2 seconds). Which architecture ensures fast checkout while supporting multi-carrier label generation?",
    "options": [
      {
        "id": "A",
        "text": "Call all carrier APIs sequentially during checkout rate calculation, cache results for 30 minutes, and use the same carrier API for label generation at shipment time"
      },
      {
        "id": "B",
        "text": "Call all carrier APIs in parallel during checkout with a 3-second aggregate timeout, return available rates as they resolve, and use a queue-based async process for label generation"
      },
      {
        "id": "C",
        "text": "Pre-calculate all possible rates nightly via cron for every ZIP code combination and store them in a lookup table; generate labels synchronously when admin creates a shipment"
      },
      {
        "id": "D",
        "text": "Use a single shipping aggregator API that proxies all carrier rate requests and label generation through one unified endpoint"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because parallel API calls with an aggregate timeout ensure the checkout page loads within an acceptable window (3 seconds max). If a slow carrier (e.g., DHL at 2 seconds) hasn't responded, the checkout still displays rates from faster carriers. For label generation, async queue processing is appropriate because labels don't need to be generated instantly at order placement  they're created when warehouse staff process shipments, and queue-based processing handles carrier API failures gracefully with retries. A is wrong because sequential calls to 4 carriers across 3 warehouses means up to 12 sequential API calls. At worst case (2 seconds each), this is a 24-second wait at checkout, which is unacceptable  customers will abandon the cart. Caching helps on subsequent requests but doesn't solve the first-hit problem. C is wrong because pre-calculating rates for every ZIP code combination is computationally infeasible. With ~43,000 US ZIP codes, 4 carriers, 3 warehouses, and multiple service levels, you'd need billions of rate calculations nightly. Rates also change based on package dimensions, weight, and carrier promotions, making cached rates inaccurate. D is wrong because while shipping aggregators simplify integration, relying on a single third-party proxy adds a single point of failure. If the aggregator goes down, the merchant loses all shipping functionality. It also adds latency (an extra network hop) and the aggregator's rate markup increases shipping costs.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "integration-patterns",
      "middleware",
      "idempotency"
    ]
  },
  {
    "id": 145,
    "category": "Integration Architecture",
    "difficulty": "Hard",
    "question": "An Adobe Commerce implementation uses RabbitMQ to synchronize order data with an external OMS (Order Management System). During a recent peak sale, messages accumulated in the queue faster than the OMS consumer could process them, causing a 4-hour sync delay. The OMS API supports batching (up to 50 orders per call) but the current consumer processes one order per message. Which RabbitMQ topology and consumer changes best resolve the throughput bottleneck?",
    "options": [
      {
        "id": "A",
        "text": "Increase the prefetch count to 50, collect messages in the consumer until 50 accumulate or 10 seconds elapse, then send a single batch API call to the OMS"
      },
      {
        "id": "B",
        "text": "Create 50 parallel consumers on the same queue, each processing one message at a time, to achieve 50x throughput"
      },
      {
        "id": "C",
        "text": "Switch from RabbitMQ to a database table as the queue, using SELECT FOR UPDATE with SKIP LOCKED for concurrent consumption"
      },
      {
        "id": "D",
        "text": "Add a dead letter exchange with automatic retry, assuming the bottleneck is caused by transient OMS API failures"
      },
      {
        "id": "E",
        "text": "Increase the RabbitMQ queue's max-length to unlimited so messages never get dropped during peaks"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "A is correct because it directly addresses the root cause: the OMS API supports batching but the consumer sends one order per API call, wasting 98% of available throughput. Setting prefetch to 50 allows the consumer to pull 50 messages from the queue at once. The consumer collects them into a batch (with a 10-second timeout to avoid waiting indefinitely when volume is low) and sends one batch API call to the OMS. This reduces API calls by 50x while using the OMS's native batch endpoint, resolving the throughput gap. B is wrong because 50 parallel consumers each making individual API calls means 50 concurrent connections to the OMS, which likely exceeds the OMS's rate limits or connection pool. It also doesn't leverage the batch API  50 single-order calls are less efficient than 1 batch call of 50 orders. Additionally, 50 consumers increase infrastructure costs and complexity. C is wrong because replacing RabbitMQ with a database queue is a step backward in architecture. Database-based queues have higher latency, don't support native pub/sub patterns, and SELECT FOR UPDATE creates lock contention under high concurrency. The problem is consumer inefficiency, not the message broker. D is wrong because the problem is throughput, not failures. Dead letter exchanges handle poison messages and transient errors, but the messages aren't failing  they're processing too slowly. Adding DLX retry logic adds complexity without addressing the batch processing gap. E is wrong because increasing max-length prevents message drops but doesn't increase processing speed. If the consumer processes messages slower than they arrive, an unlimited queue just delays the inevitable  it doesn't solve the throughput problem, and unbounded queues eventually exhaust disk space.",
    "codeExample": "// BatchOrderConsumer.php\nclass BatchOrderConsumer\n{\n    private array $batch = [];\n    private float $batchStartTime = 0;\n    private const BATCH_SIZE = 50;\n    private const BATCH_TIMEOUT = 10; // seconds\n\n    public function __construct(\n        private OmsApiClient $omsClient,\n        private LoggerInterface $logger\n    ) {}\n\n    public function process(EnvelopeInterface $envelope): void\n    {\n        if (empty($this->batch)) {\n            $this->batchStartTime = microtime(true);\n        }\n\n        $this->batch[] = json_decode($envelope->getBody(), true);\n\n        $elapsed = microtime(true) - $this->batchStartTime;\n        if (count($this->batch) >= self::BATCH_SIZE || $elapsed >= self::BATCH_TIMEOUT) {\n            $this->flush();\n        }\n    }\n\n    private function flush(): void\n    {\n        if (empty($this->batch)) {\n            return;\n        }\n        $this->logger->info(sprintf('Flushing %d orders to OMS', count($this->batch)));\n        $this->omsClient->batchCreateOrders($this->batch);\n        $this->batch = [];\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "integration-patterns",
      "middleware",
      "idempotency"
    ]
  },
  {
    "id": 146,
    "category": "Integration Architecture",
    "difficulty": "Medium",
    "question": "An Adobe Commerce store integrates with 5 external services (ERP, PIM, CRM, shipping, payment). During a recent ERP outage, cascading failures caused the checkout and product pages to become unresponsive because synchronous ERP calls timed out after 30 seconds. Which API gateway pattern combination prevents cascading failures while maintaining service availability?",
    "options": [
      {
        "id": "A",
        "text": "Implement a circuit breaker that trips after 5 consecutive ERP failures, returning cached/fallback data for a cooldown period, combined with per-service timeout policies (2 seconds for checkout-critical calls)"
      },
      {
        "id": "B",
        "text": "Add retry with exponential backoff to all external service calls, starting at 1 second and doubling up to 60 seconds, ensuring eventual delivery"
      },
      {
        "id": "C",
        "text": "Set a global 5-second timeout for all external API calls and return HTTP 503 to the user if any service is unavailable"
      },
      {
        "id": "D",
        "text": "Deploy a load balancer in front of all external services to distribute traffic evenly and prevent any single service from being overwhelmed"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "A is correct because the circuit breaker pattern directly prevents cascading failures. After 5 consecutive ERP failures, the circuit 'opens' and immediately returns cached or fallback data without attempting the ERP call, eliminating the 30-second timeout wait. Per-service timeouts of 2 seconds for checkout-critical paths ensure that even before the circuit trips, individual request latency is bounded. During the cooldown period, the circuit periodically allows a single test request to check if the ERP has recovered (half-open state). This keeps checkout functional with degraded but acceptable data. B is wrong because retry with exponential backoff makes cascading failures worse, not better. If the ERP is down, retrying with increasing delays means each request now makes multiple calls to the failing service, amplifying load when the ERP comes back up (thundering herd). During an outage, retries just waste resources and increase latency  a checkout request could wait up to 1+2+4+8+16+32+60 = 123 seconds across retries. C is wrong because returning 503 to users is the opposite of graceful degradation. Customers see an error page and leave. The goal is to keep the store operational with fallback data (e.g., cached inventory levels) rather than failing entirely because one of five services is down. D is wrong because a load balancer distributes traffic across multiple instances of the same service, but there's only one ERP endpoint. A load balancer cannot route around a fully down service, and it doesn't address timeout or failure isolation concerns.",
    "codeExample": "// CircuitBreaker implementation for external service calls\nclass CircuitBreaker\n{\n    private const STATE_CLOSED = 'closed';\n    private const STATE_OPEN = 'open';\n    private const STATE_HALF_OPEN = 'half_open';\n\n    public function __construct(\n        private CacheInterface $cache,\n        private int $failureThreshold = 5,\n        private int $cooldownSeconds = 30\n    ) {}\n\n    public function call(string $service, callable $action, callable $fallback): mixed\n    {\n        $state = $this->getState($service);\n\n        if ($state === self::STATE_OPEN) {\n            if ($this->cooldownExpired($service)) {\n                $this->setState($service, self::STATE_HALF_OPEN);\n            } else {\n                return $fallback(); // Return cached/default data\n            }\n        }\n\n        try {\n            $result = $action();\n            $this->recordSuccess($service);\n            return $result;\n        } catch (\\Throwable $e) {\n            $this->recordFailure($service);\n            if ($this->getFailureCount($service) >= $this->failureThreshold) {\n                $this->setState($service, self::STATE_OPEN);\n            }\n            return $fallback();\n        }\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "integration-patterns",
      "middleware",
      "idempotency"
    ]
  },
  {
    "id": 147,
    "category": "Integration Architecture",
    "difficulty": "Hard",
    "question": "An Adobe Commerce merchant receives product data from multiple sources: a PIM system provides marketing content in XML, an ERP sends pricing/inventory as JSON via API, and a supplier portal delivers product specs in CSV files via SFTP. Each source uses different identifiers (PIM uses GTIN, ERP uses internal SKU, supplier uses manufacturer part number). Which ETL architecture ensures reliable data consolidation into Commerce's catalog?",
    "options": [
      {
        "id": "A",
        "text": "Build direct point-to-point integrations from each source system into Commerce's product save API, with inline field mapping and transformation in each integration module"
      },
      {
        "id": "B",
        "text": "Implement a canonical data model with a cross-reference mapping table that translates between source identifiers, run source-specific extractors into a staging area, transform to canonical format, then load into Commerce via Import/Export framework"
      },
      {
        "id": "C",
        "text": "Standardize all source systems to output the same JSON format with Commerce SKU as the identifier, eliminating the need for transformation"
      },
      {
        "id": "D",
        "text": "Import all data as-is into separate Commerce custom attributes per source, and resolve conflicts at display time using frontend logic"
      },
      {
        "id": "E",
        "text": "Use Commerce's built-in REST API to pull data from all three sources on a schedule, mapping fields directly in API request handlers"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because a canonical data model with cross-reference mapping is the standard enterprise integration pattern for multi-source data consolidation. The cross-reference table (GTIN  SKU  MPN) enables identifier resolution regardless of which source provides the data. Source-specific extractors handle format differences (XML, JSON, CSV) independently, normalizing each into the canonical format in a staging area where validation and conflict resolution occur before loading. Using Commerce's Import/Export framework for the load phase leverages Magento's built-in indexing and cache invalidation. A is wrong because point-to-point integrations create an n-to-n maintenance nightmare. With 3 sources, you have 3 separate transformation codebases, each tightly coupled to both the source format and Commerce's internal structure. Adding a 4th source means building another complete integration. There's also no staging area for cross-source conflict resolution  if PIM and ERP disagree on a product name, whichever runs last wins silently. C is wrong because standardizing output formats across external systems is rarely feasible. The merchant typically doesn't control the PIM vendor's export format, the ERP's API schema, or the supplier's CSV layout. Even if possible, it pushes transformation complexity to each source system rather than centralizing it, and requires coordinating changes across multiple vendors. D is wrong because storing raw multi-source data in separate custom attributes pushes integration complexity to the frontend, where it doesn't belong. Frontend logic shouldn't resolve data conflicts  this creates performance problems (multiple attribute lookups per product), inconsistent behavior across channels (API consumers see raw conflicting data), and makes search/filtering unreliable. E is wrong because Commerce pulling from sources inverts the recommended data flow. Commerce would need credentials and network access to the PIM, ERP, and SFTP server, creating tight coupling. REST API handlers are not designed for ETL transformation logic, and pull-based scheduling means delays in reflecting source changes.",
    "codeExample": "// CrossReferenceMapping.php - Identifier resolution\nclass CrossReferenceMapping\n{\n    public function __construct(private ResourceConnection $resource) {}\n\n    public function resolveToSku(string $sourceId, string $sourceType): string\n    {\n        $connection = $this->resource->getConnection();\n        $select = $connection->select()\n            ->from('integration_xref_mapping', ['commerce_sku'])\n            ->where('source_identifier = ?', $sourceId)\n            ->where('source_type = ?', $sourceType);\n\n        $sku = $connection->fetchOne($select);\n        if (!$sku) {\n            throw new IntegrationException(\n                \"No SKU mapping for {$sourceType} identifier: {$sourceId}\"\n            );\n        }\n        return $sku;\n    }\n}\n\n// CanonicalProductModel.php - Unified product representation\nclass CanonicalProductModel\n{\n    public string $sku;\n    public string $name;\n    public float $price;\n    public int $qty;\n    public array $attributes = [];\n    public string $sourceSystem;\n    public string $sourceTimestamp;\n\n    public static function fromPimXml(\\SimpleXMLElement $xml, CrossReferenceMapping $xref): self\n    {\n        $model = new self();\n        $model->sku = $xref->resolveToSku((string) $xml->gtin, 'gtin');\n        $model->name = (string) $xml->marketing_title;\n        $model->sourceSystem = 'pim';\n        return $model;\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "integration-patterns",
      "middleware",
      "idempotency"
    ]
  },
  {
    "id": 148,
    "category": "Checkout & Order Flow Architecture",
    "difficulty": "Hard",
    "question": "A merchant reports that a custom discount total collector is applying discounts AFTER tax calculation, resulting in incorrect tax amounts. The collector is configured with `<sort_order>350</sort_order>` in sales.xml. The default tax collector has sort_order 450. What is the root cause and correct architectural fix?",
    "options": [
      {
        "id": "A",
        "text": "Change the custom collector's sort_order to 500 so it runs after tax, then recalculate tax in a second pass"
      },
      {
        "id": "B",
        "text": "The sort_order 350 is correct (before tax at 450), but the collector must call $total->setBaseGrandTotal() to trigger tax recalculation"
      },
      {
        "id": "C",
        "text": "The collector's sort_order places it before tax, but it likely modifies the wrong address attribute  it should modify $total->setSubtotalWithDiscount() and $total->addTotalAmount() so the tax collector picks up the discounted subtotal"
      },
      {
        "id": "D",
        "text": "Override the tax collector to check for the custom discount and subtract it from the taxable amount before calculating tax"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct: Total collectors communicate through the $total object and address attributes. A discount collector at sort_order 350 runs before tax (450), which is the correct ordering. However, if the collector only modifies the grand total directly without properly setting subtotalWithDiscount and calling addTotalAmount/setTotalAmount on the 'discount' collector code, the tax collector won't see the reduced amount because it reads from subtotal-related fields, not grand total. The fix is ensuring the discount collector properly populates the total amounts that downstream collectors depend on.\n\nA is wrong: Moving the discount after tax would mean tax is calculated on the full price, then a discount applied  this is the opposite of the desired behavior and doesn't fix the data flow issue.\n\nB is wrong: setBaseGrandTotal() does not trigger any recalculation. Total collectors run sequentially in sort_order; there is no automatic recalculation mechanism. Each collector reads from and writes to specific total fields.\n\nD is wrong: Overriding the tax collector creates tight coupling between collectors. The architecture is designed so collectors communicate through the $total object, not by being aware of each other's logic.",
    "codeExample": "// Correct discount collector implementation in collect():\npublic function collect(\n    Quote $quote,\n    ShippingAssignmentInterface $shippingAssignment,\n    Total $total\n): self {\n    parent::collect($quote, $shippingAssignment, $total);\n    \n    $discount = $this->calculateDiscount($quote);\n    \n    // These lines ensure tax collector sees the discount\n    $total->setSubtotalWithDiscount(\n        $total->getSubtotal() - $discount\n    );\n    $total->addTotalAmount('custom_discount', -$discount);\n    $total->addBaseTotalAmount('custom_discount', -$discount);\n    \n    return $this;\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "checkout-architecture",
      "totals",
      "order-lifecycle"
    ]
  },
  {
    "id": 149,
    "category": "Checkout & Order Flow Architecture",
    "difficulty": "Medium",
    "question": "During the quote-to-order conversion process, at what point does Magento 2 decrement product inventory (stock), and what architectural pattern controls this?",
    "options": [
      {
        "id": "A",
        "text": "Inventory is decremented inside QuoteManagement::placeOrder() immediately after the order is saved to the database"
      },
      {
        "id": "B",
        "text": "Inventory is decremented by an observer on the checkout_submit_all_after event, after the order and payment have been processed successfully"
      },
      {
        "id": "C",
        "text": "The InventoryReservation system places a reservation via the inventory_sales_source_deduction plugin during order placement, and actual stock is adjusted asynchronously"
      },
      {
        "id": "D",
        "text": "Inventory is decremented inside the payment gateway's capture method to ensure stock is only reduced when payment is confirmed"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct: Starting with MSI (Multi-Source Inventory), Magento uses a reservation-based system. During order placement, a reservation (negative quantity entry) is created in inventory_reservation table. This immediately reflects in salable quantity calculations without modifying the actual source_item quantity. The actual source deduction happens later during shipment or through asynchronous processing. This prevents overselling while keeping the stock modification decoupled from the order placement transaction.\n\nA is wrong: QuoteManagement::placeOrder() orchestrates the conversion but does not directly handle inventory logic. The inventory system is decoupled from the order management layer.\n\nB is wrong: This was closer to the legacy (pre-MSI) CatalogInventory behavior where an observer on sales events would modify stock. The modern MSI architecture uses reservations rather than direct decrements on event observers.\n\nD is wrong: Inventory and payment are separate concerns. Tying stock to payment capture would mean inventory isn't reserved during authorization-only flows, leading to overselling. The reservation system handles this independently of payment state.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "checkout-architecture",
      "totals",
      "order-lifecycle"
    ]
  },
  {
    "id": 150,
    "category": "Checkout & Order Flow Architecture",
    "difficulty": "Hard",
    "question": "You are building a custom payment method that must support both authorize-only and authorize+capture flows, integrate with Magento Vault for stored cards, and work with the Payment Gateway Command pattern. Which components must you implement?",
    "options": [
      {
        "id": "A",
        "text": "A class extending \\Magento\\Payment\\Model\\Method\\AbstractMethod with authorize() and capture() methods, plus a VaultPaymentInterface implementation"
      },
      {
        "id": "B",
        "text": "A virtual type for PaymentGatewayFacade, command pool with 'authorize', 'capture', and 'vault_authorize' commands, request builders, response handlers, a vault payment config provider, and a token UI component provider"
      },
      {
        "id": "C",
        "text": "A PaymentMethodInterface implementation, separate REST API controllers for authorize and capture, and a plugin on VaultPaymentInterface to store tokens"
      },
      {
        "id": "D",
        "text": "A GatewayCommand class for each operation, a TransferFactory, and a Magento\\Vault\\Model\\Method override to enable token storage"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct: The modern Payment Gateway Command pattern uses a facade (Magento\\Payment\\Model\\Method\\Adapter configured as a virtual type) backed by a command pool. Each operation (authorize, capture, vault_authorize, vault_capture) is a separate command composed of BuilderInterface request builders, TransferFactoryInterface, ClientInterface (HTTP client), and HandlerInterface response handlers. Vault integration requires a PaymentTokenProviderInterface (config provider) and a TokenUiComponentProviderInterface for the frontend stored card display. This is all wired through di.xml virtual types.\n\nA is wrong: AbstractMethod is the legacy approach. Magento's Payment Gateway architecture explicitly replaces method-level authorize()/capture() with the command pool pattern. Vault integration also doesn't work through a standalone VaultPaymentInterface implementation  it's integrated into the command pool.\n\nC is wrong: Payment methods don't use REST controllers for processing. The command pool handles all operations internally. Vault token storage is handled by response handlers within the command pipeline, not by plugins.\n\nD is wrong: While GatewayCommand and TransferFactory are real components, you don't override Magento\\Vault\\Model\\Method. Vault integration requires configuring the vault provider and token components, not extending the vault method class. This answer also omits the critical request builders and response handlers.",
    "codeExample": "<!-- di.xml: Payment Gateway Command Pool (simplified) -->\n<virtualType name=\"CustomGatewayFacade\"\n    type=\"Magento\\Payment\\Model\\Method\\Adapter\">\n    <arguments>\n        <argument name=\"code\" xsi:type=\"const\">\n            Custom\\Payment\\Model\\Ui\\ConfigProvider::CODE\n        </argument>\n        <argument name=\"commandPool\" xsi:type=\"object\">\n            CustomGatewayCommandPool\n        </argument>\n        <argument name=\"valueHandlerPool\" xsi:type=\"object\">\n            CustomGatewayValueHandlerPool\n        </argument>\n    </arguments>\n</virtualType>\n\n<virtualType name=\"CustomGatewayCommandPool\"\n    type=\"Magento\\Payment\\Gateway\\Command\\CommandPool\">\n    <arguments>\n        <argument name=\"commands\" xsi:type=\"array\">\n            <item name=\"authorize\" xsi:type=\"object\">\n                CustomGatewayAuthorizeCommand\n            </item>\n            <item name=\"capture\" xsi:type=\"object\">\n                CustomGatewayCaptureCommand\n            </item>\n            <item name=\"vault_authorize\" xsi:type=\"object\">\n                CustomVaultAuthorizeCommand\n            </item>\n        </argument>\n    </arguments>\n</virtualType>",
    "examDomain": "Design",
    "objectiveTags": [
      "checkout-architecture",
      "totals",
      "order-lifecycle"
    ]
  },
  {
    "id": 151,
    "category": "Checkout & Order Flow Architecture",
    "difficulty": "Medium",
    "question": "A client wants to add a custom order status 'quality_check' that appears between 'processing' and 'complete'. Orders in this status should NOT be invoiceable or shippable. What is the correct architectural approach?",
    "options": [
      {
        "id": "A",
        "text": "Create a new order STATE 'quality_check' in the state machine and assign a status to it, then configure state transitions to prevent invoice and shipment actions"
      },
      {
        "id": "B",
        "text": "Create a new order STATUS 'quality_check' assigned to the existing 'processing' state, and use a plugin on OrderManagement to prevent invoice/shipment creation when the order has this status"
      },
      {
        "id": "C",
        "text": "Create a new order STATUS 'quality_check' assigned to a new custom STATE, and override the canInvoice()/canShip() methods on the Order model to return false for this state"
      },
      {
        "id": "D",
        "text": "Create a new order STATUS 'quality_check' assigned to the 'complete' state, since it comes after processing, and use an observer to block premature completion"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct: In Magento 2, ORDER STATE is a fixed set (new, pending_payment, processing, complete, closed, canceled, holded, payment_review) that controls business logic  what actions are allowed. ORDER STATUS is a label assigned to a state and is extensible. The correct approach is creating a custom status under the 'processing' state (since the order IS still being processed) and using plugins to restrict specific actions based on status. The state machine already handles the broad permissions; you refine behavior at the status level.\n\nA is wrong: Order states are hardcoded in the Magento state machine (Order::STATE_* constants). Adding a new state requires modifying core framework code, which breaks upgradeability and is architecturally incorrect. States are not designed to be extended.\n\nC is wrong: While creating a custom state is technically possible by adding constants, it's against the intended architecture. Additionally, overriding canInvoice()/canShip() on the Order model is a heavy modification. The state already controls these methods  processing state allows invoicing/shipping. The right layer for customization is status-level logic via plugins.\n\nD is wrong: Assigning the status to the 'complete' state is semantically incorrect  'complete' means the order is fully fulfilled (invoiced and shipped). An order in quality check hasn't been shipped yet. Putting it under 'complete' would break reporting and business logic.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "checkout-architecture",
      "totals",
      "order-lifecycle"
    ]
  },
  {
    "id": 152,
    "category": "Checkout & Order Flow Architecture",
    "difficulty": "Hard",
    "question": "An enterprise merchant requires multi-shipping checkout where a single quote can be split across 3+ shipping addresses. Each resulting order must have independent payment capture and fulfillment. What are the key architectural challenges an architect must address? (Select TWO)",
    "options": [
      {
        "id": "A",
        "text": "Each shipping address creates a separate ShippingAssignment on the quote, and the Multishipping model converts each assignment into a separate order  but total collectors must handle per-address calculation without double-counting quote-level discounts"
      },
      {
        "id": "B",
        "text": "The payment method must support multiple authorize calls against a single transaction, since Magento creates one payment authorization per split order during the placeOrder loop"
      },
      {
        "id": "C",
        "text": "All split orders share a single order entity with multiple shipment records, so the main challenge is preventing partial invoicing from affecting sibling shipments"
      },
      {
        "id": "D",
        "text": "Multi-shipping checkout bypasses the standard QuoteManagement::placeOrder() and uses Multishipping::createOrders(), which means any plugins or observers on the standard place-order flow will NOT execute for multi-shipping orders"
      },
      {
        "id": "E",
        "text": "GraphQL mutations fully support multi-shipping checkout, so the architect only needs to ensure the headless frontend sends the correct address assignments"
      }
    ],
    "correctAnswers": [
      "A",
      "D"
    ],
    "explanation": "A is correct: Multi-shipping works by creating multiple ShippingAssignment objects on the quote, each with its own items and shipping address. During order creation, each assignment becomes a separate order. A critical challenge is that quote-level totals (cart rules, coupons) must be proportionally distributed across addresses without double-application. The total collectors must be aware of multi-shipping context.\n\nD is correct: The Multishipping model has its own order creation flow (createOrders()) that does NOT go through the standard QuoteManagement::placeOrder(). This is a major architectural concern because any customizations implemented as plugins on QuoteManagement or observers on checkout_submit events may not fire during multi-shipping checkout. The architect must ensure custom logic is replicated or hooked into the multi-shipping flow separately.\n\nB is wrong: Magento does not create one authorization per split order against a single transaction. Each split order gets its own independent payment object and authorization. The payment method needs to support multiple independent authorizations (which most gateways do), not multiple authorizations against a single transaction.\n\nC is wrong: Multi-shipping creates completely separate order entities, not one order with multiple shipments. Each order has its own order ID, payment, invoices, and shipments. They are independent after creation.\n\nE is wrong: As of Magento 2.4.x, GraphQL does NOT fully support multi-shipping checkout. Multi-shipping is primarily a Luma/frontend feature. A headless implementation would require significant custom GraphQL mutation development.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "checkout-architecture",
      "totals",
      "order-lifecycle"
    ]
  },
  {
    "id": 153,
    "category": "Checkout & Order Flow Architecture",
    "difficulty": "Medium",
    "question": "A merchant wants to allow guest checkout but also prompt users to create an account after order placement using the same email. What is the architectural difference between guest and customer quotes that an architect must account for?",
    "options": [
      {
        "id": "A",
        "text": "Guest quotes store customer data (email, billing/shipping addresses) directly on the quote and order tables. Post-purchase account creation requires matching the order's email to the new customer entity via the convert-guest-to-customer flow, which reassigns existing orders."
      },
      {
        "id": "B",
        "text": "Guest and customer quotes are identical in structure  the only difference is the customer_id field. Post-purchase account creation simply populates this field on existing quote and order records."
      },
      {
        "id": "C",
        "text": "Guest quotes use a temporary customer entity (is_guest=1) in the customer_entity table. Post-purchase account creation flips this flag and sets a password."
      },
      {
        "id": "D",
        "text": "Guest quotes do not persist addresses to any address book. Post-purchase account creation requires re-entering all addresses since guest checkout data is only stored in session, not in the database."
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "A is correct: Guest quotes have customer_is_guest=1 and store all customer information (email, name, addresses) directly on the quote and sales_order tables rather than referencing a customer entity. When a guest creates an account post-purchase, Magento's Order Customer Management module handles reassigning orders: it creates a customer entity, copies addresses to the customer address book, and updates the customer_id on existing orders. The architect must ensure custom order-related logic handles both null and populated customer_id references.\n\nB is wrong: While customer_id is a key difference, it's not the only one. Guest quotes have no associated customer address book entries, no persistent cart capability, and different API access patterns (guest cart uses mask_id for REST API access instead of customer token). The data relationships are structurally different beyond just one field.\n\nC is wrong: Magento does NOT create temporary customer entities for guests. There is no is_guest flag on customer_entity. Guest checkout operates without any record in the customer tables  all data lives on the quote and order tables only.\n\nD is wrong: Guest checkout data IS persisted to the database  specifically on the quote, quote_address, sales_order, and sales_order_address tables. It's not session-only. The post-purchase account creation flow reads this data from the order tables to populate the new customer's address book.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "checkout-architecture",
      "totals",
      "order-lifecycle"
    ]
  },
  {
    "id": 154,
    "category": "Checkout & Order Flow Architecture",
    "difficulty": "Hard",
    "question": "A merchant needs to implement a custom workflow where an order cannot be invoiced until a third-party ERP confirms stock allocation via webhook. After ERP confirmation, the invoice should be created automatically and trigger shipment preparation. What is the correct architectural approach?",
    "options": [
      {
        "id": "A",
        "text": "Add a plugin on Sales\\Model\\Order::canInvoice() that checks a custom order attribute 'erp_stock_confirmed'. Create a webhook endpoint that sets this attribute and programmatically creates the invoice using InvoiceOrder service contract."
      },
      {
        "id": "B",
        "text": "Create a custom order status 'awaiting_erp' under the 'processing' state, use an observer on sales_order_invoice_save_before to prevent invoicing, and create a cron job that polls the ERP for confirmation."
      },
      {
        "id": "C",
        "text": "Override the Invoice controller's execute() method to add an ERP check before invoice creation, and create a separate controller for the ERP webhook callback."
      },
      {
        "id": "D",
        "text": "Use the payment gateway's 'pending' state to hold the order until ERP confirmation, then trigger a capture command which automatically generates the invoice."
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "A is correct: This approach uses the proper extension points. Pluginizing canInvoice() on the Order model controls whether the admin UI shows the invoice button AND prevents programmatic invoice creation until the condition is met. The webhook endpoint receives the ERP confirmation, sets the custom attribute (stored via extension_attributes or a custom column), and then uses the InvoiceOrder service contract (Magento\\Sales\\Api\\InvoiceOrderInterface) to create the invoice programmatically. Service contracts are the correct way to create invoices programmatically as they handle all events and validations.\n\nB is wrong: While custom status under 'processing' is a valid concept, using sales_order_invoice_save_before to prevent invoicing is too late  it fires during save, not during the canInvoice() check, so the admin would still see the Invoice button and get an error. Also, polling via cron is inefficient compared to a webhook. The ERP pushes updates; the system shouldn't poll.\n\nC is wrong: Overriding the admin controller only blocks admin-initiated invoicing, not API or programmatic invoice creation. It's the wrong layer  business logic should be in the model/service layer, not the controller. This approach also doesn't work for REST API invoice creation.\n\nD is wrong: Conflating payment state with order workflow creates tight coupling between unrelated concerns. The payment may be fully authorized and valid while the ERP check is pending. Using payment state for inventory workflow would break standard payment reporting and could cause issues with payment gateway timeout policies.",
    "codeExample": "// Webhook controller for ERP stock confirmation\nclass ErpConfirmation implements HttpPostActionInterface\n{\n    public function __construct(\n        private OrderRepositoryInterface $orderRepository,\n        private InvoiceOrderInterface $invoiceOrder,\n        private JsonFactory $jsonFactory\n    ) {}\n\n    public function execute(): ResultInterface\n    {\n        $orderId = $this->getRequest()->getParam('order_id');\n        $order = $this->orderRepository->get($orderId);\n        \n        // Set ERP confirmation flag\n        $order->setData('erp_stock_confirmed', true);\n        $this->orderRepository->save($order);\n        \n        // Create invoice via service contract\n        $this->invoiceOrder->execute(\n            $orderId,\n            capture: true\n        );\n        \n        return $this->jsonFactory->create()\n            ->setData(['success' => true]);\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "checkout-architecture",
      "totals",
      "order-lifecycle"
    ]
  },
  {
    "id": 155,
    "category": "Customization Architecture",
    "difficulty": "Hard",
    "question": "A third-party module uses a plugin (interceptor) on \\Magento\\Catalog\\Api\\ProductRepositoryInterface::save() to enrich product data before persistence. Your module needs to modify the same method to enforce a business rule that must execute BEFORE the third-party plugin runs. The third-party plugin is declared with sortOrder=\"20\". Which approach should the Architect recommend?",
    "options": [
      {
        "id": "A",
        "text": "Create a before plugin on ProductRepositoryInterface::save() with sortOrder=\"10\" in di.xml"
      },
      {
        "id": "B",
        "text": "Create a preference for ProductRepositoryInterface that calls parent::save() after applying the business rule"
      },
      {
        "id": "C",
        "text": "Create an observer on catalog_product_save_before event to apply the business rule"
      },
      {
        "id": "D",
        "text": "Create an around plugin on ProductRepositoryInterface::save() with sortOrder=\"10\" in di.xml"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "explanation": "When you need guaranteed execution order relative to another plugin AND the ability to control whether the original method executes, an around plugin with a lower sortOrder is the correct choice.\n\nWhy D is correct:\nAn around plugin with sortOrder=\"10\" executes before the third-party's sortOrder=\"20\" plugin. Around plugins wrap the entire call chain  the before portion runs first, then $proceed() triggers remaining plugins and the original method. This gives full control over execution flow and ordering.\n\nWhy A is incorrect:\nA before plugin with sortOrder=\"10\" would execute before the third-party's before plugins, but before plugins cannot prevent execution or wrap the call. If the business rule needs to halt execution or modify the return value, a before plugin is insufficient.\n\nWhy B is incorrect:\nA preference replaces the entire implementation of the interface, which breaks ALL plugins registered on that interface  including the third-party plugin. Preferences and plugins are mutually exclusive on the same method: plugins are applied to the preference class, not the original.\n\nWhy C is incorrect:\nThe catalog_product_save_before event fires inside the Model::save() method, which is a different layer than the Repository::save() service contract. Observers cannot prevent execution (they can throw exceptions, but that's an anti-pattern), and execution order relative to plugins on the repository layer is unpredictable.",
    "codeExample": "<!-- di.xml -->\n<type name=\"Magento\\Catalog\\Api\\ProductRepositoryInterface\">\n    <plugin name=\"vendor_business_rule\"\n            type=\"Vendor\\Module\\Plugin\\ProductRepositorySavePlugin\"\n            sortOrder=\"10\" />\n</type>\n\n// Plugin class\nclass ProductRepositorySavePlugin\n{\n    public function aroundSave(\n        ProductRepositoryInterface $subject,\n        callable $proceed,\n        ProductInterface $product,\n        $saveOptions = false\n    ): ProductInterface {\n        // Business rule enforced BEFORE third-party plugin (sortOrder 20)\n        if (!$this->businessRuleValidator->validate($product)) {\n            throw new CouldNotSaveException(__('Business rule violated.'));\n        }\n        return $proceed($product, $saveOptions);\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "customization-strategy",
      "upgrade-safe-customization"
    ]
  },
  {
    "id": 156,
    "category": "Customization Architecture",
    "difficulty": "Medium",
    "question": "A merchant needs to store a \"warehouse_location\" field on orders that comes from an external WMS (Warehouse Management System) during order placement. This field must be available via REST/GraphQL APIs and should not require database schema changes to the core sales_order table. Which approach should the Architect recommend?",
    "options": [
      {
        "id": "A",
        "text": "Add a custom attribute to the order entity using an InstallData script and EAV setup"
      },
      {
        "id": "B",
        "text": "Define an extension attribute on OrderInterface with a custom table and a plugin to load/save it"
      },
      {
        "id": "C",
        "text": "Add the field directly to the sales_order table via db_schema.xml and create a preference for OrderRepository"
      },
      {
        "id": "D",
        "text": "Use a custom attribute with attribute_code registration via sales_setup and add it to the fieldset.xml"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Extension attributes are the architecturally correct way to add custom data to service contracts without modifying core tables or breaking backward compatibility.\n\nWhy B is correct:\nExtension attributes are defined in extension_attributes.xml, backed by a custom table, and loaded/saved via plugins on the repository. They automatically appear in REST/GraphQL APIs through the generated ExtensionInterface. This approach keeps the core sales_order table untouched, is upgrade-safe, and follows Magento's service contract architecture.\n\nWhy A is incorrect:\nThe Order entity in Magento 2 is a flat entity, not an EAV entity. Unlike products and customers, orders do not support EAV attributes. Attempting to use EAV setup on the order entity will fail.\n\nWhy C is incorrect:\nAdding columns directly to sales_order via db_schema.xml modifies the core table schema, which violates the requirement. Creating a preference for OrderRepository replaces the entire repository implementation, breaking other modules' plugins and making upgrades fragile.\n\nWhy D is incorrect:\nWhile sales_setup custom attributes exist for order fields, they add columns directly to sales_order (which violates the no-core-schema-change requirement). fieldset.xml controls data copying between objects (e.g., quote to order) but does not provide API exposure on its own.",
    "codeExample": "<!-- extension_attributes.xml -->\n<config>\n    <extension_attributes for=\"Magento\\Sales\\Api\\Data\\OrderInterface\">\n        <attribute code=\"warehouse_location\" type=\"string\" />\n    </extension_attributes>\n</config>\n\n<!-- Plugin to load the extension attribute -->\npublic function afterGet(\n    OrderRepositoryInterface $subject,\n    OrderInterface $order\n): OrderInterface {\n    $warehouseLocation = $this->resource->getWarehouseLocation($order->getEntityId());\n    $extensionAttributes = $order->getExtensionAttributes();\n    $extensionAttributes->setWarehouseLocation($warehouseLocation);\n    $order->setExtensionAttributes($extensionAttributes);\n    return $order;\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "customization-strategy",
      "upgrade-safe-customization"
    ]
  },
  {
    "id": 157,
    "category": "Customization Architecture",
    "difficulty": "Hard",
    "question": "An Architect is customizing a checkout page layout. The requirement is to move the shipping address form ABOVE the shipping methods block and inject a custom promotional banner between them. The existing layout has both blocks inside a \"checkout.steps.shipping\" container. Which layout XML strategy is correct?",
    "options": [
      {
        "id": "A",
        "text": "Use <move> to reorder the shipping-address block before shipping-methods, then use <referenceContainer> to insert the banner block with before=\"shipping-methods\""
      },
      {
        "id": "B",
        "text": "Use <referenceBlock> with remove=\"true\" on both blocks, then re-declare them in the desired order inside a new container"
      },
      {
        "id": "C",
        "text": "Create a preference for the Shipping block class and override the template to include the banner inline"
      },
      {
        "id": "D",
        "text": "Use <referenceBlock> on shipping-address with before=\"-\" and add the banner block using <referenceContainer> with after=\"shipping-address\""
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "Layout XML provides the <move> instruction specifically for reordering blocks within or across containers, and <referenceContainer> with positional attributes for precise block placement.\n\nWhy A is correct:\nThe <move> element repositions an existing block to a new location or changes its order within the same container without removing and re-declaring it. Using <referenceContainer name=\"checkout.steps.shipping\"> with a new block declaration and before=\"shipping-methods\" places the banner exactly between the two blocks. This is the cleanest, most maintainable approach.\n\nWhy B is incorrect:\nUsing remove=\"true\" (or display=\"false\") destroys blocks entirely  they lose all child blocks, arguments, and configurations. Re-declaring them means manually reproducing all nested structure, which is extremely fragile and breaks when other modules add children to those blocks.\n\nWhy C is incorrect:\nCreating a preference for the block class just to change element order violates separation of concerns. Layout structure belongs in layout XML, not in PHP class overrides. This also makes the change invisible to other layout customizations.\n\nWhy D is incorrect:\nThe before=\"-\" attribute means \"place before all other siblings,\" which would reorder the shipping-address block correctly. However, using after=\"shipping-address\" on the banner only works if both elements are direct children of the same container AND the rendering respects these attributes. The combination works but <move> (option A) is the canonical, documented approach for reordering existing blocks and is more explicit about intent.",
    "codeExample": "<!-- checkout_index_index.xml (theme or module layout) -->\n<page xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n      xsi:noNamespaceSchemaLocation=\"urn:magento:framework:View/Layout/etc/page_configuration.xsd\">\n    <body>\n        <!-- Step 1: Move shipping-address before shipping-methods -->\n        <move element=\"checkout.steps.shipping.address\"\n              destination=\"checkout.steps.shipping\"\n              before=\"checkout.steps.shipping.methods\" />\n\n        <!-- Step 2: Insert banner between them -->\n        <referenceContainer name=\"checkout.steps.shipping\">\n            <block class=\"Vendor\\Module\\Block\\PromoBanner\"\n                   name=\"checkout.shipping.promo.banner\"\n                   template=\"Vendor_Module::promo-banner.phtml\"\n                   after=\"checkout.steps.shipping.address\"\n                   before=\"checkout.steps.shipping.methods\" />\n        </referenceContainer>\n    </body>\n</page>",
    "examDomain": "Design",
    "objectiveTags": [
      "customization-strategy",
      "upgrade-safe-customization"
    ]
  },
  {
    "id": 158,
    "category": "Customization Architecture",
    "difficulty": "Hard",
    "question": "A project requires customizing the minicart's item renderer to add a \"delivery estimate\" field. The minicart uses a Knockout.js UI component defined in checkout_cart_sidebar_item_renderers.xml. The Architect must ensure the customization survives upgrades and doesn't conflict with other modules modifying the same renderer. Which two approaches together form the best solution?",
    "options": [
      {
        "id": "A",
        "text": "Create a RequireJS mixin for the minicart item renderer JS component to extend its data model with the delivery estimate"
      },
      {
        "id": "B",
        "text": "Override the entire minicart item renderer .html Knockout template in the custom theme"
      },
      {
        "id": "C",
        "text": "Use layout XML to add a jsLayout argument that extends the item renderer's component configuration with the new field"
      },
      {
        "id": "D",
        "text": "Create a full JS component override via requirejs-config.js map to replace the original renderer"
      },
      {
        "id": "E",
        "text": "Use a plugin on the cart totals data provider to inject delivery estimate data into the customer section data"
      }
    ],
    "correctAnswers": [
      "A",
      "E"
    ],
    "explanation": "Adding a field to a Knockout UI component requires both a data source (backend) and a UI extension (frontend)  a mixin for the JS component and a plugin for the data provider.\n\nWhy A is correct:\nRequireJS mixins extend existing JS components without replacing them. Multiple modules can define mixins on the same component, and they compose cleanly. The mixin can add the delivery estimate to the component's observable data model and template binding, making it available for rendering.\n\nWhy E is correct:\nThe minicart data comes from customer section data (customer-data JS module) loaded via the /customer/section/load endpoint. A plugin on the SectionPool or the specific cart data provider allows injecting the delivery estimate into the JSON payload that feeds the Knockout component. Without the backend data source, the frontend mixin has nothing to display.\n\nWhy B is incorrect:\nOverriding the entire Knockout template in a theme works but is fragile  any core update to the template requires manual re-merging. It also conflicts with other modules that modify the same template. Template overrides should be the last resort for UI components.\n\nWhy C is incorrect:\nLayout XML jsLayout arguments can configure component options, but they cannot inject new data fields into the component's data model. The delivery estimate requires runtime data from the backend, which layout XML cannot provide.\n\nWhy D is incorrect:\nFull component replacement via requirejs-config.js map overwrites the entire component, preventing other modules' mixins from applying. This is the most conflict-prone approach and defeats the purpose of Magento's mixin system.",
    "codeExample": "// requirejs-config.js (mixin registration)\nvar config = {\n    config: {\n        mixins: {\n            'Magento_Checkout/js/view/minicart': {\n                'Vendor_Module/js/view/minicart-mixin': true\n            }\n        }\n    }\n};\n\n// minicart-mixin.js\ndefine(['mage/utils/wrapper'], function (wrapper) {\n    'use strict';\n    return function (Component) {\n        return Component.extend({\n            getDeliveryEstimate: function (itemId) {\n                var itemData = this.getItemData(itemId);\n                return itemData.delivery_estimate || '';\n            }\n        });\n    };\n});\n\n// Plugin: inject data into cart section\npublic function afterGetSectionData(\n    \\Magento\\Checkout\\CustomerData\\Cart $subject,\n    array $result\n): array {\n    foreach ($result['items'] as &$item) {\n        $item['delivery_estimate'] = $this->estimator->getEstimate($item['product_id']);\n    }\n    return $result;\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "customization-strategy",
      "upgrade-safe-customization"
    ]
  },
  {
    "id": 159,
    "category": "Customization Architecture",
    "difficulty": "Medium",
    "question": "A module exposes a service contract \\Vendor\\Shipping\\Api\\CarrierRateRepositoryInterface::getList(). A new business requirement needs an additional \"estimated_delivery_date\" field in the response DTO without breaking existing API consumers. Which approach preserves backward compatibility?",
    "options": [
      {
        "id": "A",
        "text": "Add the new getter/setter to the existing Data Interface and update the implementation class"
      },
      {
        "id": "B",
        "text": "Define an extension attribute on the Data Interface via extension_attributes.xml and populate it with a plugin"
      },
      {
        "id": "C",
        "text": "Create a new version of the API endpoint (V2) with the additional field in the DTO"
      },
      {
        "id": "D",
        "text": "Add the field as a custom attribute using the CustomAttributesDataInterface"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "Extension attributes are Magento's mechanism for extending service contract DTOs without breaking backward compatibility.\n\nWhy B is correct:\nExtension attributes are defined in extension_attributes.xml and generate an ExtensionInterface with the new getter/setter. Existing API consumers that don't know about the new field simply ignore it  their deserialization continues to work. The field is populated via a plugin on the repository, keeping the original interface untouched. This is the canonical Magento approach for extending APIs.\n\nWhy A is incorrect:\nAdding methods to an existing Data Interface is a backward-incompatible change. Any third-party code implementing that interface will break because it doesn't have the new methods. In semantic versioning, this constitutes a breaking change requiring a major version bump.\n\nWhy C is incorrect:\nAPI versioning is overkill for adding a single optional field. Magento's extension attributes system exists precisely to avoid version proliferation. V2 endpoints also require maintaining two codepaths, increasing complexity.\n\nWhy D is incorrect:\nCustomAttributesDataInterface is designed for EAV-based entities (products, customers) where attributes are dynamic. For service contract DTOs that represent non-EAV data, custom attributes add unnecessary complexity and lack type safety. Extension attributes provide typed accessors and are the correct pattern for service contracts.",
    "codeExample": "<!-- extension_attributes.xml -->\n<config>\n    <extension_attributes for=\"Vendor\\Shipping\\Api\\Data\\CarrierRateInterface\">\n        <attribute code=\"estimated_delivery_date\" type=\"string\" />\n    </extension_attributes>\n</config>\n\n// Plugin on repository to populate the extension attribute\npublic function afterGetList(\n    CarrierRateRepositoryInterface $subject,\n    CarrierRateSearchResultsInterface $results\n): CarrierRateSearchResultsInterface {\n    foreach ($results->getItems() as $rate) {\n        $extensionAttributes = $rate->getExtensionAttributes();\n        $extensionAttributes->setEstimatedDeliveryDate(\n            $this->deliveryCalculator->calculate($rate)\n        );\n        $rate->setExtensionAttributes($extensionAttributes);\n    }\n    return $results;\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "customization-strategy",
      "upgrade-safe-customization"
    ]
  },
  {
    "id": 160,
    "category": "Customization Architecture",
    "difficulty": "Hard",
    "question": "An Architect is integrating a custom ERP module (Vendor_Erp) that requires catalog product data and customer group pricing. The module must work whether or not the optional Magento_TierPricing module is installed. Which module dependency configuration is correct?",
    "options": [
      {
        "id": "A",
        "text": "Declare Magento_Catalog as a hard dependency in module.xml <sequence> and Magento_TierPricing as a hard dependency with a try/catch in the constructor"
      },
      {
        "id": "B",
        "text": "Declare both Magento_Catalog and Magento_TierPricing in module.xml <sequence> and use <preference> in di.xml to provide a null implementation when TierPricing is absent"
      },
      {
        "id": "C",
        "text": "Declare Magento_Catalog in module.xml <sequence> for load order, require it in composer.json, and list Magento_TierPricing only in composer.json as \"suggest\" with a proxy/factory pattern for its classes"
      },
      {
        "id": "D",
        "text": "Declare both modules in composer.json \"require\" and use module.xml <sequence> only for Magento_Catalog, letting Magento auto-resolve TierPricing load order"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "Magento 2 distinguishes between hard dependencies (module cannot function without them) and soft dependencies (module has enhanced functionality when present). These are managed through two complementary systems: composer.json for installation and module.xml for load order.\n\nWhy C is correct:\nMagento_Catalog is a hard dependency  the ERP module cannot function without products. It goes in both composer.json \"require\" (ensures installation) and module.xml <sequence> (ensures load order). Magento_TierPricing is a soft dependency  it's optional. Listing it in composer.json \"suggest\" documents the optional relationship without enforcing installation. Using proxy classes or factories for TierPricing classes prevents fatal errors when the module is absent  the ObjectManager can handle missing classes gracefully through proxy patterns.\n\nWhy A is incorrect:\nDeclaring TierPricing in <sequence> creates a hard load-order dependency. If TierPricing is not installed, Magento will throw a setup exception because a sequenced module is missing. Try/catch in the constructor doesn't help because the DI container will fail to resolve the class before the constructor even runs.\n\nWhy B is incorrect:\nListing TierPricing in <sequence> again creates a hard dependency  module.xml <sequence> entries must be installed modules. The preference approach for a null implementation is creative but unnecessary complexity when proxy/factory patterns handle missing modules natively.\n\nWhy D is incorrect:\nPutting Magento_TierPricing in composer.json \"require\" makes it a mandatory installation dependency, meaning the ERP module cannot be installed without TierPricing. This directly contradicts the requirement that TierPricing is optional.",
    "codeExample": "<!-- module.xml: Hard dependency only -->\n<config>\n    <module name=\"Vendor_Erp\" setup_version=\"1.0.0\">\n        <sequence>\n            <module name=\"Magento_Catalog\" />\n            <!-- TierPricing NOT listed: soft dependency -->\n        </sequence>\n    </module>\n</config>\n\n// composer.json\n{\n    \"require\": {\n        \"magento/module-catalog\": \"^103.0\"\n    },\n    \"suggest\": {\n        \"magento/module-tier-pricing\": \"Enables customer group pricing in ERP sync\"\n    }\n}\n\n// Soft dependency usage via proxy\npublic function __construct(\n    ProductRepositoryInterface $productRepository,\n    ?TierPriceManagementInterface $tierPriceManagement = null\n) {\n    $this->productRepository = $productRepository;\n    $this->tierPriceManagement = $tierPriceManagement;\n}\n\npublic function syncProduct(int $productId): array\n{\n    $product = $this->productRepository->getById($productId);\n    $data = ['sku' => $product->getSku()];\n\n    // Graceful degradation when TierPricing absent\n    if ($this->tierPriceManagement !== null) {\n        $data['tier_prices'] = $this->tierPriceManagement->getList($product->getSku());\n    }\n    return $data;\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "customization-strategy",
      "upgrade-safe-customization"
    ]
  },
  {
    "id": 161,
    "category": "Multi-site Architecture",
    "difficulty": "Medium",
    "question": "A merchant wants to sell identical products in the US and Canada with different prices, tax rules, and payment methods, but wants a single admin catalog. What is the correct architectural approach?",
    "options": [
      {
        "id": "A",
        "text": "Create two Store Views under one Website, using different locales for each country"
      },
      {
        "id": "B",
        "text": "Create two separate Websites, each with its own Store and Store View, sharing products via the Global scope catalog"
      },
      {
        "id": "C",
        "text": "Create two Stores under one Website with separate category trees for each country"
      },
      {
        "id": "D",
        "text": "Use a single Website with a single Store View and handle all differences via customer group pricing"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because separate Websites are required when you need different base currencies, tax configurations, or payment methods  these are all Website-scoped configurations in Magento 2. Products assigned to the Global scope are automatically available across both Websites, giving the merchant a single catalog to manage while allowing per-Website pricing, tax rules, and payment methods.\n\nA is wrong because Store Views exist under a Store within a Website, and they only control language/locale/translations. Tax rules, payment methods, and base currency are Website-scoped and cannot differ between Store Views in the same Website.\n\nC is wrong because multiple Stores under one Website share the same Website-scoped configuration (tax, payment, base currency). While separate Stores allow different category trees, they cannot solve the requirement for different tax rules and payment methods per country.\n\nD is wrong because customer group pricing does not address tax configuration or payment method differences, which are Website-scoped. This approach would also create a poor customer experience with no clear separation between country-specific storefronts.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "multi-site",
      "scope-hierarchy"
    ]
  },
  {
    "id": 162,
    "category": "Multi-site Architecture",
    "difficulty": "Hard",
    "question": "A retailer operates storefronts in the US (USD), Germany (EUR), and Japan (JPY). Each storefront has its own base currency. During catalog price indexing, the merchant notices that cross-currency price comparisons in layered navigation are inaccurate. What is the root cause and correct solution?",
    "options": [
      {
        "id": "A",
        "text": "The currency rate table is outdated; configure a scheduled cron job using the Fixer.io API to update rates, then trigger a full price reindex"
      },
      {
        "id": "B",
        "text": "Layered navigation always uses the default Website's base currency for price ranges; override the price indexer to normalize all prices to a single reference currency"
      },
      {
        "id": "C",
        "text": "Each Website has its own base currency and price index; layered navigation price ranges are built per-Website scope, so cross-currency comparison is not a valid use case  the issue is likely that products are missing Website-specific prices and falling back to default scope"
      },
      {
        "id": "D",
        "text": "Enable the 'Display Prices in Both Currencies' option in the catalog configuration so customers can compare prices across currencies"
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct because Magento 2's price indexer builds separate price index entries per Website. Each Website's layered navigation uses its own base currency for price range buckets. There is no built-in cross-currency price comparison in layered navigation. When prices appear 'inaccurate,' it's typically because products lack Website-specific prices and fall back to the default scope price (which is in a different currency), causing mismatched values in the index.\n\nA is wrong because while keeping currency rates updated is good practice, rates are used for display currency conversion (converting base currency to allowed display currencies within the same Website). Updating rates does not fix the fundamental issue of products missing Website-specific base prices.\n\nB is wrong because the price indexer does not normalize prices across Websites to a single currency. Overriding the indexer this way would be a custom, non-standard approach that fights the platform's multi-Website architecture rather than using it correctly.\n\nD is wrong because there is no such native configuration option. Display currency conversion shows prices in alternate currencies within the same storefront, but does not enable cross-Website price comparison in layered navigation.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "multi-site",
      "scope-hierarchy"
    ]
  },
  {
    "id": 163,
    "category": "Multi-site Architecture",
    "difficulty": "Medium",
    "question": "A company needs to launch a Magento 2 store in French and German for the European market. Both languages sell the same products at the same prices with the same payment and shipping methods. Product descriptions and CMS content must be translated. What is the most efficient architecture?",
    "options": [
      {
        "id": "A",
        "text": "Create two separate Websites  one for French and one for German  each with translated content"
      },
      {
        "id": "B",
        "text": "Create one Website with one Store and two Store Views (fr_FR and de_DE), using Store View-scoped attributes for translated product content and inline translation for static strings"
      },
      {
        "id": "C",
        "text": "Create one Website with two Stores, each having one Store View, and duplicate the entire catalog for each language"
      },
      {
        "id": "D",
        "text": "Create one Website with one Store View and use a JavaScript-based translation layer on the frontend to dynamically translate all content"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because Store Views are specifically designed for language/locale variations within the same store. When prices, payment methods, shipping, tax rules, and catalog structure are identical, there is no reason to create separate Websites or Stores. Store View-scoped product attributes (name, description, meta fields) hold translations. CSV translation files and inline translation handle static UI strings. This is the most efficient approach  one catalog, one set of rules, minimal duplication.\n\nA is wrong because separate Websites are unnecessary overhead when pricing, tax, payment, and shipping are identical. Websites are for scenarios requiring different base currencies, tax rules, or payment configurations. Using Websites for language-only differences duplicates configuration and complicates catalog management.\n\nC is wrong because separate Stores are used when you need different category tree structures (root categories). If the same products are sold with the same navigation, duplicating the catalog across two Stores is wasteful and creates a maintenance burden with no architectural benefit.\n\nD is wrong because client-side translation is not a Magento pattern, does not integrate with the CMS or product attribute system, causes SEO problems (search engines see untranslated content), and creates a poor user experience with potential flash-of-untranslated-content issues.",
    "codeExample": "<!-- i18n CSV file: app/design/frontend/Vendor/theme/i18n/de_DE.csv -->\n\"Add to Cart\",\"In den Warenkorb\"\n\"Search\",\"Suche\"\n\"My Account\",\"Mein Konto\"\n\n<!-- Store View scope for product attributes in catalog_product_entity_varchar -->\n<!-- attribute_id=73 (name), store_id=2 (de_DE Store View) -->\n<!-- value = 'Herren Laufschuhe' instead of 'Men Running Shoes' -->",
    "examDomain": "Design",
    "objectiveTags": [
      "multi-site",
      "scope-hierarchy"
    ]
  },
  {
    "id": 164,
    "category": "Multi-site Architecture",
    "difficulty": "Hard",
    "question": "An enterprise merchant has three brands that share some products but each brand has unique products and a distinct category tree. Certain products must appear in multiple brand catalogs with brand-specific pricing. What architecture correctly supports these requirements? (Choose 2)",
    "options": [
      {
        "id": "A",
        "text": "Create one Website with three Stores, each having its own root category, and assign shared products to all three Websites via the product's 'Product in Websites' setting"
      },
      {
        "id": "B",
        "text": "Create three separate Websites, each with its own Store, and assign shared products to multiple Websites  use Website-scoped pricing for brand-specific prices"
      },
      {
        "id": "C",
        "text": "Create one Website with one Store, use customer groups to show different category trees and prices per brand"
      },
      {
        "id": "D",
        "text": "Create three Stores under one Website with different root categories for distinct category trees, then use catalog price rules with Store View scope for brand-specific pricing"
      },
      {
        "id": "E",
        "text": "Create three separate Websites, each with its own Store and root category, assign shared products to all three Websites, and configure per-Website prices on the product's Advanced Pricing settings"
      }
    ],
    "correctAnswers": [
      "B",
      "E"
    ],
    "explanation": "B and E are both correct and describe the same architecture with different levels of detail. Three separate Websites are needed because each brand requires distinct pricing (price is Website-scoped in Magento 2). Each Website's Store gets its own root category, enabling distinct category trees per brand. Shared products are assigned to multiple Websites via the 'Product in Websites' checkbox, and Website-scoped pricing allows each brand to set its own price for the same product.\n\nA is wrong because it describes three Stores under one Website but then references assigning products to 'all three Websites'  there is only one Website in this scenario. More critically, under a single Website all Stores share the same base price (price is Website-scoped), so brand-specific pricing is impossible without separate Websites.\n\nC is wrong because customer groups cannot control which category tree a customer sees. Root categories and category tree structure are Store-level configurations. Customer group pricing exists but does not solve the distinct category tree requirement.\n\nD is wrong because catalog price rules are not Store View-scoped in native Magento 2  they are Website-scoped. Even if they were, using price rules as a substitute for proper Website-scoped base pricing would be fragile and difficult to maintain. Under one Website, the base price is shared across all Stores, so price rules would be workarounds rather than proper architecture.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "multi-site",
      "scope-hierarchy"
    ]
  },
  {
    "id": 165,
    "category": "Multi-site Architecture",
    "difficulty": "Hard",
    "question": "A merchant runs three Magento 2 storefronts on separate domains (brand-a.com, brand-b.com, brand-c.com) behind Varnish. The Nginx configuration must route each domain to the correct Magento Website code. Which configuration approach correctly handles this?",
    "options": [
      {
        "id": "A",
        "text": "Set the MAGE_RUN_CODE and MAGE_RUN_TYPE environment variables in the Nginx server block per domain using a map directive, and pass them to PHP-FPM via fastcgi_param"
      },
      {
        "id": "B",
        "text": "Configure separate Magento installations for each domain and use Nginx upstream blocks to proxy each domain to its own application instance"
      },
      {
        "id": "C",
        "text": "Use Magento's Admin > Stores > Configuration > Web > Base URLs to set the domain per Store View, relying on Magento's internal routing to match the incoming domain automatically"
      },
      {
        "id": "D",
        "text": "Set the store code in the URL path (brand-a.com/store_a/) and enable 'Add Store Code to URLs' in the admin configuration for each Store View"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "A is correct because the standard approach for multi-domain Magento 2 deployments is to use Nginx's map directive to associate each incoming server_name (domain) with the correct MAGE_RUN_CODE (Website code) and MAGE_RUN_TYPE (set to 'website'). These are passed to PHP-FPM as fastcgi_param values, telling Magento which Website configuration to load. When Varnish sits in front, the X-Forwarded-Host header or a similar mechanism passes the original domain through so Nginx can still resolve the correct Website code.\n\nB is wrong because running separate Magento installations defeats the purpose of multi-Website architecture. The entire benefit of Magento's Website/Store/Store View hierarchy is sharing a single codebase, admin panel, and database across multiple storefronts. Separate installations multiply maintenance, deployment complexity, and infrastructure costs.\n\nC is wrong because while setting Base URLs is necessary for Magento to generate correct links, it does not handle the initial routing of incoming requests. Magento does not inspect the incoming HTTP Host header and automatically select the correct Website. The web server must explicitly tell Magento which Website to load via MAGE_RUN_CODE before the application bootstraps.\n\nD is wrong because adding store codes to URLs (brand-a.com/store_a/) is a Store View-level feature, not a Website routing mechanism. It does not solve multi-domain routing  all domains would still need proper server-level configuration. Additionally, store codes in URLs are generally undesirable for branding and SEO on separate domains.",
    "codeExample": "# Nginx configuration for multi-domain Magento 2\n\nmap $http_host $MAGE_RUN_CODE {\n    brand-a.com   brand_a;\n    brand-b.com   brand_b;\n    brand-c.com   brand_c;\n}\n\nmap $http_host $MAGE_RUN_TYPE {\n    default   website;\n}\n\nserver {\n    listen 80;\n    server_name brand-a.com brand-b.com brand-c.com;\n    set $MAGE_ROOT /var/www/magento;\n\n    location ~ \\.php$ {\n        fastcgi_pass   unix:/run/php-fpm/magento.sock;\n        fastcgi_param  MAGE_RUN_CODE $MAGE_RUN_CODE;\n        fastcgi_param  MAGE_RUN_TYPE $MAGE_RUN_TYPE;\n        include        fastcgi_params;\n        fastcgi_param  SCRIPT_FILENAME $MAGE_ROOT/pub/index.php;\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "multi-site",
      "scope-hierarchy"
    ]
  },
  {
    "id": 166,
    "category": "Catalog & Price Architecture",
    "difficulty": "Hard",
    "question": "A merchant with 50,000 products and 12 customer groups reports that catalog pages load slowly after price rule changes. Investigation reveals the catalog_product_index_price table rebuild takes over 40 minutes. The merchant uses tier prices, special prices, and catalog price rules extensively. Which architectural approach best addresses this price indexing bottleneck?",
    "options": [
      {
        "id": "A",
        "text": "Replace the default price indexer with a custom indexer that writes directly to the flat catalog tables, bypassing catalog_product_index_price entirely"
      },
      {
        "id": "B",
        "text": "Implement a custom price indexer dimension that partitions the catalog_product_index_price table by customer group, enabling parallel indexing per group"
      },
      {
        "id": "C",
        "text": "Disable the price indexer and calculate all prices at runtime using a plugin on \\Magento\\Catalog\\Pricing\\Price\\FinalPrice, caching results in Redis"
      },
      {
        "id": "D",
        "text": "Reduce customer groups to 3 and merge tier pricing rules to decrease the number of rows generated per product in the index table"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct: Magento 2.3+ introduced indexer dimensions (introduced via the Indexer\\DimensionProviderInterface) specifically to address price indexing at scale. By partitioning catalog_product_index_price by customer group, each group's prices can be rebuilt independently and in parallel, dramatically reducing total reindex time. The architecture creates separate temporary tables per dimension, processes them concurrently, then swaps them into the main table.\n\nA is wrong: The flat catalog tables depend on catalog_product_index_price for their price columns. Bypassing it would leave flat tables with stale or missing price data and break collection filtering by price.\n\nC is wrong: Runtime price calculation for 50,000 products would create severe performance problems on category and search result pages where dozens of products must display prices simultaneously. Even with Redis caching, cache warming and invalidation at this scale would be more complex than proper indexing.\n\nD is wrong: While reducing customer groups would decrease index rows (rows = products  groups), this is a business constraint workaround rather than an architectural solution. It forces the merchant to sacrifice legitimate pricing segmentation and doesn't address the root indexing architecture problem.",
    "codeExample": "<!-- di.xml: Configure price indexer dimensions by customer group -->\n<type name=\"Magento\\Catalog\\Model\\Indexer\\Product\\Price\\DimensionCollectionFactory\">\n    <arguments>\n        <argument name=\"dimensionProviders\" xsi:type=\"array\">\n            <item name=\"customer_group\" xsi:type=\"string\">\n                Magento\\Customer\\Model\\Indexer\\CustomerGroupDimensionProvider\n            </item>\n        </argument>\n    </arguments>\n</type>\n\n<!-- indexer.xml: Enable dimensions for price indexer -->\n<indexer id=\"catalog_product_price\"\n         class=\"Magento\\Catalog\\Model\\Indexer\\Product\\Price\"\n         view_id=\"catalog_product_price\">\n    <dimensions>\n        <dimension name=\"customer_group\"\n                   provider=\"Magento\\Customer\\Model\\Indexer\\CustomerGroupDimensionProvider\" />\n    </dimensions>\n</indexer>",
    "examDomain": "Design",
    "objectiveTags": [
      "catalog-pricing",
      "indexing",
      "rule-engine"
    ]
  },
  {
    "id": 167,
    "category": "Catalog & Price Architecture",
    "difficulty": "Medium",
    "question": "A product has a regular price of $100, a special price of $85 (currently active), a tier price of $80 for qty 5+ for the General customer group, and an active catalog price rule giving 10% off. What final price does Magento display for a General group customer viewing the product detail page (qty 1)?",
    "options": [
      {
        "id": "A",
        "text": "$76.50  the catalog rule applies 10% off the special price of $85"
      },
      {
        "id": "B",
        "text": "$80  the tier price takes highest priority over all other price types"
      },
      {
        "id": "C",
        "text": "$85  the special price is used, and the catalog rule discount is not applied on top of it"
      },
      {
        "id": "D",
        "text": "$90  the catalog rule applies 10% off the regular price, ignoring the special price"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "A is correct: Magento's price resolution calculates the final price by first determining the minimum between regular price and special price (min($100, $85) = $85), then applying catalog price rules on top of that resolved price. A 10% discount on $85 = $76.50. Tier prices are only considered when the quantity threshold is met, so at qty 1, the tier price of $80 for qty 5+ does not apply.\n\nB is wrong: Tier prices are quantity-dependent. The tier price of $80 only activates when the customer adds 5 or more units. At qty 1 on the product detail page, tier pricing is not in effect.\n\nC is wrong: Catalog price rules DO apply on top of the special price. The special price replaces the regular price as the base for further discounts. Magento's FinalPrice calculation applies catalog rules after resolving the special price, not instead of it.\n\nD is wrong: Catalog price rules apply to the final resolved price, not exclusively to the regular price. Since the special price ($85) is lower than the regular price ($100), $85 becomes the base price on which the catalog rule percentage is calculated.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "catalog-pricing",
      "indexing",
      "rule-engine"
    ]
  },
  {
    "id": 168,
    "category": "Catalog & Price Architecture",
    "difficulty": "Hard",
    "question": "A B2B merchant needs a \"negotiated price\" that overrides all other pricing (special prices, tier prices, catalog rules) for specific customer-product combinations stored in a custom table. The negotiated price must appear in category listings, search results, and layered navigation price filtering. Which implementation approach is architecturally correct?",
    "options": [
      {
        "id": "A",
        "text": "Create a plugin on \\Magento\\Catalog\\Pricing\\Price\\FinalPrice::getValue() that checks the custom table and returns the negotiated price when found"
      },
      {
        "id": "B",
        "text": "Create a custom price indexer plugin on \\Magento\\Catalog\\Model\\ResourceModel\\Product\\Indexer\\Price\\Query\\BaseFinalPrice that joins the negotiated price table and overrides the min_price/final_price columns in the index"
      },
      {
        "id": "C",
        "text": "Use an observer on catalog_product_get_final_price to set the negotiated price on the product model before any other price calculation occurs"
      },
      {
        "id": "D",
        "text": "Store negotiated prices as customer-group-specific special prices using the existing special_price attribute and create one customer group per negotiation"
      },
      {
        "id": "E",
        "text": "Create a custom PriceBox block that renders the negotiated price on the frontend while leaving the actual price model and index untouched"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct: For negotiated prices to work in category listings, search results, and layered navigation price filtering, the prices MUST be present in the price index (catalog_product_index_price). Layered navigation and collection sorting/filtering read from the index, not from runtime price calculation. By modifying the price indexer query via a plugin on BaseFinalPrice, the negotiated prices are written into min_price and final_price columns, making them available everywhere the index is consumed.\n\nA is wrong: A plugin on FinalPrice::getValue() only affects runtime price calculation on product detail pages and when individual product prices are resolved. It does NOT affect the price index, so category page price filtering via layered navigation would show incorrect price ranges, and sorted-by-price listings would use the non-negotiated indexed price.\n\nC is wrong: The catalog_product_get_final_price event similarly only fires during runtime price resolution, not during indexing. Layered navigation and collection price filters would still use the unmodified indexed prices.\n\nD is wrong: Creating a customer group per negotiation is not scalable for B2B. A merchant with 500 customers each having unique negotiated prices would need 500 customer groups, which multiplies price index rows (products  groups) and makes group management unworkable.\n\nE is wrong: A custom PriceBox only changes the visual rendering. The actual price used for cart calculations, layered navigation filtering, and price sorting would remain the standard price. This creates a dangerous disconnect between displayed and actual prices.",
    "codeExample": "<?php\nnamespace Vendor\\NegotiatedPrice\\Plugin;\n\nuse Magento\\Catalog\\Model\\ResourceModel\\Product\\Indexer\\Price\\Query\\BaseFinalPrice;\nuse Magento\\Framework\\DB\\Select;\n\nclass ModifyPriceIndexQuery\n{\n    public function afterGetQuery(\n        BaseFinalPrice $subject,\n        Select $select\n    ): Select {\n        // Join negotiated_price table into the price index query\n        $select->joinLeft(\n            ['np' => 'negotiated_price'],\n            'np.product_id = e.entity_id AND np.customer_group_id = cg.customer_group_id',\n            []\n        );\n\n        // Override final_price and min_price when negotiated price exists\n        $connection = $select->getConnection();\n        $columns = $select->getPart(Select::COLUMNS);\n\n        // Use IFNULL to fall back to standard price when no negotiation exists\n        $select->columns([\n            'final_price' => $connection->getIfNullSql(\n                'np.negotiated_price',\n                'price_index.final_price'\n            ),\n            'min_price' => $connection->getIfNullSql(\n                'np.negotiated_price',\n                'price_index.min_price'\n            ),\n        ]);\n\n        return $select;\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "catalog-pricing",
      "indexing",
      "rule-engine"
    ]
  },
  {
    "id": 169,
    "category": "Catalog & Price Architecture",
    "difficulty": "Medium",
    "question": "A merchant sells industrial equipment where each product requires customers to select a warranty duration (1, 3, or 5 years), an installation service (basic or premium), and optional add-on components from a predefined list. Each combination affects the final price. An architect must choose the right product type. Which approach is most appropriate?",
    "options": [
      {
        "id": "A",
        "text": "Create a custom product type with its own price model to handle the warranty/service/add-on pricing matrix"
      },
      {
        "id": "B",
        "text": "Use a bundle product with fixed bundle options for warranty and installation, and a multi-select option for add-on components"
      },
      {
        "id": "C",
        "text": "Use a configurable product with super attributes for warranty duration and installation type, plus custom options for add-ons"
      },
      {
        "id": "D",
        "text": "Use a simple product with custom options for all three selections and calculate the price via a plugin on the custom option price model"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct: Bundle products are designed exactly for this use case  composing a final product from multiple required and optional selections, each contributing to the total price. Warranty duration maps to a fixed radio/dropdown bundle option with 3 choices (each priced differently). Installation service maps to another fixed bundle option with 2 choices. Add-on components map to a multi-select or checkbox bundle option. Bundle products handle the price aggregation natively, display correctly in cart/checkout, and are fully supported by the price indexer.\n\nA is wrong: Creating a custom product type is significant over-engineering for this scenario. Custom product types require implementing TypeInterface, a custom price model, stock handling, quote/order item handling, and custom admin UI. This is only justified when no existing type can model the product's fundamental behavior (e.g., subscriptions, digital licenses with unique fulfillment). The bundle type already handles this composition pattern.\n\nC is wrong: Configurable products create child simple products for each attribute combination. Warranty (3 values)  Installation (2 values) = 6 child SKUs per equipment product, and add-ons cannot be modeled as super attributes because they are multi-select. This forces a hybrid approach that is harder to maintain and doesn't leverage Magento's built-in composition pricing.\n\nD is wrong: Custom options on simple products work for basic cases but lack the structured pricing, inventory awareness, and reporting capabilities of bundle items. Custom options are flat  they don't support the hierarchical selection model needed here, and the price calculation would require custom plugin logic that duplicates what the bundle product type already provides.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "catalog-pricing",
      "indexing",
      "rule-engine"
    ]
  },
  {
    "id": 170,
    "category": "Catalog & Price Architecture",
    "difficulty": "Hard",
    "question": "A large merchant with 200+ categories (tree depth of 6 levels) and 80,000 products reports that category pages for anchor categories at level 2 load in 8+ seconds. Flat catalog is enabled. Analysis shows the category_product index is current, but MySQL queries joining catalog_category_product_index with catalog_product_entity_int for layered navigation filters are slow. Which combination of architectural changes will most effectively improve performance?",
    "options": [
      {
        "id": "A",
        "text": "Increase MySQL query cache size and add composite indexes on catalog_category_product_index covering (category_id, product_id, position)"
      },
      {
        "id": "B",
        "text": "Disable flat catalog entirely and rely on EAV with Elasticsearch for all frontend catalog queries, since Elasticsearch handles filtering and sorting independently of MySQL index tables"
      },
      {
        "id": "C",
        "text": "Disable anchor categories at level 2 so they only show directly assigned products, reducing the category-product index row count, and implement faceted navigation via Elasticsearch"
      },
      {
        "id": "D",
        "text": "Keep flat catalog for product listing data but migrate layered navigation and filtering to Elasticsearch, and optimize anchor category depth so high-level anchors resolve fewer descendant categories"
      },
      {
        "id": "E",
        "text": "Replace SQLite-based indexing with a custom Redis-backed category-product mapping for faster lookups during category page rendering"
      }
    ],
    "correctAnswers": [
      "D"
    ],
    "explanation": "D is correct: This is the optimal hybrid approach. Flat catalog tables remain valuable for fast product attribute retrieval in listings (avoiding EAV joins for display attributes). However, layered navigation filtering  which is the actual bottleneck when joining category_product_index with attribute index tables  should be delegated to Elasticsearch, which handles faceted filtering natively without MySQL joins. Additionally, reviewing anchor category depth is important: a level-2 anchor category in a 6-level tree aggregates products from all descendant categories, potentially creating hundreds of thousands of rows in the category-product index. Limiting anchor behavior or restructuring the tree reduces this multiplication.\n\nA is wrong: MySQL query cache was removed in MySQL 8.0 and is generally ineffective for dynamic e-commerce queries. The composite index suggested already exists by default on catalog_category_product_index. The problem is not missing indexes but the sheer volume of rows that anchor categories at high levels create  an index cannot fix a fundamentally large result set that must be joined with attribute tables.\n\nB is wrong: Disabling flat catalog entirely forces all product listing queries back to EAV, which requires multiple joins per attribute for display data (name, image, price, etc.). While Elasticsearch handles filtering well, the actual product data retrieval for rendering still hits MySQL, and EAV queries for 40+ products per page with 10+ display attributes are significantly slower than flat table reads.\n\nC is wrong: Disabling anchor categories at level 2 would break the merchant's expected catalog navigation behavior  customers browsing a top-level category expect to see all products within its subcategories. This is a fundamental UX requirement for most catalogs, not something that should be sacrificed for performance.\n\nE is wrong: Magento does not use SQLite for indexing  it uses MySQL/MariaDB. The suggestion is based on a incorrect premise. Furthermore, replacing the category-product index with Redis would require reimplementing the entire category product resolution, layered navigation, and price filtering logic, which is extreme over-engineering compared to leveraging Elasticsearch's existing faceted search capabilities.",
    "codeExample": "<!-- catalog/search engine config: Use Elasticsearch for layered navigation -->\n<!-- env.php or admin: Stores > Config > Catalog > Catalog Search -->\n<!--\n  'system' => [\n      'default' => [\n          'catalog' => [\n              'search' => [\n                  'engine' => 'elasticsearch7',\n                  'elasticsearch7_server_hostname' => 'localhost',\n                  'elasticsearch7_server_port' => '9200'\n              ]\n          ]\n      ]\n  ]\n-->\n\n<?php\n// Verify anchor category product count to identify bloated index areas\nnamespace Vendor\\CatalogDiagnostic\\Console;\n\nuse Magento\\Catalog\\Model\\ResourceModel\\Category\\CollectionFactory;\nuse Magento\\Framework\\App\\ResourceConnection;\nuse Symfony\\Component\\Console\\Command\\Command;\nuse Symfony\\Component\\Console\\Input\\InputInterface;\nuse Symfony\\Component\\Console\\Output\\OutputInterface;\n\nclass AnchorCategoryAnalysis extends Command\n{\n    public function __construct(\n        private readonly ResourceConnection $resource,\n        private readonly CollectionFactory $categoryCollectionFactory\n    ) {\n        parent::__construct();\n    }\n\n    protected function execute(InputInterface $input, OutputInterface $output): int\n    {\n        $connection = $this->resource->getConnection();\n        $table = $this->resource->getTableName('catalog_category_product_index');\n\n        // Find categories with the most indexed product rows\n        $select = $connection->select()\n            ->from($table, ['category_id', 'product_count' => 'COUNT(*)'])\n            ->group('category_id')\n            ->order('product_count DESC')\n            ->limit(20);\n\n        $results = $connection->fetchAll($select);\n\n        foreach ($results as $row) {\n            $output->writeln(sprintf(\n                'Category %d: %d indexed products',\n                $row['category_id'],\n                $row['product_count']\n            ));\n        }\n\n        return Command::SUCCESS;\n    }\n}",
    "examDomain": "Design",
    "objectiveTags": [
      "catalog-pricing",
      "indexing",
      "rule-engine"
    ]
  },
  {
    "id": 171,
    "category": "B2B Features",
    "difficulty": "Medium",
    "question": "A client needs to model a corporate structure where a parent company has three regional divisions, each with their own purchasing departments and budget limits. Which approach correctly implements this in Adobe Commerce B2B?",
    "options": [
      {
        "id": "A",
        "text": "Create separate customer accounts for each division and link them via custom attributes"
      },
      {
        "id": "B",
        "text": "Use the Company Account hierarchy with a root company user, division-level admin users assigned to teams, and configure roles with resource-based permissions for each team"
      },
      {
        "id": "C",
        "text": "Create one company account and manage divisions through customer groups with shared pricing rules"
      },
      {
        "id": "D",
        "text": "Implement a custom module that extends the customer entity with parent-child relationships and budget tracking"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because Adobe Commerce B2B's Company Account feature natively supports hierarchical organizational structures through Teams (which represent divisions/departments) and Roles with granular resource permissions. The root company admin sits at the top, division admins manage their teams, and roles control what actions (placing orders, viewing quotes, managing users) each level can perform. This maps directly to the corporate structure requirement.\n\nA is wrong because separate customer accounts cannot share a company context  they would be isolated entities without a unified hierarchy, approval chain, or shared catalog access.\n\nC is wrong because customer groups are a B2C concept for pricing segmentation. They do not provide organizational hierarchy, team-based permissions, or the approval workflows needed for divisional purchasing control.\n\nD is wrong because building a custom parent-child customer system would duplicate the native Company Account functionality, adding unnecessary complexity and maintenance burden while losing integration with B2B features like purchase approvals, quotes, and shared catalogs.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "b2b",
      "company-accounts",
      "shared-catalog"
    ]
  },
  {
    "id": 172,
    "category": "B2B Features",
    "difficulty": "Hard",
    "question": "An architect is designing catalog pricing for a B2B merchant who sells to 200+ companies. Most companies see standard pricing, but 15 strategic accounts need custom pricing on overlapping subsets of products. Some products appear in multiple custom catalogs with different prices. How should the shared catalog architecture be configured?",
    "options": [
      {
        "id": "A",
        "text": "Create one Public shared catalog with standard pricing and 15 Custom shared catalogs, each assigned to the respective company account. For products in multiple custom catalogs, each catalog maintains its own independent price."
      },
      {
        "id": "B",
        "text": "Create 15 tier-price rules using catalog price rules with customer group conditions, keeping all products in the default catalog"
      },
      {
        "id": "C",
        "text": "Create one Custom shared catalog and assign all 15 companies to it, using tier pricing within that single catalog to differentiate per-company prices"
      },
      {
        "id": "D",
        "text": "Bypass shared catalogs entirely and use cart price rules with company-specific coupon codes to achieve per-company pricing"
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "A is correct because this is the intended Shared Catalog architecture. The Public catalog serves as the default for all companies without a custom assignment and controls product visibility and base pricing. Each Custom shared catalog can override prices on a per-product basis independently, so the same SKU can have $100 in Company X's catalog and $85 in Company Y's catalog. When a company is assigned a Custom catalog, they see only the products included in it at the custom prices. This scales to 15 catalogs and handles overlapping product sets with different prices naturally.\n\nB is wrong because catalog price rules apply discounts based on customer groups, not company accounts. They cannot provide the product visibility control that shared catalogs offer (hiding/showing specific products per company), and managing 15 different pricing structures through layered price rules becomes fragile and conflict-prone.\n\nC is wrong because a single Custom shared catalog cannot differentiate pricing between the 15 companies assigned to it  all companies on the same shared catalog see the same prices. You would need one Custom catalog per company to achieve per-company pricing.\n\nD is wrong because cart price rules with coupons are a promotional mechanism, not a B2B pricing architecture. They don't control product visibility, require customers to enter codes, can be shared/leaked between companies, and don't integrate with the B2B quote negotiation workflow.",
    "codeExample": "// Programmatically assigning custom prices in a shared catalog\n/** @var \\Magento\\SharedCatalog\\Api\\SharedCatalogManagementInterface $sharedCatalogManagement */\n/** @var \\Magento\\SharedCatalog\\Api\\ProductManagementInterface $productManagement */\n\n// Get the custom shared catalog assigned to a company\n$sharedCatalog = $sharedCatalogManagement->getByCompanyId($companyId);\n\n// Assign products with custom pricing\n$productManagement->assignProducts($sharedCatalog->getId(), $productSkus);\n\n// Custom prices are set via tier price entries linked to the\n// customer group that the shared catalog creates internally\n/** @var \\Magento\\Catalog\\Api\\TierPriceStorageInterface $tierPriceStorage */\n$tierPrice = $this->tierPriceFactory->create();\n$tierPrice->setPrice(85.00);\n$tierPrice->setPriceType('fixed');\n$tierPrice->setCustomerGroup($sharedCatalog->getCustomerGroupId());\n$tierPrice->setQuantity(1);\n$tierPrice->setSku('WIDGET-100');\n$tierPriceStorage->update([$tierPrice]);",
    "examDomain": "Design",
    "objectiveTags": [
      "b2b",
      "company-accounts",
      "shared-catalog"
    ]
  },
  {
    "id": 173,
    "category": "B2B Features",
    "difficulty": "Hard",
    "question": "A B2B merchant wants to optimize the reordering experience for warehouse managers who regularly place orders of 50-200 SKUs. The managers know their SKUs and quantities in advance, often from spreadsheets. Which combination of B2B features should the architect recommend? (Choose 2)",
    "options": [
      {
        "id": "A",
        "text": "Quick Order form with CSV upload support, allowing managers to paste or upload SKU/quantity pairs and add all items to cart in one action"
      },
      {
        "id": "B",
        "text": "Requisition Lists that persist frequently ordered product collections, enabling one-click reorder of a saved list with quantity adjustments before adding to cart"
      },
      {
        "id": "C",
        "text": "A custom REST API integration that accepts a JSON payload of SKUs and quantities and programmatically creates orders, bypassing the storefront entirely"
      },
      {
        "id": "D",
        "text": "Configuring the native wishlist feature with multi-wishlist enabled so managers can save and reorder from categorized product collections"
      },
      {
        "id": "E",
        "text": "Building a custom module that watches a shared network folder for CSV files and auto-creates orders using the Magento order management API"
      }
    ],
    "correctAnswers": [
      "A",
      "B"
    ],
    "explanation": "A is correct because Quick Order is purpose-built for B2B buyers who know their SKUs. It provides a form where users can enter SKU/quantity pairs directly, paste from a spreadsheet, or upload a CSV file. For 50-200 line items from a spreadsheet, the CSV upload capability is the most efficient path  no browsing the catalog required.\n\nB is correct because Requisition Lists are persistent, reusable product collections designed for B2B repeat ordering. Warehouse managers can save their standard orders as named lists (e.g., \"Weekly Restock - Warehouse A\"), then reorder by selecting the list, adjusting quantities as needed, and adding everything to cart. This complements Quick Order for recurring vs. ad-hoc ordering patterns.\n\nC is wrong because building a custom API integration bypasses the storefront purchasing workflow, which means no approval rules are applied, no shared catalog pricing validation occurs in the buyer's context, and managers lose visibility into their order flow. It also requires custom development when native features already solve the problem.\n\nD is wrong because wishlists are a B2C feature designed for individual consumers saving products for future personal purchase. They lack B2B capabilities like company-level sharing, integration with purchase approval workflows, and the quantity-focused interface that Requisition Lists provide.\n\nE is wrong because an automated file-watch order creation system bypasses all B2B workflow controls  purchase approvals, budget validation, and shared catalog pricing enforcement. It introduces security risks from the file system integration and requires significant custom development for a problem that Quick Order's CSV upload already solves with proper governance.",
    "codeExample": "",
    "examDomain": "Design",
    "objectiveTags": [
      "b2b",
      "company-accounts",
      "shared-catalog"
    ]
  },
  {
    "id": 174,
    "category": "B2B Features",
    "difficulty": "Hard",
    "question": "A manufacturing client requires a multi-tier purchase approval system: orders under $500 are auto-approved, orders $500-$5,000 require department manager approval, and orders over $5,000 require both department manager and VP approval in sequence. If any approver rejects, the order is cancelled. How should this be architected using Adobe Commerce B2B?",
    "options": [
      {
        "id": "A",
        "text": "Create three approval rules at the company level: one auto-approve rule for <$500, one rule requiring the Manager role for $500-$5,000, and one rule requiring both Manager and VP roles for >$5,000, relying on the native sequential approval chain"
      },
      {
        "id": "B",
        "text": "Configure two purchase order approval rules scoped to the company: Rule 1 requires 'Manager' role approval for orders $500, Rule 2 requires 'VP' role approval for orders >$5,000. Orders matching both rules require sequential approval from both roles. Set auto-approve threshold in company configuration for orders under $500."
      },
      {
        "id": "C",
        "text": "Build a custom approval workflow module using Magento's event/observer system to intercept order placement and route through a state machine with Manager and VP approval states"
      },
      {
        "id": "D",
        "text": "Use the native B2B quote negotiation workflow instead, configuring it so that orders above $500 require a quote request that must be approved by the appropriate manager level before conversion to an order"
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because Adobe Commerce B2B's Purchase Order Approval Rules support exactly this pattern. Rules are defined at the company level with conditions (order total thresholds) and required approver roles. When a purchase order matches multiple rules, all rules must be satisfied  creating the sequential chain. Rule 1 catches all orders $500 and requires Manager approval. Rule 2 catches orders >$5,000 and additionally requires VP approval. Orders under $500 bypass approval entirely based on the company-level auto-approval configuration. If any approver rejects, the purchase order is rejected.\n\nA is wrong because there is no native \"auto-approve rule\" as a distinct rule type  auto-approval for low-value orders is handled by the absence of matching rules or company-level configuration, not by creating an explicit rule. Additionally, the framing of three separate rules misrepresents how rule matching works: the $500-$5,000 and >$5,000 rules should overlap ($500 catches both tiers) rather than being mutually exclusive ranges, because the sequential chain comes from an order matching multiple rules simultaneously.\n\nC is wrong because building a custom approval state machine duplicates the native Purchase Order approval functionality. The native system already provides rule-based routing, role-based approvers, sequential chains, and rejection handling. Custom development here adds maintenance cost and loses integration with the B2B company hierarchy and role system.\n\nD is wrong because the quote negotiation workflow serves a fundamentally different purpose  it's for price negotiation between buyer and seller, not internal purchase approval within a company. Quotes involve back-and-forth price adjustments with the merchant, while purchase approvals are internal governance within the buying organization. Using quotes for approvals would conflate two distinct business processes and confuse both buyers and the merchant's sales team.",
    "codeExample": "// Programmatically creating purchase order approval rules\nuse Magento\\PurchaseOrderRule\\Api\\Data\\RuleInterface;\nuse Magento\\PurchaseOrderRule\\Api\\RuleRepositoryInterface;\n\n/** @var RuleRepositoryInterface $ruleRepository */\n/** @var RuleInterface $managerRule */\n$managerRule->setCompanyId($companyId);\n$managerRule->setName('Manager Approval >= $500');\n$managerRule->setIsActive(true);\n$managerRule->setConditionsSerialized(json_encode([\n    'type' => 'Magento\\\\PurchaseOrderRule\\\\Model\\\\Rule\\\\Condition\\\\Combine',\n    'conditions' => [[\n        'type' => 'Magento\\\\PurchaseOrderRule\\\\Model\\\\Rule\\\\Condition\\\\Address',\n        'attribute' => 'grand_total',\n        'operator' => '>=',\n        'value' => 500\n    ]]\n]));\n// Approver role IDs reference company roles from the hierarchy\n$managerRule->setApproverRoleIds([$managerRoleId]);\n$ruleRepository->save($managerRule);",
    "examDomain": "Design",
    "objectiveTags": [
      "b2b",
      "company-accounts",
      "shared-catalog"
    ]
  },
  {
    "id": 175,
    "category": "Integration Architecture",
    "difficulty": "Hard",
    "examDomain": "Design",
    "objectiveTags": [
      "integration-patterns",
      "idempotency",
      "event-driven-architecture"
    ],
    "question": "A merchant runs Adobe Commerce with 120k SKUs and integrates with a PIM and ERP. During flash updates, the PIM can publish up to 30k product changes in 15 minutes. Business requires near-real-time storefront updates, no duplicate updates to ERP inventory, and graceful recovery if either side is down. Which architecture is the best fit?",
    "options": [
      {
        "id": "A",
        "text": "Run a cron every 5 minutes that exports full product snapshots from Commerce to ERP and imports full PIM snapshots into Commerce."
      },
      {
        "id": "B",
        "text": "Use synchronous REST calls in both directions for every product save, and fail the save if any downstream system times out."
      },
      {
        "id": "C",
        "text": "Use an event-driven pattern with outbox + queue consumers, idempotency keys per change event, and retry/dead-letter handling at integration boundaries."
      },
      {
        "id": "D",
        "text": "Replicate ERP and PIM tables into Commerce database and read them directly to avoid API overhead."
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct because it decouples write latency from downstream availability, preserves ordered durable delivery, and enables replay. Outbox guarantees events are not lost after Commerce commits. Idempotency keys prevent duplicate side effects when retries occur. Dead-letter handling keeps poison payloads from blocking the pipeline while preserving auditability.\n\nA is wrong because full snapshots are expensive, create stale windows, and increase conflict risk. B is wrong because tight synchronous coupling makes product save availability depend on external uptime. D is wrong because cross-system table replication introduces ownership and consistency risks and breaks service boundaries.",
    "codeExample": "// Pseudocode: event envelope with idempotency\n{\n  event_id: 'prod-1234-20260216T120301Z',\n  aggregate: 'product',\n  aggregate_id: 1234,\n  version: 981,\n  type: 'price.changed',\n  payload: { sku: 'SKU-1234', price: 99.00 }\n}"
  },
  {
    "id": 176,
    "category": "Checkout & Order Flow Architecture",
    "difficulty": "Hard",
    "examDomain": "Design",
    "objectiveTags": [
      "checkout-architecture",
      "latency-budget",
      "resilience-patterns"
    ],
    "question": "At checkout, Adobe Commerce calls tax, fraud, and shipping providers. P95 checkout step load must stay below 2.5s. One provider intermittently spikes to 6s and occasionally times out. Orders must still place with auditable risk decisions and no hidden charge recalculation after order placement. What should the architect design?",
    "options": [
      {
        "id": "A",
        "text": "Call providers sequentially and increase frontend timeout to 8 seconds to capture all responses."
      },
      {
        "id": "B",
        "text": "Use parallel calls with per-provider timeouts, fail-open only for non-blocking checks, persist decision state on order, and queue post-order reconciliation tasks with explicit customer communication rules."
      },
      {
        "id": "C",
        "text": "Skip external checks during checkout and run all checks after invoice creation."
      },
      {
        "id": "D",
        "text": "Cache one global fraud/tax/shipping response per cart ID for 24 hours to avoid spikes."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because it enforces a latency budget while preserving deterministic business behavior. Parallelization reduces wall-clock latency, per-provider timeouts avoid tail-latency collapse, and persisted decision snapshots prevent invisible post-order mutation. Async reconciliation is acceptable only when policy explicitly defines customer-visible outcomes.\n\nA degrades conversion and still fails under extended outages. C violates risk and taxation controls. D is unsafe because these responses depend on mutable inputs (address, items, promotions, fraud signals) and short-lived validity windows.",
    "codeExample": "// Decision snapshot persisted to order extension attributes\n{\n  tax_quote_id: 'tax-8891',\n  fraud_result: 'manual_review',\n  shipping_rate_source: 'cached-fastest-warehouse-2',\n  policy_version: 'checkout-policy-v4'\n}"
  },
  {
    "id": 177,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "plugin-chain",
      "error-handling"
    ],
    "question": "During review of a custom module, you find an around plugin on `\nMagento\\Catalog\\Api\\ProductRepositoryInterface::save` that catches `\\Throwable`, logs it, and returns the original product object to keep UI flow smooth. Which assessment is most accurate?",
    "options": [
      {
        "id": "A",
        "text": "Acceptable: admin users prefer no visible errors, and logging is enough for operations."
      },
      {
        "id": "B",
        "text": "Risky but acceptable if the logger writes to a dedicated file with rotation."
      },
      {
        "id": "C",
        "text": "Critical issue: swallowing exceptions hides write failures and can create data integrity drift between persisted and expected state."
      },
      {
        "id": "D",
        "text": "Only a performance issue; change to a before plugin to reduce overhead."
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct. Repository save is a transactional boundary; suppressing failures breaks caller guarantees and can trigger downstream corruption (index drift, stale cache assumptions, inconsistent integrations). Exceptions should be mapped or rethrown with context, not hidden.\n\nA and B prioritize UX over correctness and observability truth. D misidentifies the primary risk: this is not about plugin type overhead; it is about contract integrity."
  },
  {
    "id": 178,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "refactoring",
      "object-manager-anti-pattern",
      "testability"
    ],
    "question": "A service class injects five dependencies but still calls `ObjectManager::get()` inside a loop to resolve strategy classes based on product type. The author claims constructor injection is impossible because strategy count is dynamic. What is the best architect response?",
    "options": [
      {
        "id": "A",
        "text": "Keep it: runtime lookup is normal when strategy sets are unknown at compile time."
      },
      {
        "id": "B",
        "text": "Replace with service locator helper to avoid direct ObjectManager usage in business code."
      },
      {
        "id": "C",
        "text": "Refactor to DI-configured strategy pool (array argument / virtual types) and resolve by key from injected map."
      },
      {
        "id": "D",
        "text": "Use a global singleton registry to cache strategy instances after first lookup."
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct because it preserves Magento DI, improves testability, and keeps extensibility declarative in `di.xml`. Strategy pools are the canonical approach for runtime selection with compile-time wiring.\n\nA and B normalize service locator anti-patterns that hide dependencies. D adds global mutable state and lifecycle ambiguity."
  },
  {
    "id": 179,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "upgrade-safe-customization",
      "preferences",
      "conflict-analysis"
    ],
    "question": "Two third-party modules define preferences for the same core class. A team proposes adding a third preference in your custom module to restore expected behavior. Which approach should the architect recommend?",
    "options": [
      {
        "id": "A",
        "text": "Add a higher-priority preference and document module load order as a permanent fix."
      },
      {
        "id": "B",
        "text": "Replace all preferences with one custom forked class in `app/code` for deterministic behavior."
      },
      {
        "id": "C",
        "text": "Avoid preference stacking; isolate needed behavior via plugins, extension points, or composition and reduce preference surface area."
      },
      {
        "id": "D",
        "text": "Disable one third-party module in production and re-enable after peak season."
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct. Preference conflicts are brittle and high-risk in upgrades. Architects should minimize preferences and favor composable extension points where multiple modules can coexist.\n\nA and B increase long-term maintenance and upgrade risk. D is operationally unsafe and ignores root cause."
  },
  {
    "id": 180,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "code-review",
      "transaction-boundaries",
      "performance"
    ],
    "question": "A cron observer processes 80k rows in one DB transaction and dispatches external HTTP calls inside that transaction. Production shows lock waits and checkout slowdowns. What refactor is most appropriate?",
    "options": [
      {
        "id": "A",
        "text": "Keep one transaction for consistency and increase MySQL lock timeout."
      },
      {
        "id": "B",
        "text": "Split into bounded batches, keep DB transaction scope local to state change, and move HTTP side effects to async queue workers."
      },
      {
        "id": "C",
        "text": "Disable cron during business hours and run once nightly."
      },
      {
        "id": "D",
        "text": "Move job to frontend request/response so lock contention is visible immediately."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Long-lived transactions plus external I/O is a classic lock amplification anti-pattern. Batch processing with short transactions and queued side effects keeps OLTP contention low and improves recovery semantics.\n\nA hides symptoms. C increases business latency and does not scale. D worsens customer-facing reliability."
  },
  {
    "id": 181,
    "category": "Code Review & Refactoring",
    "difficulty": "Medium",
    "examDomain": "Review",
    "objectiveTags": [
      "refactoring",
      "solid-principles",
      "maintainability"
    ],
    "question": "You review a 1,200-line class that validates checkout inputs, calculates pricing, triggers integrations, builds email payloads, and writes audit logs. Which first refactoring move gives highest risk reduction with least functional disruption?",
    "options": [
      {
        "id": "A",
        "text": "Rewrite it entirely into a new module to start clean."
      },
      {
        "id": "B",
        "text": "Introduce an orchestrator that delegates to extracted collaborators with clear interfaces for validation, pricing, integration, and notifications."
      },
      {
        "id": "C",
        "text": "Keep class intact and add comments documenting each region."
      },
      {
        "id": "D",
        "text": "Convert all methods to static so they are easier to call from multiple entry points."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because it incrementally introduces boundaries without destabilizing behavior. It enables targeted testing, clearer ownership, and safer iterative extraction.\n\nA is high-risk big-bang rewrite. C does not solve coupling. D increases global coupling and harms testability."
  },
  {
    "id": 182,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "plugin-chain",
      "execution-order",
      "debuggability"
    ],
    "question": "Checkout total calculation is modified by five plugins from different modules. Results differ between environments. Which review action is most effective first step?",
    "options": [
      {
        "id": "A",
        "text": "Increase PHP memory and OPcache because plugin chains are memory-sensitive."
      },
      {
        "id": "B",
        "text": "Map plugin execution order (`sortOrder` + module sequence), document before/around/after effects, and remove non-deterministic side effects from around plugins."
      },
      {
        "id": "C",
        "text": "Replace all plugins with one preference for total collector class."
      },
      {
        "id": "D",
        "text": "Cache total results globally per customer group to avoid recalculation."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Deterministic understanding of interception order is the prerequisite to fixing environment-specific behavior drift. Around plugins that mutate shared state often create hard-to-reason bugs and should be minimized.\n\nA is unrelated. C trades one conflict class for another. D risks stale totals and legal/compliance issues."
  },
  {
    "id": 183,
    "category": "Code Review & Refactoring",
    "difficulty": "Medium",
    "examDomain": "Review",
    "objectiveTags": [
      "api-design",
      "backward-compatibility",
      "service-contracts"
    ],
    "question": "A proposed change removes an existing method from an interface marked `@api` and replaces it with a new method signature. Release is planned as a patch update. What is the architect recommendation?",
    "options": [
      {
        "id": "A",
        "text": "Approve if all internal modules are updated in the same release."
      },
      {
        "id": "B",
        "text": "Approve only for Commerce Cloud projects where deployment is controlled."
      },
      {
        "id": "C",
        "text": "Reject as backward-incompatible; introduce additive API changes and deprecate old behavior for a major-version path."
      },
      {
        "id": "D",
        "text": "Allow removal if integration tests pass in CI."
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct. `@api` contracts must preserve backward compatibility across supported versions. Breaking changes require major-version strategy with migration guidance.\n\nA, B, and D ignore third-party and external integration stability obligations."
  },
  {
    "id": 184,
    "category": "Code Review & Refactoring",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "cacheability",
      "frontend-architecture",
      "review-findings"
    ],
    "question": "A code review finds `cacheable=\"false\"` added to a layout block rendered on category pages to show customer-specific badges. Traffic is 4M page views/day with Varnish enabled. What is the correct review outcome?",
    "options": [
      {
        "id": "A",
        "text": "Approve; correctness for customer data is more important than cache hit ratio."
      },
      {
        "id": "B",
        "text": "Reject; move customer-specific badge data to private content sections or AJAX hydration to keep page-level FPC cacheable."
      },
      {
        "id": "C",
        "text": "Approve but raise TTL to offset lower cacheability."
      },
      {
        "id": "D",
        "text": "Approve and add Redis memory to absorb extra backend traffic."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Disabling cache at block level can collapse FPC effectiveness for high-traffic pages. Customer-specific fragments should be handled via private content or controlled client-side hydration.\n\nA, C, and D treat symptoms while preserving a structural anti-pattern."
  },
  {
    "id": 185,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "troubleshooting",
      "idempotency",
      "payments"
    ],
    "question": "Payment provider retries webhook callbacks when it does not receive 200 within 3 seconds. During network jitter, duplicate invoices are created for some orders. Which root-cause fix is best?",
    "options": [
      {
        "id": "A",
        "text": "Increase webhook timeout to 15 seconds and keep existing logic."
      },
      {
        "id": "B",
        "text": "Apply a mutex lock around invoice creation only."
      },
      {
        "id": "C",
        "text": "Implement idempotency keys from provider event IDs, persist processed-event ledger, and return fast acknowledgement before non-critical side effects."
      },
      {
        "id": "D",
        "text": "Disable retries on the payment provider side."
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct. Webhook handling must be idempotent under at-least-once delivery. Persisting event IDs and short-circuiting duplicates guarantees exactly-once business effect. Fast ACK reduces retry storms.\n\nA delays but does not remove duplicate risk. B alone is fragile across multi-node workers and restarts. D weakens reliability and typically cannot be fully controlled by the merchant."
  },
  {
    "id": 186,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "graphql",
      "performance-diagnostics",
      "n-plus-one"
    ],
    "question": "GraphQL response time for product listing jumped from 450ms to 2.8s after adding custom fields. Profiler shows repeated repository calls per item. What is the most effective architectural correction?",
    "options": [
      {
        "id": "A",
        "text": "Increase GraphQL HTTP cache TTL and accept slower uncached requests."
      },
      {
        "id": "B",
        "text": "Refactor resolvers to batch-load data (data provider / batch resolver pattern) and prefetch required entities per page request."
      },
      {
        "id": "C",
        "text": "Move all custom fields into synchronous REST calls from frontend after initial GraphQL response."
      },
      {
        "id": "D",
        "text": "Disable custom fields for mobile traffic only."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. The observed symptom is N+1 query behavior. Batch resolver/data provider patterns collapse repeated lookups into bounded queries and restore predictable scaling.\n\nA masks only cacheable traffic. C increases round trips and complexity. D is a business workaround, not an engineering fix."
  },
  {
    "id": 187,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "database-deadlocks",
      "operational-debugging",
      "checkout"
    ],
    "question": "After peak launch, random checkout failures show SQL deadlocks involving inventory reservations and custom order attributes. Failures spike when async consumer lag grows. What should be prioritized first?",
    "options": [
      {
        "id": "A",
        "text": "Raise MySQL deadlock timeout and retry at webserver layer."
      },
      {
        "id": "B",
        "text": "Standardize lock acquisition order across involved writes, shorten transaction scope, and move non-transactional writes out of checkout transaction."
      },
      {
        "id": "C",
        "text": "Disable inventory reservations to reduce write contention."
      },
      {
        "id": "D",
        "text": "Route all writes to a replica during peak traffic."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because deadlock frequency is reduced by deterministic lock ordering and minimal transaction scope. Checkout transactions should only include strictly required atomic writes.\n\nA may reduce visible errors but preserves contention. C breaks MSI correctness. D is invalid because replicas are read targets, not write consistency boundaries."
  },
  {
    "id": 188,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Medium",
    "examDomain": "Review",
    "objectiveTags": [
      "cache-invalidation",
      "catalog-pricing",
      "root-cause-analysis"
    ],
    "question": "Prices on PDP are occasionally stale for 3-5 minutes after merchandising updates, while cart shows correct totals. Indexers are up to date. Which issue is most likely?",
    "options": [
      {
        "id": "A",
        "text": "Price index corruption due to customer group dimension mismatch."
      },
      {
        "id": "B",
        "text": "FPC/edge cache invalidation lag for catalog price-related tags while cart totals are recalculated dynamically."
      },
      {
        "id": "C",
        "text": "Session storage eviction in Redis database 2."
      },
      {
        "id": "D",
        "text": "Checkout totals collector sort order conflict."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. PDP often relies on cached content and tag-driven invalidation, while cart recalculates live totals from quote context. This symptom pattern points to cache invalidation timing rather than index correctness.\n\nA would usually show broader inconsistency. C affects session continuity, not deterministic price freshness. D affects cart/order computation, not isolated PDP staleness."
  },
  {
    "id": 189,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "message-queue",
      "memory-leak",
      "consumer-stability"
    ],
    "question": "A long-running queue consumer starts at 250MB memory and grows to 1.8GB within two hours before being OOM-killed. Throughput drops over time. What investigation path is most appropriate?",
    "options": [
      {
        "id": "A",
        "text": "Increase container memory limit to 3GB and monitor again."
      },
      {
        "id": "B",
        "text": "Disable GC for better speed and rely on worker restarts nightly."
      },
      {
        "id": "C",
        "text": "Profile object retention across message loop, clear per-message references, avoid static caches of payloads, and enforce controlled consumer max-messages restart policy."
      },
      {
        "id": "D",
        "text": "Switch queue backend to database tables so memory pressure moves to MySQL."
      }
    ],
    "correctAnswers": [
      "C"
    ],
    "explanation": "C is correct. The symptom indicates retention across message boundaries. Root-cause work includes leak profiling, loop-scope cleanup, and bounded worker lifecycle. Controlled restarts are acceptable guardrails, not substitutes for leak fixes.\n\nA and B are symptom treatments. D changes bottleneck location and can reduce queue scalability."
  },
  {
    "id": 190,
    "category": "Troubleshooting & Root Cause Analysis",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "cron",
      "multi-node",
      "race-condition"
    ],
    "question": "In a three-node deployment, some cron tasks run twice and send duplicate customer emails. `cron_schedule` shows overlapping `running` states from different hosts. What is the correct architectural remediation?",
    "options": [
      {
        "id": "A",
        "text": "Keep cron on all nodes and add host-level lock files under `/tmp`."
      },
      {
        "id": "B",
        "text": "Designate a single cron runner node, keep process isolation for heavy groups, and enforce stale-job recovery settings (`schedule_lifetime`)."
      },
      {
        "id": "C",
        "text": "Reduce cron frequency from every minute to every fifteen minutes."
      },
      {
        "id": "D",
        "text": "Move all cron tasks to synchronous admin-triggered actions."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Multi-node cron without strict ownership causes race conditions. Single runner with sane lifecycle settings preserves exactly-once operational intent.\n\nA fails on non-shared filesystems. C does not remove race conditions. D degrades reliability and operations."
  },
  {
    "id": 191,
    "category": "Security",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "security-hardening",
      "ssrf",
      "integration-boundaries"
    ],
    "question": "A custom admin feature lets users configure a webhook URL for outbound notifications. Security review flags SSRF risk. Which mitigation set is architecturally correct?",
    "options": [
      {
        "id": "A",
        "text": "Allow any HTTPS URL and rely on firewall egress rules only."
      },
      {
        "id": "B",
        "text": "Validate against allowlist (host/domain), block private/link-local IP ranges after DNS resolution, enforce scheme/port constraints, and sign outbound payloads."
      },
      {
        "id": "C",
        "text": "Encrypt webhook URL in database and keep runtime behavior unchanged."
      },
      {
        "id": "D",
        "text": "Run requests through browser CORS checks to prevent internal calls."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because SSRF defense requires strict destination validation and network boundary controls. DNS resolution checks and private-range denial are essential. Payload signing adds integrity for receivers.\n\nA is incomplete defense-in-depth. C protects at-rest secrecy but not request destination abuse. D misunderstands server-side request context."
  },
  {
    "id": 192,
    "category": "Security",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "csp",
      "xss-prevention",
      "frontend-security"
    ],
    "question": "A third-party script is required on checkout confirmation page. Team proposes `Content-Security-Policy: script-src *` to avoid rollout risk. What should the architect approve?",
    "options": [
      {
        "id": "A",
        "text": "Approve wildcard for one release and remove later."
      },
      {
        "id": "B",
        "text": "Use strict host allowlist with nonce/hash strategy where possible, limit scope to required route, and monitor CSP violation reports."
      },
      {
        "id": "C",
        "text": "Disable CSP in production and rely on WAF signatures."
      },
      {
        "id": "D",
        "text": "Move script into inline HTML so CSP does not apply."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Checkout surfaces sensitive data and requires least-privilege script policy. Route-scoped CSP with reporting supports safe rollout and monitoring.\n\nA and C materially expand XSS blast radius. D is false; inline scripts are typically more restricted and require explicit policy controls."
  },
  {
    "id": 193,
    "category": "Security",
    "difficulty": "Medium",
    "examDomain": "Review",
    "objectiveTags": [
      "api-security",
      "least-privilege",
      "token-management"
    ],
    "question": "An integration token currently has full admin ACL and is used by a middleware service that only needs catalog read + order shipment creation. What is the best remediation?",
    "options": [
      {
        "id": "A",
        "text": "Keep admin token but rotate weekly."
      },
      {
        "id": "B",
        "text": "Create dedicated integration with minimum required ACL resources and separate tokens by environment/workload."
      },
      {
        "id": "C",
        "text": "Use one token per developer machine for easier debugging."
      },
      {
        "id": "D",
        "text": "Switch to customer token to reduce privileges automatically."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because least privilege limits blast radius and supports auditability. Workload/environment separation reduces lateral risk.\n\nA improves hygiene but not privilege scope. C increases unmanaged credential sprawl. D changes auth model and does not match integration use case."
  },
  {
    "id": 194,
    "category": "Security",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "secrets-management",
      "cloud-security",
      "incident-response"
    ],
    "question": "A production incident exposed an API key in application logs. Which architect-level response is most complete?",
    "options": [
      {
        "id": "A",
        "text": "Delete logs from the server and continue with same key."
      },
      {
        "id": "B",
        "text": "Rotate compromised secret immediately, revoke old credentials, scrub log sinks where feasible, add log redaction controls, and move secret retrieval to environment/secret store only."
      },
      {
        "id": "C",
        "text": "Mask the key in frontend UI and keep backend logging unchanged."
      },
      {
        "id": "D",
        "text": "Encrypt all logs at rest and treat incident as resolved."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because response must include containment, credential invalidation, and prevention controls. Redaction and secret-store-only access reduce recurrence.\n\nA, C, and D leave active credential risk or ignore data already exfiltrated to downstream log systems."
  },
  {
    "id": 195,
    "category": "Security",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "secure-coding",
      "input-validation",
      "webapi"
    ],
    "question": "A custom REST endpoint accepts arbitrary JSON and maps fields directly to a model `setData($payload)` before save. What is the strongest correction?",
    "options": [
      {
        "id": "A",
        "text": "Keep dynamic mapping and add `strip_tags()` on all string values."
      },
      {
        "id": "B",
        "text": "Define strict service contract DTO, explicit field whitelist/validation, server-side authorization checks, and reject unknown fields."
      },
      {
        "id": "C",
        "text": "Rely on frontend form validation and continue server-side passthrough."
      },
      {
        "id": "D",
        "text": "Base64-encode JSON before save to prevent injection."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Explicit contracts and boundary validation prevent mass assignment and privilege escalation vectors. Unknown-field rejection preserves API integrity.\n\nA is superficial sanitization. C trusts untrusted clients. D provides no security control."
  },
  {
    "id": 196,
    "category": "Testing",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "testing-strategy",
      "risk-based-testing",
      "checkout"
    ],
    "question": "You are reviewing a checkout customization that modifies totals, payment method availability, and order placement observers. Team only wrote unit tests with mocks. What additional test set is most critical before release?",
    "options": [
      {
        "id": "A",
        "text": "No additional tests; unit tests already validate business logic."
      },
      {
        "id": "B",
        "text": "Add integration tests for totals/order placement and at least one end-to-end functional path to validate framework wiring and data persistence."
      },
      {
        "id": "C",
        "text": "Add only visual regression tests on checkout pages."
      },
      {
        "id": "D",
        "text": "Replace all unit tests with manual QA sign-off."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Checkout changes cross DI wiring, DB transactions, and framework orchestration that mocks cannot fully represent. Integration plus targeted E2E gives high-confidence coverage.\n\nA misses integration risk. C covers UI only. D reduces repeatability and safety."
  },
  {
    "id": 197,
    "category": "Testing",
    "difficulty": "Medium",
    "examDomain": "Review",
    "objectiveTags": [
      "mftf",
      "flaky-tests",
      "stability"
    ],
    "question": "An MFTF scenario fails intermittently after asynchronous index updates. Engineers inserted fixed `wait(20)` steps and failures dropped but CI time doubled. What is the better solution?",
    "options": [
      {
        "id": "A",
        "text": "Keep fixed waits because stability is more important than speed."
      },
      {
        "id": "B",
        "text": "Replace static waits with condition-based waits/assertions tied to UI state or backend completion signals."
      },
      {
        "id": "C",
        "text": "Disable flaky test from pipeline and run weekly."
      },
      {
        "id": "D",
        "text": "Convert MFTF test to unit test to remove browser timing variance."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Condition-based waits reduce nondeterminism and runtime while preserving intent.\n\nA accumulates pipeline latency and still flakes under variance. C hides risk. D changes test scope and no longer validates user workflow."
  },
  {
    "id": 198,
    "category": "Testing",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "contract-testing",
      "service-contracts",
      "backward-compatibility"
    ],
    "question": "A module exposes a service contract consumed by three internal modules and one external integration. A refactor changes response field nullability. Which testing strategy best guards compatibility?",
    "options": [
      {
        "id": "A",
        "text": "Only run unit tests for the refactored module."
      },
      {
        "id": "B",
        "text": "Add contract/integration tests asserting schema and behavior invariants, including nullability expectations and extension attribute presence."
      },
      {
        "id": "C",
        "text": "Run static analysis only because interfaces compile."
      },
      {
        "id": "D",
        "text": "Rely on staging smoke test that checks HTTP 200 responses."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Compatibility depends on behavior guarantees, not compile success alone. Contract tests catch subtle serialization and nullability breaks before release.\n\nA, C, and D are insufficient for cross-module consumer safety."
  },
  {
    "id": 199,
    "category": "Testing",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "performance-testing",
      "release-gates",
      "regression-prevention"
    ],
    "question": "A high-traffic merchant had repeated regressions where category page TTFB increased after feature releases. Which architect-level quality gate is most effective?",
    "options": [
      {
        "id": "A",
        "text": "Manual spot checks in browser before deployment."
      },
      {
        "id": "B",
        "text": "Automated performance baseline tests in CI with threshold gates for key paths and trend reporting over builds."
      },
      {
        "id": "C",
        "text": "Post-release monitoring only; rollback if issue appears."
      },
      {
        "id": "D",
        "text": "Enforce PHP code style stricter rules."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Reliable prevention requires pre-release quantitative gates plus historical trend visibility.\n\nA and C are reactive. D improves consistency but does not detect runtime performance regressions."
  },
  {
    "id": 200,
    "category": "Database",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "database-design",
      "query-optimization",
      "reporting"
    ],
    "question": "A custom admin report joins `sales_order`, `sales_order_item`, and two EAV tables and now takes 35 seconds on production data. Business needs sub-3-second response for date-range reports. Which option is best?",
    "options": [
      {
        "id": "A",
        "text": "Run the same query on every request and increase MySQL buffer sizes."
      },
      {
        "id": "B",
        "text": "Introduce a purpose-built denormalized reporting table/materialized snapshot updated asynchronously, with indexed query dimensions."
      },
      {
        "id": "C",
        "text": "Use `SELECT *` and paginate at PHP layer to reduce DB time."
      },
      {
        "id": "D",
        "text": "Move report generation into frontend JavaScript loops."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct for operational reporting at scale. OLTP schemas are not optimized for heavy analytical joins; asynchronous projection tables are standard architecture for fast reads.\n\nA may help marginally but does not change complexity class. C and D worsen data transfer and processing overhead."
  },
  {
    "id": 201,
    "category": "Database",
    "difficulty": "Medium",
    "examDomain": "Review",
    "objectiveTags": [
      "index-strategy",
      "query-plan",
      "database-review"
    ],
    "question": "A query filtering by `(store_id, status, created_at)` scans millions of rows. Existing indexes are on each single column only. What is the best review recommendation?",
    "options": [
      {
        "id": "A",
        "text": "Add one composite index aligned to filter selectivity/order and verify with EXPLAIN."
      },
      {
        "id": "B",
        "text": "Add indexes to every column in the table to maximize optimizer choices."
      },
      {
        "id": "C",
        "text": "Disable indexes to speed up inserts and rely on cache."
      },
      {
        "id": "D",
        "text": "Sort in PHP to avoid SQL planner complexity."
      }
    ],
    "correctAnswers": [
      "A"
    ],
    "explanation": "A is correct. Composite indexes aligned with predicate and sorting patterns usually outperform multiple single-column indexes for this workload. EXPLAIN confirms plan quality.\n\nB increases write cost and often harms plan selection. C is destructive for read performance. D moves work away from the database engine optimized for it."
  },
  {
    "id": 202,
    "category": "Database",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "data-retention",
      "archiving",
      "operational-readiness"
    ],
    "question": "Order tables exceeded 400M rows and maintenance windows cannot complete. Legal requires 7-year retention but hot-path operations only need 18 months. Which strategy is most appropriate?",
    "options": [
      {
        "id": "A",
        "text": "Delete old orders permanently to restore performance."
      },
      {
        "id": "B",
        "text": "Archive older records to a separate data store/schema with governed access and keep operational tables lean, plus documented restore/report pathways."
      },
      {
        "id": "C",
        "text": "Keep all rows in primary tables and double DB CPU."
      },
      {
        "id": "D",
        "text": "Export CSV once and remove database backups."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct: it balances legal retention, operational performance, and auditability. Architectures should separate hot operational workload from long-term historical access.\n\nA violates retention policy. C is expensive and often insufficient. D undermines recoverability and governance."
  },
  {
    "id": 203,
    "category": "Configuration & XML",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "xml-merge-rules",
      "module-sequence",
      "debugging-config"
    ],
    "question": "A custom total collector intermittently disappears after deployments with different module sets enabled. `sales.xml` definitions exist in multiple modules with similar item names. What should review focus on first?",
    "options": [
      {
        "id": "A",
        "text": "Raise PHP memory limit to ensure XML merge completes."
      },
      {
        "id": "B",
        "text": "Inspect XML merge precedence, duplicate item keys, and module sequence dependencies to ensure deterministic collector registration."
      },
      {
        "id": "C",
        "text": "Move collector declaration to `config.php` for stronger priority."
      },
      {
        "id": "D",
        "text": "Clear browser cache after deployment."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Collector disappearance across module combinations strongly suggests merge-key collision or sequence-related override behavior. Deterministic naming and explicit dependency order are required.\n\nA and D are unrelated. C misuses configuration location and does not solve merge semantics."
  },
  {
    "id": 204,
    "category": "Configuration & XML",
    "difficulty": "Medium",
    "examDomain": "Review",
    "objectiveTags": [
      "area-specific-di",
      "configuration-scope",
      "review-findings"
    ],
    "question": "A team placed admin-only preference overrides in global `etc/di.xml`. API behavior changed unexpectedly. Which correction should be recommended?",
    "options": [
      {
        "id": "A",
        "text": "Keep global config and add conditionals in class methods for admin area."
      },
      {
        "id": "B",
        "text": "Move overrides to `etc/adminhtml/di.xml` so scope is limited to admin area."
      },
      {
        "id": "C",
        "text": "Use plugins with runtime checks for every method call."
      },
      {
        "id": "D",
        "text": "Duplicate class and switch via composer autoload for backend requests."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Area-specific DI is the intended mechanism to avoid cross-area behavior bleed.\n\nA and C add runtime complexity and overhead. D is brittle and hard to maintain."
  },
  {
    "id": 205,
    "category": "Logging & Debugging",
    "difficulty": "Hard",
    "examDomain": "Review",
    "objectiveTags": [
      "observability",
      "distributed-tracing",
      "incident-debugging"
    ],
    "question": "An order request traverses CDN -> web node -> Adobe Commerce -> middleware -> ERP. Incident resolution takes hours because logs cannot be correlated across systems. Which architecture change provides the highest diagnostic value?",
    "options": [
      {
        "id": "A",
        "text": "Increase each system log level to DEBUG permanently."
      },
      {
        "id": "B",
        "text": "Introduce end-to-end correlation IDs propagated through HTTP headers, queue metadata, and structured logs; include it in alert payloads."
      },
      {
        "id": "C",
        "text": "Store all logs in local files on each node for faster writes."
      },
      {
        "id": "D",
        "text": "Disable retry logic so failures appear only once."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Correlation IDs are foundational for distributed debugging and mean-time-to-resolution reduction. Structured propagation across sync and async boundaries preserves causality.\n\nA increases noise/cost without joinability. C fragments observability. D harms resilience."
  },
  {
    "id": 206,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Hard",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cloud-deployment",
      "build-deploy-phases",
      "zero-downtime"
    ],
    "question": "A team runs `setup:upgrade` and cache warmup in the Cloud build phase to shorten deploy time. Deploys intermittently fail and rollback. What is the correct phase strategy?",
    "options": [
      {
        "id": "A",
        "text": "Keep current approach; build is always safest for all commands."
      },
      {
        "id": "B",
        "text": "Run compile/static build artifacts in build phase, execute environment-dependent operations (DB/schema/config) in deploy, and use post-deploy for warmup/health checks."
      },
      {
        "id": "C",
        "text": "Move everything to post-deploy to avoid deploy lock."
      },
      {
        "id": "D",
        "text": "Run all commands manually on production after deployment."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Build should create immutable artifacts; deploy handles runtime environment and database-sensitive actions; post-deploy handles non-critical warmup and verification.\n\nA and C blur phase responsibilities and increase risk. D removes repeatability and automation safety."
  },
  {
    "id": 207,
    "category": "Adobe Commerce Cloud",
    "difficulty": "Medium",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "environment-variables",
      "configuration-management",
      "cloud-ops"
    ],
    "question": "Different environments show inconsistent Redis/session behavior. Team committed env-specific values in module config and partially in `.magento.env.yaml`. What should the architect enforce?",
    "options": [
      {
        "id": "A",
        "text": "Keep mixed approach so each team can choose preferred config location."
      },
      {
        "id": "B",
        "text": "Centralize environment-specific runtime configuration in Cloud env mechanisms/variables with clear precedence documentation and remove environment-specific values from code artifacts."
      },
      {
        "id": "C",
        "text": "Store all environment differences in frontend `.env` files."
      },
      {
        "id": "D",
        "text": "Hardcode production settings and copy DB to lower environments weekly."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because it preserves twelve-factor style separation of code and environment, improving predictability across stages.\n\nA creates drift. C is wrong scope. D is unsafe and non-compliant for many orgs."
  },
  {
    "id": 208,
    "category": "Deployment & Cloud",
    "difficulty": "Hard",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "deployment-strategy",
      "backward-compatible-migrations",
      "release-safety"
    ],
    "question": "You deploy weekly with near-zero downtime requirement. A feature introduces schema changes and code relying on new columns. What rollout pattern is safest?",
    "options": [
      {
        "id": "A",
        "text": "Deploy code and destructive schema change together, then flush all caches."
      },
      {
        "id": "B",
        "text": "Use backward-compatible expand/migrate/contract sequence across releases: add nullable/new structures first, dual-write/read as needed, then remove old schema only after full cutover."
      },
      {
        "id": "C",
        "text": "Run schema changes manually after traffic drops at night."
      },
      {
        "id": "D",
        "text": "Disable old code paths with feature flags before schema exists."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct and is the standard safe migration pattern for continuous delivery. It keeps old and new versions compatible during rollout windows and rollback scenarios.\n\nA risks runtime breakage. C is operationally fragile. D can break before dependencies are ready."
  },
  {
    "id": 209,
    "category": "Caching",
    "difficulty": "Hard",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "cache-invalidation",
      "fastly-varnish",
      "operational-readiness"
    ],
    "question": "After each deployment, homepage and category cache hit ratio drops below 20% for 30 minutes, causing backend saturation. What is the best cache strategy improvement?",
    "options": [
      {
        "id": "A",
        "text": "Purge all cache globally on every release to guarantee correctness."
      },
      {
        "id": "B",
        "text": "Adopt targeted tag-based invalidation and controlled warmup of critical routes (home, top categories, PDP hot set) before opening full traffic."
      },
      {
        "id": "C",
        "text": "Disable Varnish and rely only on application cache."
      },
      {
        "id": "D",
        "text": "Lower TTL to 30 seconds to refill faster."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct. Tag-scoped invalidation plus warmup prevents avoidable cold-start storms and preserves origin capacity.\n\nA over-purges and creates thundering herd effects. C removes a critical performance layer. D reduces cache utility and can worsen load."
  },
  {
    "id": 210,
    "category": "Web API",
    "difficulty": "Hard",
    "examDomain": "ConfigureDeploy",
    "objectiveTags": [
      "webapi",
      "async-bulk",
      "operational-scaling"
    ],
    "question": "A partner sends 200k product stock updates during peak hours through synchronous REST calls, causing API saturation and checkout latency spikes. Which architecture should be implemented?",
    "options": [
      {
        "id": "A",
        "text": "Increase PHP-FPM workers and keep synchronous endpoint pattern."
      },
      {
        "id": "B",
        "text": "Move integration to async bulk API/queue-based ingestion with idempotent payload keys and consumer autoscaling policies."
      },
      {
        "id": "C",
        "text": "Throttle checkout endpoints so stock updates can complete first."
      },
      {
        "id": "D",
        "text": "Ask partner to split calls across more IP addresses."
      }
    ],
    "correctAnswers": [
      "B"
    ],
    "explanation": "B is correct because high-volume data ingestion should be decoupled from synchronous request paths. Async bulk processing smooths load, supports retries, and protects customer-facing latency.\n\nA scales symptoms only. C harms revenue-critical flows. D sidesteps architecture and can worsen abuse controls."
  }
]
